<!DOCTYPE html>
<!-- 
 Licensed Materials - Property of IBM
 Copyright IBM Corp. 2014
 US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 -->
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"><![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9"><![endif]-->
<!--[if gt IE 8]><!--><html class="no-js"><!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>{{ site-title }}</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>

    <div id="notsupported">
        <h1>{{ unsupported-header }}</h1>
        <h2>{{ unsupported-sudHeader }}</h2>
        <p>{{ unsupported-infotext }}</p>
        <ul class="browserlist">
            <li class="browser chrome"><a href="https://www.google.com/chrome" target="_blank">Google Chrome</a></li>
            <li class="browser firefox"><a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a> {{ unsupported-firefox-versioninfo }}</li>
            <!--li class="browser safari"><a href="https://www.google.com/search?q=download+safari" target="_blank">Safari</a> {{ unsupported-safari-versioninfo }}</li>
            <li class="browser chromeframe"><a href="http://www.google.com/chromeframe/" target="_blank">Google Chrome Frame for Internet Explorer</a></li-->
        </ul>
    </div>

    <div id="main-container">

        <h1>{{ page-headline }}</h1>
        <h2>{{ uic-version }} 4.0.0</h2>

        <form class="configwizard clearfix" id="configwizard-form" method="post">

            <div class="configwizard-slide">

                <section class="config-section mandatory-section in">
                    <fieldset>
                        <legend><h1>{{ browserService-header }}</h1></legend>
                        <article>
                            <header>
                                <h1>{{ browserService-subHeader }}</h1>
                            </header>
                            <dl>
                                <dt>
                                    <label for="browserService-jQuery">
                                        <input type="radio" class="browserService" name="browserService" id="browserService-jQuery" value="jQuery"> {{ browserService-jQuery }}
                                    </label>
                                    <span class="help-icon"><span class="help-text">{{ browserService-jQuery-helptext }}</span></span>
                                </dt>
                                <dd>
                                    <p>{{ browserService-jQuery-description }}</p>
                                </dd>
                                <dt>
                                    <label for="browserService-w3c">
                                        <input type="radio" class="browserService" name="browserService" id="browserService-w3c" value="w3c" checked> {{ browserService-w3c }}
                                    </label>
                                    <span class="help-icon"><span class="help-text">{{ browserService-w3c-helptext }}</span></span>
                                </dt>
                                <dd>
                                    <p>{{ browserService-w3c-description }}</p>
                                </dd>
                            </dl>
                            <details>
                                <summary>{{ advanced-options }}</summary>
                                <dl class="services-browser-sizzleURL-container" id="services-browser-sizzleURL-container">
                                    <dt>
                                        <label for="services-browser-sizzleURL">{{ browserService-sizzleURL }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-sizzleURL-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-browser-sizzleURL" name="config.services.browser.sizzleURL"  value="" pattern="[-a-zA-Z0-9_/.,;:?#=+&]*">
                                    </dd>
                                    <dt>
                                        <label for="services-browser-sizzleObject">{{ browserService-sizzleObject }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-sizzleObject-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-browser-sizzleObject" name="config.services.browser.sizzleObject"  value="window.Sizzle" />
                                    </dd>
                                </dl>
                                <dl class="services-browser-jQuery-container" id="services-browser-jQuery-container" style="display: none;">
                                    <dt>
                                        <label for="services-browser-jQueryObject">{{ browserService-jQueryObject }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-jQueryObject-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-browser-jQueryObject" name="config.services.browser.jQueryObject"  value="window.jQuery" disabled="disabled" />
                                    </dd>
                                </dl>
                                <dl>
                                    <dt>
                                        <label for="services-browser-blacklist">{{ browserService-blacklistedElements }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-blacklistedElements-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-browser-blacklist" name="config.services.browser.blacklist" placeholder="{{ browserService-blacklistedElements-placeholder }}">
                                    </dd>
                                    <dt>
                                        <label for="services-browser-customid">{{ browserService-customID }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-customID-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-browser-customid" name="config.services.browser.customid[]" placeholder="{{ browserService-customID-placeholder }}">
                                    </dd>
                                    <dt>
                                        <label for="core-ieExcludedLinks">{{ browserService-ieExcludedLinks }}
                                            <span class="help-icon"><span class="help-text">{{ browserService-ieExcludedLinks-helptext }}</span></span>
                                        </label>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="core-ieExcludedLinks" name="config.core.ieExcludedLinks" placeholder="{{ browserService-ieExcludedLinks-placeholder }}">
                                    </dd>
                                </dl>
                            </details>
                        </article>
                    </fieldset>
                </section>

                <section class="config-section mandatory-section">
                    <fieldset>
                        <legend><h1>{{ queueService-header }}</h1></legend>
                        <article>
                            <header>
                                <h1>{{ queueService-subHeader }}</h1>
                            </header>
                            <details class="services-queue-0 queueService-queue-default data-bindings" open>
                                <summary>
                                    {{ queueService-queueName }} <span class="services-queue-0-qid">DEFAULT</span>,
                                    {{ queueService-queueEndpoint }} <span class="services-queue-0-endpoint">/TealeafTarget.aspx</span>,
                                    {{ queueService-queueSize }} <span class="services-queue-0-maxEvents">25</span>,
                                    {{ queueService-queueTimer }} <span class="services-queue-0-timerinterval">0</span>
                                </summary>
                                <dl>
                                    <dt>
                                        <label for="services-queue-0-qid">{{ queueService-queueName }}</label>
                                        <span class="help-icon"><span class="help-text">{{ queueService-queueName-helptext }}</span></span>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-queue-0-qid" name="config.services.queue.queues[0].qid" value="DEFAULT" readonly required>
                                    </dd>
                                    <dt>
                                        <label for="services-queue-0-endpoint">{{ queueService-queueEndpoint }}</label>
                                        <span class="help-icon"><span class="help-text">{{ queueService-queueEndpoint-helptext }}</span></span>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="services-queue-0-endpoint" name="config.services.queue.queues[0].endpoint" value="/TealeafTarget.aspx" required pattern="[-a-zA-Z0-9_/.,;:?#=+&]*">
                                    </dd>
                                    <dt>
                                        <label for="services-queue-0-maxEvents">{{ queueService-queueSize }}</label>
                                        <span class="help-icon"><span class="help-text">{{ queueService-queueSize-helptext }}</span></span>
                                    </dt>
                                    <dd>
                                        <input class="numberfield" id="services-queue-0-maxEvents" name="config.services.queue.queues[0].maxEvents" value="25" min="1" max="99" required pattern="[0-9]*">
                                    </dd>
                                    <dt>
                                        <label for="services-queue-0-timerinterval">{{ queueService-queueTimer }}</label>
                                        <span class="help-icon"><span class="help-text">{{ queueService-queueTimer-helptext }}</span></span>
                                    </dt>
                                    <dd>
                                        <input class="numberfield" id="services-queue-0-timerinterval" name="config.services.queue.queues[0].timerinterval" value="0">
                                        <span class="services-queue-0-timerinterval">0</span>{{ queueService-queueTimer-label }}
                                    </dd>
                                    <details>
										<summary>{{ advanced-options }}</summary>
										<dt>
											<label for="services-queue-0-crossDomainEnabled">
												<input type="checkbox" name="config.services.queue.queues[0].crossDomainEnabled" id="services-queue-0-crossDomainEnabled" data-toggles="services-crossDomainEnabled-container" value="true"> {{ queueService-crossDomainEnabled }}
											</label>
										</dt>
										<dd></dd>
										<fieldset id="services-crossDomainEnabled-container"  style="display: none;">
											<dt>
												<label for="services-queue-0- crossDomainFrameSelector">{{ queueService-crossDomainFrameSelector }}</label>
												<span class="help-icon"><span class="help-text">{{ queueService-crossDomainFrameSelector-helptext }}</span></span>
											</dt>
											<dd>
												<input class="textfield" id="services-queue-0- crossDomainFrameSelector" name="config.services.queue.queues[0].crossDomainFrameSelector" value="" >
											</dd>
										</fieldset>
										<dt>
											<label for="config.services.queue.asyncReqOnUnload">
												<input type="checkbox" name="config.services.queue.asyncReqOnUnload" id="config.services.queue.asyncReqOnUnload" value="true"> {{ queueService-asyncReqOnUnload }}
											</label>
											<span class="help-icon"><span class="help-text">{{ queueService-asyncReqOnUnload-helptext }}</span></span>
										</dt>
										<dd></dd>
									</details>
                                </dl>
                            </details>
                            <!-- <a href="#">{{ queueService-addQueue }}</a> -->
                        </article>
                    </fieldset>
                </section>

                <section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{ messageService-header }}</h1></legend>
                        <article>
                            <header>
                                <h1>{{ messageService-subHeader }}</h1>
                            </header>
                            <div class="addable-target services-message-privacy-configurations">
                                <details class="services-message-privacy-{n0} messageService-privacy data-bindings template" id="messageService-privacyconfiguration" data-id-counter="0">
                                    <summary>
                                        {{ messageService-subHeader }} #{n0}: {{ messageService-maskType }}: <span class="services-message-privacy-{n0}-maskType" data-replace-lang-key="messageService-maskType">Empty</span>,
                                        {{ messageService-targets }}: <span class="services-message-privacy-{n0}-targets"></span>
                                    </summary>
                                    <div class="innerDetails">
                                        <div class="addable-target">
                                            <details class="services-message-privacy-{n0}-target template" id="messageService-{n0}-privacyconfiguration-target" data-id-counter="0">
                                                <summary>
                                                    {{ messageService-id }} <span class="services-message-privacy-{n0}-targets-{n1}-id"></span>,
                                                    {{ messageService-idType }} <span class="services-message-privacy-{n0}-targets-{n1}-idType" data-replace-lang-key="messageService-idType">HTML ID</span>
                                                </summary>
                                                <div class="innerDetails">
                                                    <dl>
                                                        <dt>
                                                            <label for="services-message-privacy-{n0}-targets-{n1}-id">{{ messageService-id }}</label>
                                                            <span class="help-icon"><span class="help-text">{{ messageService-id-helptext }}</span></span>
                                                        </dt>
                                                        <dd>
                                                            <input class="textfield services-message-privacy-target textfield services-message-privacy-target-{n0}" id="services-message-privacy-{n0}-targets-{n1}-id" data-name="config.services.message.privacy[{n0}].targets[{n1}].id" data-privacy-config-id="{n0}">
                                                        </dd>
                                                        <dt>
                                                            <label for="services-message-privacy-{n0}-targets-{n1}-idType">{{ messageService-idType }}</label>
                                                            <span class="help-icon"><span class="help-text">{{ messageService-idType-helptext }}</span></span>
                                                        </dt>
                                                        <dd>
                                                            <select id="services-message-privacy-{n0}-targets-{n1}-idType" data-name="config.services.message.privacy[{n0}].targets[{n1}].idType">
                                                                <option value="-1" selected>{{ messageService-idType--1 }}</option>
                                                                <option value="-2">{{ messageService-idType--2 }}</option>
                                                                <option value="-3">{{ messageService-idType--3 }}</option>
                                                            </select>
                                                        </dd>
                                                        <dt>
                                                            <label for="services-message-privacy-{n0}-targets-{n1}-cssSelector">{{ messageService-cssSelector }}
                                                                <span class="help-icon"><span class="help-text">{{ messageService-cssSelector-helptext }}</span></span>
                                                            </label>
                                                        </dt>
                                                        <dd>
                                                            <input class="textfield" id="services-message-privacy-{n0}-targets-{n1}-cssSelector" data-name="config.services.message.privacy[{n0}].targets[{n1}].cssSelector" placeholder="{{ services-message-privacy-cssSelector-placeholder }}">
                                                        </dd>
                                                    </dl>
                                                    <a href="#" id="messageService-{n0}-privacyconfiguration-target-{n1}-removeTarget" class="remove-instantly">{{ messageService-removePrivacyConfigurationTarget }}</a>
                                                </div>
                                            </details>
                                        </div>
                                        <a href="#" id="services-message-privacy-addTarget" class="add-more add-instantly" data-id="messageService-{n0}-privacyconfiguration-target" data-replacement-token="1">{{ messageService-addTarget }}</a>
                                        <dl>
                                            <dt>
                                                <label for="services-message-privacy-{n0}-maskType">{{ messageService-maskType }}</label>
                                                <span class="help-icon">
                                                    <span class="help-text">{{ messageService-maskType-helptext }}</span>
                                                </span>
                                            </dt>
                                            <dd>
                                                <select id="services-message-privacy-{n0}-maskType" data-name="config.services.message.privacy[{n0}].maskType" class="services-message-privacy-maskType">
                                                    <option value="1" selected>{{ messageService-maskType-1 }}</option>
                                                    <option value="2">{{ messageService-maskType-2 }}</option>
                                                    <option value="3">{{ messageService-maskType-3 }}</option>
                                                    <option value="4">{{ messageService-maskType-4 }}</option>
                                                </select>
                                            </dd>
                                            <dt class="services-message-privacy-maskFunctionDefinition">
                                                <label for="services-message-privacy-{n0}-maskFunction">{{ messageService-maskFunction }}</label>
                                                <span class="help-icon"><span class="help-text">{{ messageService-maskFunction-helptext }}</span></span>
                                            </dt>
                                            <dd class="services-message-privacy-maskFunctionDefinition">
                                                <textarea class="textfield escapedFunction" rows="5" id="services-message-privacy-{n0}-maskFunction" data-name="config.services.message.privacy[{n0}].maskFunction" disabled>function (value) { return value; }</textarea>
                                            </dd>
                                        </dl>
                                        <a href="#" id="messageService-privacyconfiguration-{n0}-removeTarget" class="remove-instantly">{{ messageService-removePrivacyConfiguration }}</a>
                                    </div>
                                </details>
                            </div>
                            <a href="#" id="services-message-privacy-addConfiguration" class="add-more" data-id="messageService-privacyconfiguration" data-replacement-token="0">{{ messageService-addConfiguration }}</a>
                        </article>
                    </fieldset>
                </section>

                 <section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{ serializer-header }}</h1></legend>
                        <article>
                            <details>
                                <summary>{{ advanced-options }}</summary>
                                <dl>
                                    <dt>
                                        <label for="services-serializer-defaultToBuiltin">
                                            <input type="checkbox" name="config.services.serializer.json.defaultToBuiltin" id="services-serializer-defaultToBuiltin" value="true" checked> {{ serializer-defaultToBuiltin }}
                                        </label>
                                        <span class="help-icon">
                                            <span class="help-text">{{ serializer-defaultToBuiltin-helptext }}</span>
                                        </span>                                        
                                    </dt>
                                    <dd></dd>
                                </dl>
                                <div class="services-serializer">
                                    <summary>
                                        {{ serializer-parsers }} <span id="service-serializer-parsers-values" class="services-serializer-parsers-values"></span>
                                        <span class="help-icon">
                                            <span class="help-text">{{ serializer-parsers-helptext }}</span>
                                        </span>
                                    </summary>
                                    <div class="innerDetails">
                                        <div class="addable-target">
                                            <details class="template" id="services-serializer-parsers-template" data-id-counter="0">
                                                 <summary>
                                                    {{ serializer-parser }}
                                                </summary>
                                                <div class="innerDetails">
                                                    <input class="textfield services-serializer-parsers" id="services-serializer-parser" name="config.services.serializer.json.parsers[{n0}]" value="">
                                                </div>
                                            </details>
                                        </div>
                                        <a href="#" id="services-serializer-addParser" class="add-more add-instantly"  data-id="services-serializer-parsers-template" data-replacement-token="0">{{ serializer-addParser }}</a>
                                    </div>
                                    <summary>
                                        {{ serializer-stringifiers }} <span id="service-serializer-stringifiers-values" class="services-serializer-stringifiers-values"></span>
                                        <span class="help-icon">
                                            <span class="help-text">{{ serializer-stringifiers-helptext }}</span>
                                        </span>
                                    </summary>
                                    <div class="innerDetails">
                                        <div class="addable-target">
                                            <details class="template" id="services-serializer-stringifiers-template" data-id-counter="0">
                                                 <summary>
                                                    {{ serializer-stringifier }}
                                                </summary>
                                                <div class="innerDetails">
                                                    <input class="textfield services-serializer-stringifiers" id="services-serializer-stringifiers" name="config.services.serializer.json.stringifiers[{n0}]" value="">
                                                </div>
                                            </details>
                                        </div>
                                        <a href="#" id="services-serializer-addStringifier" class="add-more add-instantly"  data-id="services-serializer-stringifiers-template" data-replacement-token="0">{{ serializer-addStringifier }}</a>
                                    </div>
                                </div>
                            </details>
                        </article>
                    </fieldset>
                </section>

				<section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{encoder-header }}</h1></legend>
                        <article>
						<dl>
							<dt>
								<label for="config.services.encoder.enable">
									<input type="checkbox" name="config.services.encoder.enable" id="config.services.encoder.enable" data-toggles="services-encoder-toggles" value="true"> {{ encoder-enable }}
								</label>
							</dt>
						<dl>
						<div id="services-encoder-toggles" style="display: none">
                            <details>
                                <summary>{{ advanced-options }}</summary>
                                    <summary>
                                        {{encoder }} <span id="service-encoder" class="services-encoder"></span>
                                        <span class="help-icon">
                                            <span class="help-text">{{encoder-helptext }}</span>
                                        </span>
                                    </summary>
                                    <div class="innerDetails">
										<summary>
                                            {{encoder-encode }}
										    <span class="help-icon">
												<span class="help-text">{{encoder-encode-helptext }}</span>
											</span>
                                        </summary>
										<div class="innerDetails">
                                           <input class="textfield services-encoder-encode" id="services-encoder-encode" name="config.services.encoder.gzip.encode" value="window.pako.gzip" disabled>
                                        </div>
										<summary>
											{{encoder-defaultEncoding }}
										    <span class="help-icon">
												<span class="help-text">{{encoder-defaultEncoding-helptext }}</span>
											</span>
                                        </summary>
										<div class="innerDetails">
                                            <input class="textfield services-encoder-defaultEncoding" id="services-encoder-defaultEncoding" name="config.services.encoder.gzip.defaultEncoding" value="gzip" disabled>
                                        </div>     
                                    </div>       
                            </details>
						</div>
                        </article>
                    </fieldset>
                </section>

                <section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{ modules-header }}</h1></legend>
                        <article>
                            <header>
                                <h1>{{ modules-subHeader }}</h1>
                            </header>
                            <dl>
                                <dt>
                                    <label for="core-modules-performance">
                                        <input type="checkbox" name="config.core.modules.performance.enabled" id="core-modules-performance" value="true" data-toggles="modules-performance-filter-container" checked> {{ modules-performance }}
                                    </label>
                                    <span class="help-icon"><span class="help-text">{{ modules-performance-helptext }}</span></span>
                                </dt>
                                <dd></dd>
                                <dt>
                                    <label for="core-modules-replay">
                                        <input type="checkbox" name="config.core.modules.replay.enabled" id="core-modules-replay" value="true" data-toggles="modules-replay-events-container" checked> {{ modules-replay }}
                                    </label>
                                    <span class="help-icon"><span class="help-text">{{ modules-replay-helptext }}</span></span>
                                </dt>
                                <dd></dd>
								<dt>
                                    <label for="core-modules-overstat">
                                        <input type="checkbox" name="config.core.modules.overstat.enabled" id="core-modules-overstat" value="true" data-toggles="modules-overstat-filter-container"> {{ modules-overstat }}
                                    </label>
                                    <span class="help-icon"><span class="help-text">{{ modules-overstat-helptext }}</span></span>
                                </dt>
                                <dd></dd>
                            </dl>
                            <details>
                                <summary>{{ advanced-options }}</summary>
                                <!-- <dl>
                                    <dt>
                                        <label for="core-moduleBase">{{ modules-moduleBaseURL }}</label>
                                        <span class="help-icon"><span class="help-text">{{ modules-moduleBaseURL-helptext }}</span></span>
                                    </dt>
                                    <dd>
                                        <input class="textfield" id="core-moduleBase" name="config.core.moduleBase"  value="intermediate/modules/">
                                    </dd>
                                </dl> -->
                                <fieldset id="modules-performance-filter-container">
                                    <legend>{{ modules-PerformanceSettings }}</legend>
                                    <dl>
                                        <dt>
                                            <label for="config.modules.performance.calculateRenderTime">
                                                <input type="checkbox" name="config.modules.performance.calculateRenderTime" id="config.modules.performance.calculateRenderTime" value="true" checked> {{ performance-calculateRenderTime }}
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ performance-calculateRenderTime-helptext }}</span></span>
                                        </dt>
                                        <dd>{{ performance-calculateRenderTime-description }}</dd>
                                    </dl>
                                    <dl>
                                        <dt>
                                            <label for="config.modules.performance.filter.navigationStart">
                                                <input type="checkbox" name="config.modules.performance.filter.navigationStart" id="config.modules.performance.filter.navigationStart" value="true" checked> navigationStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-navigationStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.unloadEventStart">
                                                <input type="checkbox" name="config.modules.performance.filter.unloadEventStart" id="config.modules.performance.filter.unloadEventStart" value="true" checked> unloadEventStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-unloadEventStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.unloadEventEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.unloadEventEnd" id="config.modules.performance.filter.unloadEventEnd" value="true" checked> unloadEventEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-unloadEventEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.redirectStart">
                                                <input type="checkbox" name="config.modules.performance.filter.redirectStart" id="config.modules.performance.filter.redirectStart" value="true" checked> redirectStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-redirectStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.redirectEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.redirectEnd" id="config.modules.performance.filter.redirectEnd" value="true" checked> redirectEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-redirectEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.fetchStart">
                                                <input type="checkbox" name="config.modules.performance.filter.fetchStart" id="config.modules.performance.filter.fetchStart" value="true" checked> fetchStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-fetchStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domainLookupStart">
                                                <input type="checkbox" name="config.modules.performance.filter.domainLookupStart" id="config.modules.performance.filter.domainLookupStart" value="true" checked> domainLookupStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domainLookupStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domainLookupEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.domainLookupEnd" id="config.modules.performance.filter.domainLookupEnd" value="true" checked> domainLookupEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domainLookupEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.connectStart">
                                                <input type="checkbox" name="config.modules.performance.filter.connectStart" id="config.modules.performance.filter.connectStart" value="true" checked> connectStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-connectStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.connectEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.connectEnd" id="config.modules.performance.filter.connectEnd" value="true" checked> connectEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-connectEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.secureConnectionStart">
                                                <input type="checkbox" name="config.modules.performance.filter.secureConnectionStart" id="config.modules.performance.filter.secureConnectionStart" value="true" checked> secureConnectionStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-secureConnectionStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.requestStart">
                                                <input type="checkbox" name="config.modules.performance.filter.requestStart" id="config.modules.performance.filter.requestStart" value="true" checked> requestStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-requestStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.responseStart">
                                                <input type="checkbox" name="config.modules.performance.filter.responseStart" id="config.modules.performance.filter.responseStart" value="true" checked> responseStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-responseStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.responseEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.responseEnd" id="config.modules.performance.filter.responseEnd" value="true" checked> responseEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-responseEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domLoading">
                                                <input type="checkbox" name="config.modules.performance.filter.domLoading" id="config.modules.performance.filter.domLoading" value="true" checked> domLoading
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domLoading-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domInteractive">
                                                <input type="checkbox" name="config.modules.performance.filter.domInteractive" id="config.modules.performance.filter.domInteractive" value="true" checked> domInteractive
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domInteractive-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domContentLoadedEventStart">
                                                <input type="checkbox" name="config.modules.performance.filter.domContentLoadedEventStart" id="config.modules.performance.filter.domContentLoadedEventStart" value="true" checked> domContentLoadedEventStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domContentLoadedEventStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domContentLoadedEventEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.domContentLoadedEventEnd" id="config.modules.performance.filter.domContentLoadedEventEnd" value="true" checked> domContentLoadedEventEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domContentLoadedEventEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.domComplete">
                                                <input type="checkbox" name="config.modules.performance.filter.domComplete" id="config.modules.performance.filter.domComplete" value="true" checked> domComplete
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-domComplete-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.loadEventStart">
                                                <input type="checkbox" name="config.modules.performance.filter.loadEventStart" id="config.modules.performance.filter.loadEventStart" value="true" checked> loadEventStart
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-loadEventStart-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                        <dt>
                                            <label for="config.modules.performance.filter.loadEventEnd">
                                                <input type="checkbox" name="config.modules.performance.filter.loadEventEnd" id="config.modules.performance.filter.loadEventEnd" value="true" checked> loadEventEnd
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-loadEventEnd-helptext }}</span></span>
                                        </dt>
                                        <dd></dd>
                                    </dl>
                                    <input type="hidden" name="config.core.modules.performance.events[0].name" value="load">
                                    <input type="hidden" name="config.core.modules.performance.events[0].target" value="window">

                                    <input type="hidden" name="config.core.modules.performance.events[1].name" value="unload">
                                    <input type="hidden" name="config.core.modules.performance.events[1].target" value="window">
                                </fieldset>

                                <fieldset class="core-modules-replay-events" id="modules-replay-events-container">
                                    <legend>{{ modules-replay-events }}:</legend>
                                    <dl>
                                        <dt>
                                            <label for="core-modules-replay-events-mobile">
                                                <input type="checkbox" id="core-modules-replay-events-mobile" checked> {{ modules-mobile-events }}
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-mobile-events-helptext }}</span></span>
                                        </dt>
                                        <dt>
                                            <label for="core-modules-replay-events-hashchange">
                                                <input type="checkbox" id="core-modules-replay-events-hashchange" checked> {{ modules-hashchange }}
                                            </label>
                                             <span class="help-icon"><span class="help-text">{{ modules-hashchange-helptext }}</span></span>
                                        </dt>
                                        <dt>
                                            <label for="core-modules-replay-events-scrollresize">
                                                <input type="checkbox" id="core-modules-replay-events-scrollresize" checked> {{ modules-scroll-winsize }}
                                            </label>
                                            <span class="help-icon"><span class="help-text">{{ modules-scroll-winsize-helptext }}</span></span>
                                        </dt>
                                    </dl>
                                    <input type="hidden" name="config.core.modules.replay.events[0].name" value="load">
                                    <input type="hidden" name="config.core.modules.replay.events[0].target" value="window">

                                    <input type="hidden" name="config.core.modules.replay.events[1].name" value="unload">
                                    <input type="hidden" name="config.core.modules.replay.events[1].target" value="window">

                                    <input type="hidden" name="config.core.modules.replay.events[2].name" value="click">
                                    <input type="hidden" name="config.core.modules.replay.events[2].recurseFrames" value="true">

                                    <input type="hidden" name="config.core.modules.replay.events[3].name" value="focus">
                                    <input type="hidden" name="config.core.modules.replay.events[3].target" value="input, select, textarea, button">
                                    <input type="hidden" name="config.core.modules.replay.events[3].recurseFrames" value="true">

                                    <input type="hidden" name="config.core.modules.replay.events[4].name" value="blur">
                                    <input type="hidden" name="config.core.modules.replay.events[4].target" value="input, select, textarea, button">
                                    <input type="hidden" name="config.core.modules.replay.events[4].recurseFrames" value="true">

                                    <input type="hidden" name="config.core.modules.replay.events[5].name" value="change">
                                    <input type="hidden" name="config.core.modules.replay.events[5].target" value="changeTarget">
                                    <input type="hidden" name="config.core.modules.replay.events[5].recurseFrames" value="true">

                                    <div class="core-modules-replay-events-scrollresize">
                                        <input type="hidden" name="config.core.modules.replay.events[8].name" value="resize">
                                        <input type="hidden" name="config.core.modules.replay.events[8].target" value="window">
                                        <input type="hidden" name="config.core.modules.replay.events[9].name" value="scroll">
                                        <input type="hidden" name="config.core.modules.replay.events[9].target" value="window">
                                    </div>

                                    <div class="core-modules-replay-events-hashchange">
                                        <input type="hidden" name="config.core.modules.replay.events[10].name" value="hashchange">
                                        <input type="hidden" name="config.core.modules.replay.events[10].target" value="window">
                                    </div>

                                    <div class="core-modules-replay-events-mobile">
                                        <input type="hidden" name="config.core.modules.replay.events[11].name" value="orientationchange">
                                        <input type="hidden" name="config.core.modules.replay.events[11].target" value="window">
                                        <input type="hidden" name="config.core.modules.replay.events[12].name" value="touchend">
										<input type="hidden" name="config.core.modules.replay.events[13].name" value="touchstart">
                                    </div>
                                </fieldset>
								<fieldset id="modules-overstat-filter-container">
                                    <input type="hidden" name="config.core.modules.overstat.events[0].name" value="click" disabled>
                                    <input type="hidden" name="config.core.modules.overstat.events[0].recurseFrames" value="true" disabled>

                                    <input type="hidden" name="config.core.modules.overstat.events[1].name" value="mousemove" disabled>
                                    <input type="hidden" name="config.core.modules.overstat.events[1].recurseFrames" value="true" disabled>
									
									<input type="hidden" name="config.core.modules.overstat.events[2].name" value="mouseout" disabled>
                                    <input type="hidden" name="config.core.modules.overstat.events[2].recurseFrames" value="true" disabled>
                                </fieldset>
                            </details>
                        </article>
                    </fieldset>                                    
                    <fieldset>
                        <article>
                            <div class="addable-target">
                                <details class="config-modules-replay-filter-{n0} template" id="config-modules-replay-filter-configuration" data-id-counter="0">
                                    <summary>
                                        {{ replay-customEvent }} #{n0}: "name": <span class="config-modules-replay-filter-{n0}-name"></span>, "target": <span class="config-modules-replay-filter-{n0}-target"></span>, <span id="config-modules-replay-filter-{n0}-delegateTarget-span">"delegateTarget": <span class="config-modules-replay-filter-{n0}-delegateTarget"></span>, </span>"recurseFrames": <span class="config-modules-replay-filter-{n0}-recurseFrames"></span>
                                    </summary>
                                    <div class="innerDetails">
                                        <dl>
                                            <dt>
                                                <label for="config-modules-replay-filter-{n0}-name">{{ replay-customEvent-name}}
                                                    <span class="help-icon"><span class="help-text">{{ replay-customEvent-name-helptext }}</span></span>
                                                </label>
                                            </dt>
                                            <dd>
                                                <input class="textfield" id="config-modules-replay-filter-{n0}-name" data-name="config.core.modules.replay.events.custom[{n0}].name" placeholder="{{ replay-customEventName-placeholder }}">
                                            </dd>
                                            <dt>
                                                <label for="config-modules-replay-filter-{n0}-target">{{ replay-customEvent-target}}
                                                    <span class="help-icon"><span class="help-text">{{ replay-customEvent-target-helptext }}</span></span>
                                                </label>
                                            </dt>
                                            <dd>
                                                <input class="textfield" id="config-modules-replay-filter-{n0}-target" data-name="config.core.modules.replay.events.custom[{n0}].target" placeholder="{{ replay-customEventTarget-placeholder }}">
                                            </dd>
                                            <dt>
                                                <label for="config-modules-replay-filter-{n0}-delegateTarget" id="config-modules-replay-filter-{n0}-delegateTarget-label">{{ replay-customEvent-delegateTarget}}
                                                    <span class="help-icon"><span class="help-text">{{ replay-customEvent-delegateTarget-helptext }}</span></span>
                                                </label>
                                            </dt>
                                            <dd>
                                                <input class="textfield" id="config-modules-replay-filter-{n0}-delegateTarget" data-name="config.core.modules.replay.events.custom[{n0}].delegateTarget" placeholder="{{ replay-customEventTarget-placeholder }}">
                                            </dd>
                                            <dt>
                                                <label for="config-modules-replay-filter-{n0}-recurseFrames">{{ replay-customEvent-recurseFrames}}
                                                    <span class="help-icon"><span class="help-text">{{ replay-customEvent-recurseFrames-helptext }}</span></span>
                                                </label>
                                            </dt>
                                            <dd>
                                                <input type="checkbox" id="config-modules-replay-filter-{n0}-recurseFrames" data-name="config.core.modules.replay.events.custom[{n0}].recurseFrames" value="true" />
                                            </dd>
                                        </dl>
                                        <a href="#" id="config-modules-replay-filter-configuration-{n0}-removeTarget" class="remove-instantly">{{ replay-removeCustomEvent }}</a>
                                    </div>
                                </details>
                            </div>
                            <a href="#" id="config-modules-replay-filter-addTarget" class="add-more add-instantly" data-id="config-modules-replay-filter-configuration" data-replacement-token="0">{{ replay-addCustomDelegate }}</a>
                        </article>
                    </fieldset>
                </section>
				<section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{ domCapture-header }}</h1></legend>
                        <article>
						    <dt>
                                <label for="modules-replay-domCapture">
                                    <input type="checkbox" name="config.modules.replay.domCapture.enabled" id="modules-replay-domCapture" value="true" data-toggles="modules-replay-domCapture-filter-container"> {{ domCapture-enabled }}
								</label>
								<span class="help-icon"><span class="help-text">{{ domCapture-enabled-helptext }}</span></span>
							</dt>
							<fieldset id="modules-replay-domCapture-filter-container" style="display: none;">
								<details>
									<summary>{{ advanced-options }}</summary>
									<dl>
										<dt>
											<label for="config.modules.replay.domCapture.options.captureFrames">
												<input type="checkbox" name="config.modules.replay.domCapture.options.captureFrames" id="config.modules.replay.domCapture.options.captureFrames" value="true" checked> {{ domCapture-captureFrames }}
											</label>
											<span class="help-icon"><span class="help-text">{{ domCapture-captureFrames-helptext }}</span></span>
										</dt>
									</dl>
									<dl>
										<dt>
											<label for="config.modules.replay.domCapture.options.removeScript">
												<input type="checkbox" name="config.modules.replay.domCapture.options.removeScript" id="config.modules.replay.domCapture.options.removeScript" value="true" checked> {{ domCapture-removeScript }}
											</label>
											<span class="help-icon"><span class="help-text">{{ domCapture-removeScript-helptext }}</span></span>
										</dt>
									</dl>
									<dl>
										<dt>
											<label for="config.modules.replay.domCapture.options.maxLength">
												{{ domCapture-maxLength }} <input type="input" name="config.modules.replay.domCapture.options.maxLength" id="config.modules.replay.domCapture.options.maxLength" value="10000000">
											</label>
											<span class="help-icon"><span class="help-text">{{ domCapture-maxLength-helptext }}</span></span>
										</dt>
									</dl>
								</details>
								<header>
									<h1>{{ domCapture-subHeader }}</h1>
									<fieldset>
										<article>
											<div class="addable-target">
												<details class="config-modules-replay-domCapture-filter-{n0} template" id="config-modules-replay-domCapture-filter-configuration" data-id-counter="0">
													<summary>
														{{ domCapture-trigger }} #{n0}: "event": <span class="config-modules-replay-domCapture-filter-{n0}-event"></span>, </span>"delay": <span class="config-modules-replay-domCapture-filter-{n0}-delay"></span>
													</summary>
													<div class="innerDetails">
														<dl>
															<dt>
																<label for="config-modules-replay-domCapture-filter-{n0}-event">{{ domCapture-event}}
																	<span class="help-icon"><span class="help-text">{{ domCapture-event-helptext }}</span></span>
																</label>
															</dt>
															<dd>
																<select id="config-modules-replay-domCapture-filter-{n0}-event" data-name="config.modules.replay.domCapture.triggers[{n0}].event" data-select="modules-replay-domCapture-filter-{n0}">
																	<option value="load">load</option>
																	<option value="unload">unload</option>
																	<option value="click">click</option>
																	<option value="change">change</option>
																</select>
															</dd>
																<div id="modules-replay-domCapture-filter-{n0}-load" data-selectoption="modules-replay-domCapture-filter-{n0}-load">
																	<details class="modules-replay-domCapture-filter-{n0} template" id ="modules-replay-domCapture-filter-{n0}-load-screenview" data-id-counter="0">
																		<summary>
																		{{ domCapture-screenview }} #{n1}
																		</summary>
																		<div>
																		<dl>
																			<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-load-{n1}-screenview" data-name="config.modules.replay.domCapture.triggers[{n0}].screenviews[{n1}]">
																		</dl>
																		<a href="#" id="modules-replay-domCapture-filter-{n0}-load-screenview-{n1}-removeTarget" class="remove-instantly">{{ domCapture-removeScreenview }}</a>
																		</div>
																		
																	</details>
																	<a href="#" id="modules-replay-domCapture-load-screenview-addTarget" class="add-more add-instantly" data-id="modules-replay-domCapture-filter-{n0}-load-screenview" data-replacement-token="1">{{ domCapture-addScreenview }}</a>
																</div>
																<div id="modules-replay-domCapture-filter-{n0}-unload" data-selectoption="modules-replay-domCapture-filter-{n0}-unload" style="display: none;" disabled>
																	<details class="modules-replay-domCapture-filter-{n0} template" id ="modules-replay-domCapture-filter-{n0}-unload-screenview" data-id-counter="0">
																		<summary>
																		{{ domCapture-screenview }} #{n1}
																		</summary>
																		<div>
																		<dl>
																			<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-unload-{n1}-screenview" data-name="config.modules.replay.domCapture.triggers[{n0}].screenviews[{n1}]">
																		</dl>
																		<a href="#" id="modules-replay-domCapture-filter-{n0}-unload-screenview-{n1}-removeTarget" class="remove-instantly">{{ domCapture-removeScreenview }}</a>
																		</div>
																		
																	</details>
																	<a href="#" id="modules-replay-domCapture-unload-screenview-addTarget" class="add-more add-instantly" data-id="modules-replay-domCapture-filter-{n0}-unload-screenview" data-replacement-token="1">{{ domCapture-addScreenview }}</a>
																</div>
																<div id="modules-replay-domCapture-filter-{n0}-click" data-selectoption="modules-replay-domCapture-filter-{n0}-click" style="display: none;" disabled>
																	<details class="modules-replay-domCapture-filter-{n0} template" id ="modules-replay-domCapture-filter-{n0}-click-targets" data-id-counter="0">
																		<summary>
																		{{ domCapture-target }}
																		</summary>
																		<div>
																		<dl>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-click-{n1}-id">{{ domCapture-target-id}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-id-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-click-{n1}-id" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].id">
																			</dd>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-click-{n1}-idType">{{ domCapture-target-idType}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-idType-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<select id="modules-replay-domCapture-filter-{n0}-click-{n1}-idType" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].idType">
																					<option value="-1">HTML_ID</option>
																					<option value="-2">XPATH_ID</option>
																					<option value="-3">CUSTOM_ID</option>
																				</select>
																			</dd>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-click-{n1}-cssSelector">{{ domCapture-target-cssSelector}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-cssSelector-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-click-{n1}-cssSelector" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].cssSelector">
																			</dd>
																		</dl>
																		<a href="#" id="modules-replay-domCapture-filter-{n0}-click-targets-{n1}-removeTarget" class="remove-instantly">{{ domCapture-removeTarget }}</a>
																		</div>
																		
																	</details>
																	<a href="#" id="modules-replay-domCapture-click-targets-addTarget" class="add-more add-instantly" data-id="modules-replay-domCapture-filter-{n0}-click-targets" data-replacement-token="1">{{ domCapture-addTarget }}</a>
																</div>
																<div id="modules-replay-domCapture-filter-{n0}-change" data-selectoption="modules-replay-domCapture-filter-{n0}-change" style="display: none;" disabled>
																	<details class="modules-replay-domCapture-filter-{n0} template" id ="modules-replay-domCapture-filter-{n0}-change-targets" data-id-counter="0">
																		<summary>
																		{{ domCapture-target }}
																		</summary>
																		<div>
																		<dl>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-change-{n1}-id">{{ domCapture-target-id}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-id-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-change-{n1}-id" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].id">
																			</dd>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-change-{n1}-idType">{{ domCapture-target-idType}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-idType-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<select id="modules-replay-domCapture-filter-{n0}-change-{n1}-idType" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].idType">
																					<option value="-1">HTML_ID</option>
																					<option value="-2">XPATH_ID</option>
																					<option value="-3">CUSTOM_ID</option>
																				</select>
																			</dd>
																			<dt>
																				<label for="modules-replay-domCapture-filter-{n0}-change-{n1}-cssSelector">{{ domCapture-target-cssSelector}}
																					<span class="help-icon"><span class="help-text">{{ domCapture-target-cssSelector-helptext }}</span></span>
																				</label>
																			</dt>
																			<dd>
																				<input class="textfield" id ="modules-replay-domCapture-filter-{n0}-change-{n1}-cssSelector" data-name="config.modules.replay.domCapture.triggers[{n0}].targets[{n1}].cssSelector">
																			</dd>
																		</dl>
																		<a href="#" id="modules-replay-domCapture-filter-{n0}-change-targets-{n1}-removeTarget" class="remove-instantly">{{ domCapture-removeTarget }}</a>
																		</div>
																		
																	</details>
																	<a href="#" id="modules-replay-domCapture-change-targets-addTarget" class="add-more add-instantly" data-id="modules-replay-domCapture-filter-{n0}-change-targets" data-replacement-token="1">{{ domCapture-addTarget }}</a>
																</div>
															<dt>
																<label for="config-modules-replay-domCapture-filter-{n0}-delay">{{ domCapture-delay }}
																	<span class="help-icon"><span class="help-text">{{ domCapture-delay-helptext }}</span></span>
																</label>
															</dt>
															<dd>
																<input class="textfield" id="config-modules-replay-domCapture-filter-{n0}-delay" data-name="config.modules.replay.domCapture.triggers[{n0}].delay" placeholder="{{ domCapture-delay-placeholder }}">
															</dd>
														</dl>
														<a href="#" id="config-modules-replay-domCapture-filter-configuration-{n0}-removeTarget" class="remove-instantly">{{ domCapture-removeTrigger }}</a>
													</div>
												</details>
											</div>
											<a href="#" id="config-modules-replay-domCapture-filter-addTarget" class="add-more add-instantly" data-id="config-modules-replay-domCapture-filter-configuration" data-replacement-token="0">{{ domCapture-addTrigger }}</a>
										</article>
									</fieldset>
								</header>
							</fieldset>
						</article>
					</fieldset>
				</section>
                <section class="config-section recommended-section">
                    <fieldset>
                        <legend><h1>{{ misc-header }}</h1></legend>
                        <dl>
                            <dt>
                                <label for="misc-frames-blacklist">{{ misc-frames-blacklist-label }}
                                    <span class="help-icon"><span class="help-text">{{ misc-frames-blacklist-helptext }}</span></span>
                                </label>
                            </dt>
                            <dd>
                                <input class="textfield" id="misc-frames-blacklist" name="config.core.framesBlacklist" placeholder="{{ misc-frames-blacklist-placeholder }}">
                            </dd>
                        </dl>
                        <details>
                            <summary>{{ sessionData-options }}</summary>
                            <dl>
                                <dt>
                                    <label for="sessionData-Enable">
                                        <input type="checkbox" class="sessionDataEnable" name="config.core.sessionDataEnabled" id="sessionData-Enable" value="true" /> {{ sessionData-Enable }}
                                    </label>
                                </dt>
                                <dd>
                                    <p>{{ sessionData-Enable-description }}</p>
                                </dd>

                                <dt>
                                    <label for="sessionId-Cookie">
                                        <input type="radio" class="sessionIdChoice" name="sessionId" id="sessionId-Cookie" value="Cookie" checked="checked" /> {{ sessionId-Cookie }}
                                    </label>
                                </dt>
                                <dd>
                                    <p>{{ sessionId-Cookie-description }}</p>
                                </dd>
                                <dt>
                                    <label for="sessionId-Query">
                                        <input type="radio" class="sessionIdChoice" name="sessionId" id="sessionId-Query" value="Query Parameter" /> {{ sessionId-Query }}
                                    </label>
                                </dt>
                                <dd>
                                    <p>{{ sessionId-Query-description }}</p>
                                </dd>
                            </dl>

                            <dl id="misc-sessionId-Cookie-container">
                                <dt>
                                    <label for="sessionId-Cookie-Name">{{ sessionId-Cookie-Name }}
                                        <span class="help-icon"><span class="help-text">{{ sessionId-Cookie-Name-helptext }}</span></span>
                                    </label>
                                </dt>

                                <dd>
                                    <input class="textfield" id="sessionId-Cookie-Name" name="config.core.sessionData.sessionCookieName"  value="TLTSID" pattern="[-a-zA-Z0-9_/.,;:?#=+&]+" />
                                </dd>

                                <dt>
                                    <label for="sessionId-Cookie-ValueNeedsHashing">
                                        <input type="checkbox" id="sessionId-Cookie-ValueNeedsHashing" name="config.core.sessionData.sessionValueNeedsHashing"  value="true" /> {{ sessionId-ValueNeedsHashing }}
                                    </label>
                                </dt>
                                <dd>
                                    <p>{{ sessionId-ValueNeedsHashingDescription }}</p>
                                </dd>
                            </dl>

                            <dl id="misc-sessionId-Query-container" style="display: none;">
                                <dt>
                                    <label for="sessionId-Query-Name">{{ sessionId-Query-Name }}
                                        <span class="help-icon"><span class="help-text">{{ sessionId-Query-Name-helptext }}</span></span>
                                    </label>
                                </dt>

                                <dd>
                                    <input class="textfield" id="sessionId-Query-Name" name="config.core.sessionData.sessionQueryName"  value="" pattern="[-a-zA-Z0-9_/\.,;:?#=+&]+" disabled="disabled" />
                                </dd>

                                <dt>
                                    <label for="sessionId-Query-Delimiter">{{ sessionId-Query-Delimiter }}
                                        <span class="help-icon"><span class="help-text">{{ sessionId-Query-Delimiter-helptext }}</span></span>
                                    </label>
                                </dt>

                                <dd>
                                    <select id="sessionId-Query-Delimiter" name="config.core.sessionData.sessionQueryDelim" disabled="disabled">
                                        <option label="&" selected="selected">&</option>
                                        <option label=";">;</option>
                                    </select>
                                </dd>

                                <dt>
                                    <label for="sessionId-Query-ValueNeedsHashing">
                                        <input type="checkbox" id="sessionId-Query-ValueNeedsHashing" name="config.core.sessionData.sessionValueNeedsHashing"  value="true" disabled="disabled" /> {{ sessionId-ValueNeedsHashing }}
                                    </label>
                                </dt>
                                <dd>
                                    <p>{{ sessionId-ValueNeedsHashingDescription }}</p>
                                </dd>
                            </dl>
                        </details>
                    </fieldset>
                </section>
            </div>

        </form>

        <aside id="regextester">
        <a class="close" id="close-regex"> &#215 </a>
            <h1>{{ regextester-headline }}</h1>
            <dl>
                <dt><label for="regextester-regex">{{ regextester-regex }}</label></dt>
                <dd>
                    <div>
                        <input id="regextester-regex">
                    </div>
                    <div>
                        <label><input type="checkbox" id="regextester-flag-i" value="i"> {{ regextester-flag-i }}</label>
                        <label><input type="checkbox" id="regextester-flag-g" value="g"> {{ regextester-flag-g }}</label>
                    </div>
                </dd>
                <dt><label for="regextester-sample">{{ regextester-sample }}</label></dt>
                <dd><input id="regextester-sample"></dd>
                <dt>{{ regextester-matches }}</dt>
                <dd><output for="regextester-regex regextester-sample" id="regextester-output" class="regextester-no-match">false</output></dd>
                <dt><label>{{ regextester-regex }} {{ regextester-copylabel }}</label></dt>
                <dd><input readonly id="regextester-copyregex"></dd>
            </dl>
            <button id="btn-testregex">{{ regextester-btn-test }}</button>
        </aside>

        <footer>
            <button id="btn-prev" disabled>{{ btn-prev }}</button>
            <button id="btn-next">{{ btn-next }}</button>
            <button id="btn-finish">{{ btn-finish }}</button>
            <button id="btn-reset" disabled>{{ btn-reset }}</button>
            <select id="library-type">
                <option value="-prod-min" selected>{{ library-type-prod-min }}</option>
                <option value="-prod">{{ library-type-prod }}</option>
                <option value="-dev">{{ library-type-dev }}</option>
            </select>
            <button id="btn-regextester">{{ btn-regextester }}</button>
        </footer>

    </div>

<div class="UIC-SDK-FILES" style="display: none;">
<script type="text/tljs" id="UIC-SDK-FILE-changetarget">
var changeTarget;
if (TLT.getFlavor() === "w3c" && TLT.utils.isLegacyIE) {
    changeTarget = "input, select, textarea, button";
}
</script>
<script type="text/tljs" id="UIC-SDK-FILE-jQuery-prod-min">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags jQuery,NDEBUG
 */
if(window.TLT){throw"Attempting to recreate TLT. Library may be included more than once on the page."}var TLT=(function(){function n(A,t,u,B){var z=null,C=null,y=TLT.getService("queue"),x=TLT.getModule("replay"),v=null,w=window.location,D=w.origin||null,s=w.pathname;if(!t||typeof t!=="string"){return}if(!u||typeof u!=="string"){u=""}if(!D){D=(w.protocol||"")+"//"+(w.host||"")}if(D.indexOf("file://")>-1){s=s.replace(/(.*?)(?=\/[^.\/]*\.app)/g,"").replace(".app//",".app/")}C={type:2,screenview:{type:A,name:t,url:s,host:D,referrer:u}};if(A==="LOAD"){v={type:"screenview_load",name:t}}else{if(A==="UNLOAD"){v={type:"screenview_unload",name:t}}}if(v&&x){z=x.onevent(v)}if(z){C.dcid=z}if(A==="LOAD"||A==="UNLOAD"){y.post("",C,"DEFAULT")}}var q=(new Date()).getTime(),r={},b={},d=false,e=null,k=(function(){var t,v=[];function u(A){var z=p.getService("browser"),w=p.getCoreConfig().framesBlacklist,y,x;t=t||[];A=A||null;if(typeof w!=="undefined"&&w.length>0){for(x=0;x<w.length;x+=1){y=z.queryAll(w[x],A);if(y&&y.length>0){t=t.concat(y)}}v=v.concat(z.queryAll("iframe",A))}}function s(w){if(p.utils.indexOf(v,w)<0){u(w.ownerDocument)}return p.utils.indexOf(t,w)>-1}s.clearCache=function(){t=null};return s}()),l=null,f={config:["getConfig","updateConfig","getCoreConfig","updateCoreConfig","getModuleConfig","updateModuleConfig","getServiceConfig","updateServiceConfig"],queue:["post","setAutoFlush","flushAll"],browserBase:["getXPathFromNode","processDOMEvent"]},o=(function(){var s={};return{normalizeModuleEvents:function(w,u,z,t){var y=false,v=false,x=p.getService("browser");z=z||p._getLocalTop();t=t||z.document;s[w]={loadFired:false,pageHideFired:false};p.utils.forEach(u,function(A){switch(A.name){case"load":y=true;u.push(p.utils.mixin(p.utils.mixin({},A),{name:"pageshow"}));break;case"unload":v=true;u.push(p.utils.mixin(p.utils.mixin({},A),{name:"pagehide"}));u.push(p.utils.mixin(p.utils.mixin({},A),{name:"beforeunload"}));break;case"change":if(p.utils.isLegacyIE&&p.getFlavor()==="w3c"){u.push(p.utils.mixin(p.utils.mixin({},A),{name:"propertychange"}))}break}});if(!y&&!v){delete s[w];return}s[w].silentLoad=!y;s[w].silentUnload=!v;if(!y){u.push({name:"load",target:z})}if(!v){u.push({name:"unload",target:z})}},canPublish:function(t,v){var u;if(s.hasOwnProperty(t)===false){return true}u=s[t];switch(v.type){case"load":u.pageHideFired=false;u.loadFired=true;return !u.silentLoad;case"pageshow":u.pageHideFired=false;v.type="load";return !u.loadFired&&!u.silentLoad;case"pagehide":v.type="unload";u.loadFired=false;u.pageHideFired=true;return !u.silentUnload;case"unload":case"beforeunload":v.type="unload";u.loadFired=false;return !u.pageHideFired&&!u.silentUnload}return true},isUnload:function(t){return typeof t==="object"?(t.type==="unload"||t.type==="beforeunload"||t.type==="pagehide"):false}}}()),c={},a={},g=function(){},i=null,j=true,m=null,h=function(){},p={getStartTime:function(){return q},init:function(t,u){var s;i=u;if(!j){throw"init must only be called once!"}j=false;s=function(v){v=v||window.event||{};if(document.addEventListener||v.type==="load"||document.readyState==="complete"){if(document.removeEventListener){document.removeEventListener("DOMContentLoaded",s,false);window.removeEventListener("load",s,false)}else{document.detachEvent("onreadystatechange",s);window.detachEvent("onload",s)}g(t,u)}};if(document.readyState==="complete"){setTimeout(s)}else{if(document.addEventListener){document.addEventListener("DOMContentLoaded",s,false);window.addEventListener("load",s,false)}else{document.attachEvent("onreadystatechange",s);window.attachEvent("onload",s)}}},isInitialized:function(){return d},getState:function(){return e},destroy:function(t){var s="",v="",y=null,z=null,w=null,u=null,A=false;if(j){return false}this.stopAll();if(!t){u=this.getService("browser");for(s in c){if(c.hasOwnProperty(s)&&u!==null){v=s.split("|")[0];y=c[s].target;A=c[s].delegateTarget||undefined;u.unsubscribe(v,y,this._publishEvent,A)}}}for(z in b){if(b.hasOwnProperty(z)){w=b[z].instance;if(w&&typeof w.destroy==="function"){w.destroy()}b[z].instance=null}}k.clearCache();c={};d=false;j=true;e="destroyed";if(typeof i==="function"){try{i("destroyed")}catch(x){}}},_updateModules:function(v){var u=this.getCoreConfig(),t=this.getService("browser"),x=null,s=null;if(u&&t&&u.modules){try{for(s in u.modules){if(u.modules.hasOwnProperty(s)){x=u.modules[s];if(r.hasOwnProperty(s)){if(x.enabled===false){this.stop(s);continue}this.start(s);if(x.events){this._registerModuleEvents(s,x.events,v)}}else{if(t.loadScript){t.loadScript(u.moduleBase+s+".js")}}}}this._registerModuleEvents.clearCache()}catch(w){p.destroy();return false}}else{return false}return true},rebind:function(s){p._updateModules(s)},getSessionData:function(){if(!p.isInitialized()){return}var w=null,t=null,u,v,s=p.getCoreConfig();if(!s||!s.sessionDataEnabled){return null}t=s.sessionData||{};u=t.sessionQueryName;if(u){v=p.utils.getQueryStringValue(u,t.sessionQueryDelim)}else{u=t.sessionCookieName||"TLTSID";v=p.utils.getCookieValue(u)}if(u&&v){w=w||{};w.tltSCN=u;w.tltSCV=v;w.tltSCVNeedsHashing=!!t.sessionValueNeedsHashing}return w},logCustomEvent:function(v,t){if(!p.isInitialized()){return}var u=null,s=this.getService("queue");if(!v||typeof v!=="string"){v="CUSTOM"}t=t||{};u={type:5,customEvent:{name:v,data:t}};s.post("",u,"DEFAULT")},logExceptionEvent:function(w,u,t){if(!p.isInitialized()){return}var v=null,s=this.getService("queue");if(!w||typeof w!=="string"){return}u=u||"";t=t||"";v={type:6,exception:{description:w,url:u,line:t}};s.post("",v,"DEFAULT")},logScreenviewLoad:function(u,t,s){if(!p.isInitialized()){return}n("LOAD",u,t,s)},logScreenviewUnload:function(s){if(!p.isInitialized()){return}n("UNLOAD",s)},logDOMCapture:function(u,w){var x=null,v,t,y,s;if(!this.isInitialized()){return x}if(p.utils.isLegacyIE){return x}t=this.getService("domCapture");if(t){u=u||window.document;w=w||{};v=t.captureDOM(u,w);if(v){x=w.dcid||("dcid-"+this.utils.getSerialNumber()+"."+(new Date()).getTime());v.dcid=x;y={type:12,domCapture:v};s=this.getService("queue");s.post("",y,"DEFAULT")}else{x=null}}return x},performDOMCapture:function(u,s,t){return this.logDOMCapture(s,t)},_bridgeCallback:function(t){var s=a[t];if(s&&s.enabled){return s}return null},logScreenCapture:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("screenCapture");if(s!==null){s.cbFunction()}},enableTealeafFramework:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("enableTealeafFramework");if(s!==null){s.cbFunction()}},disableTealeafFramework:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("disableTealeafFramework");if(s!==null){s.cbFunction()}},startNewTLFSession:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("startNewTLFSession");if(s!==null){s.cbFunction()}},currentSessionId:function(){if(!p.isInitialized()){return}var t,s=p._bridgeCallback("currentSessionId");if(s!==null){t=s.cbFunction()}return t},defaultValueForConfigurableItem:function(s){if(!p.isInitialized()){return}var u,t=p._bridgeCallback("defaultValueForConfigurableItem");if(t!==null){u=t.cbFunction(s)}return u},valueForConfigurableItem:function(s){if(!p.isInitialized()){return}var u,t=p._bridgeCallback("valueForConfigurableItem");if(t!==null){u=t.cbFunction(s)}return u},setConfigurableItem:function(t,v){if(!p.isInitialized()){return}var s=false,u=p._bridgeCallback("setConfigurableItem");if(u!==null){s=u.cbFunction(t,v)}return s},addAdditionalHttpHeader:function(t,v){if(!p.isInitialized()){return}var s=false,u=p._bridgeCallback("addAdditionalHttpHeader");if(u!==null){s=u.cbFunction(t,v)}return s},logCustomEventBridge:function(u,v,t){if(!p.isInitialized()){return}var s=false,w=p._bridgeCallback("logCustomEventBridge");if(w!==null){s=w.cbFunction(u,v,t)}return s},registerBridgeCallbacks:function(v){var u=0,t=0,s=null;if(!v){return false}if(v.length===0){a={};return false}try{for(u=0,t=v.length;u<t;u+=1){s=v[u];if(typeof s==="object"&&s.cbType&&s.cbFunction){a[s.cbType]={enabled:s.enabled,cbFunction:s.cbFunction}}}}catch(w){return false}return true},redirectQueue:function(u){var x,t,s,v,w;if(!u||!u.length){return u}s=a.messageRedirect;if(s&&s.enabled){w=p.getService("serializer");for(x=0,t=u.length;x<t;x+=1){v=s.cbFunction(w.serialize(u[x]),u[x]);if(v&&typeof v==="object"){u[x]=v}else{u.splice(x,1);x-=1;t=u.length}}}return u},_hasSameOrigin:function(s){try{return s.document.location.host===document.location.host&&s.document.location.protocol===document.location.protocol}catch(t){}return false},provideRequestHeaders:function(){var t=null,s=a.addRequestHeaders;if(s&&s.enabled){t=s.cbFunction()}return t},_registerModuleEvents:(function(){var u,v=function(z,y,x){if(z==="window"){return y}if(z==="document"){return x}return z};function w(x,E,H){var G=p.getService("browserBase"),B=p.getService("browser"),F=p.utils.getDocument(H),z=p._getLocalTop(),y=p.utils.isIFrameDescendant(H),D,C,A;H=H||F;o.normalizeModuleEvents(x,E,z,F);if(y){D=G.ElementData.prototype.examineID(H).id;if(typeof D==="string"){D=D.slice(0,D.length-1);for(C in c){if(c.hasOwnProperty(C)){for(A=0;A<c[C].length;A+=1){if(x===c[C][A]){if(C.indexOf(D)!==-1){delete c[C];break}}}}}}}p.utils.forEach(E,function(I){var L=v(I.target,z,F)||F,K=v(I.delegateTarget,z,F),J="";if(I.recurseFrames!==true&&y){return}if(typeof L==="string"){if(I.delegateTarget&&p.getFlavor()==="jQuery"){J=p._buildToken4delegateTarget(I.name,L,I.delegateTarget);if(!c.hasOwnProperty(J)){c[J]=[x];c[J].target=L;c[J].delegateTarget=K;B.subscribe(I.name,L,p._publishEvent,K,J)}else{c[J].push(x)}}else{p.utils.forEach(B.queryAll(L,H),function(M){var N=u.get(M);if(!N){N=G.ElementData.prototype.examineID(M);u.set(M,N)}J=I.name+"|"+N.id+N.type;if(p.utils.indexOf(c[J],x)!==-1){return}c[J]=c[J]||[];c[J].push(x);c[J].target=M;B.subscribe(I.name,M,p._publishEvent)})}}else{J=p._buildToken4bubbleTarget(I.name,L,typeof I.target==="undefined");if(!c.hasOwnProperty(J)){c[J]=[x];B.subscribe(I.name,L,p._publishEvent)}else{if(p.utils.indexOf(c[J],x)===-1){c[J].push(x)}}}if(J!==""){if(typeof L!=="string"){c[J].target=L}}})}function t(x){var y=p.utils.getIFrameWindow(x);return(y!==null)&&p._hasSameOrigin(y)&&(y.document!==null)&&y.document.readyState==="complete"}function s(y,E,F){F=F||p._getLocalTop().document;u=u||new p.utils.WeakMap();w(y,E,F);if(y!=="performance"){var C=null,x=null,z=p.getService("browser"),D=z.queryAll("iframe, frame",F),B,A;for(B=0,A=D.length;B<A;B+=1){C=D[B];if(k(C)){continue}if(t(C)){x=p.utils.getIFrameWindow(C);p._registerModuleEvents(y,E,x.document)}(function(I,G,J){var H=null,K={moduleName:I,moduleEvents:G,hIFrame:J,_registerModuleEventsDelayed:function(){var L=null;if(!k(J)){L=p.utils.getIFrameWindow(J);if(p._hasSameOrigin(L)){p._registerModuleEvents(I,G,L.document)}}}};p.utils.addEventListener(J,"load",function(){K._registerModuleEventsDelayed()});if(p.utils.isLegacyIE&&t(J)){H=p.utils.getIFrameWindow(J);p.utils.addEventListener(H.document,"readystatechange",function(){K._registerModuleEventsDelayed()})}}(y,E,C))}}}s.clearCache=function(){if(u){u.clear();u=null}};return s}()),_buildToken4currentTarget:function(t){var u=t.nativeEvent?t.nativeEvent.currentTarget:null,s=u?this.getService("browserBase").ElementData.prototype.examineID(u):{id:t.target.id,type:t.target.idType};return t.type+"|"+s.id+s.type},_buildToken4delegateTarget:function(s,u,t){return s+"|"+u+"|"+t},_buildToken4bubbleTarget:function(t,A,z,E){var x=p._getLocalTop(),s,u=p.getService("browser"),F=function(G){var H=null;if(p._hasSameOrigin(s.parent)){p.utils.forEach(u.queryAll("iframe, frame",s.parent.document),function(I){var J=null;if(!k(I)){J=p.utils.getIFrameWindow(I);if(p._hasSameOrigin(J)&&J.document===G){H=I}}})}return H},B=p.utils.getDocument(A),D=this.getService("browserBase"),C=null,w,v=t,y;if(B){s=B.defaultView||B.parentWindow}if(A===window||A===window.window){v+="|null-2|window"}else{if(z&&s&&p._hasSameOrigin(s.parent)&&typeof B!=="undefined"&&x.document!==B){C=F(B);if(C){w=D.ElementData.prototype.examineID(C);v+="|"+w.xPath+"-2"}}else{if(E&&E!==document&&p.getFlavor()==="jQuery"){v+="|null-2|"+p.utils.getTagName(A)+"|"+p.utils.getTagName(E)}else{v+="|null-2|document"}}}return v},_reinitConfig:function(){p._updateModules()},_publishEvent:function(s){var t=null,w=null,y=(s.delegateTarget&&s.data)?s.data:p._buildToken4currentTarget(s),z=null,A,B,C,v=null,D=false,E=false,x=p.getCoreConfig(),u=p.getService("browser"),F=s.delegateTarget||null;if(m){clearTimeout(m)}m=setTimeout(h,p.utils.getValue(x,"inactivityTimeout",600000));if((s.type==="load"||s.type==="pageshow")&&!s.nativeEvent.customLoad){return}if(p.utils.isIE){if(s.type==="click"){l=s.target.element}if(s.type==="beforeunload"){D=false;p.utils.forEach(x.ieExcludedLinks,function(H){var I,G,J=u.queryAll(H);for(I=0,G=J?J.length:0;I<G;I+=1){if(typeof J[I]!==undefined&&J[I]===l){D=true;return}}});if(D){return}}}if(o.isUnload(s)){e="unloading"}if(s.type==="change"&&p.utils.isLegacyIE&&p.getFlavor()==="w3c"&&(s.target.element.type==="checkbox"||s.target.element.type==="radio")){return}if(s.type==="propertychange"){if(s.nativeEvent.propertyName==="checked"&&(s.target.element.type==="checkbox"||(s.target.element.type==="radio"&&s.target.element.checked))){s.type="change";s.target.type="INPUT"}else{return}}if(!c.hasOwnProperty(y)){if(s.hasOwnProperty("nativeEvent")){C=s.nativeEvent.currentTarget||s.nativeEvent.target}y=p._buildToken4bubbleTarget(s.type,C,true,F)}if(c.hasOwnProperty(y)){z=c[y];for(A=0,B=z.length;A<B;A+=1){t=z[A];w=p.getModule(t);v=p.utils.mixin({},s);if(w&&p.isStarted(t)&&typeof w.onevent==="function"){E=o.canPublish(t,v);if(E){w.onevent(v)}}}}if(v&&v.type==="unload"&&E){p.destroy()}},_getLocalTop:function(){return window.window},addModule:function(s,t){r[s]={creator:t,instance:null,context:null,messages:[]};if(this.isInitialized()){this.start(s)}},getModule:function(s){if(r[s]&&r[s].instance){return r[s].instance}return null},removeModule:function(s){this.stop(s);delete r[s]},isStarted:function(s){return r.hasOwnProperty(s)&&r[s].instance!==null},start:function(t){var u=r[t],s=null;if(u&&u.instance===null){u.context=new TLT.ModuleContext(t,this);s=u.instance=u.creator(u.context);if(typeof s.init==="function"){s.init()}}},startAll:function(){var s=null;for(s in r){if(r.hasOwnProperty(s)){this.start(s)}}},stop:function(t){var u=r[t],s=null;if(u&&u.instance!==null){s=u.instance;if(typeof s.destroy==="function"){s.destroy()}u.instance=u.context=null}},stopAll:function(){var s=null;for(s in r){if(r.hasOwnProperty(s)){this.stop(s)}}},addService:function(t,s){b[t]={creator:s,instance:null}},getService:function(s){if(b.hasOwnProperty(s)){if(!b[s].instance){try{b[s].instance=b[s].creator(this);if(typeof b[s].instance.init==="function"){b[s].instance.init()}}catch(t){return null}if(typeof b[s].instance.getServiceName!=="function"){b[s].instance.getServiceName=function(){return s}}}return b[s].instance}return null},removeService:function(s){delete b[s]},broadcast:function(v){var u=0,s=0,w=null,t=null;if(v&&typeof v==="object"){for(w in r){if(r.hasOwnProperty(w)){t=r[w];if(p.utils.indexOf(t.messages,v.type)>-1){if(typeof t.instance.onmessage==="function"){t.instance.onmessage(v)}}}}}},listen:function(s,u){var t=null;if(this.isStarted(s)){t=r[s];if(p.utils.indexOf(t.messages,u)===-1){t.messages.push(u)}}},fail:function(u,t,s){u="UIC FAILED. "+u;try{p.destroy(!!s)}finally{p.utils.clog(u);throw new p.UICError(u,t)}},UICError:(function(){function s(t,u){this.message=t;this.code=u}s.prototype=new Error();s.prototype.name="UICError";s.prototype.constructor=s;return s}()),getFlavor:function(){return"jQuery"}};h=function(){p.logExceptionEvent("Inactivity timeout.");p.destroy()};g=function(u,z){var y,w,s,t,v;if(d){p.utils.clog("TLT.init() called more than once. Ignoring.");return}if(TLT&&TLT.replay){return}y=p.getService("config");y.updateConfig(u);if(!p._updateModules()){if(e!=="destroyed"){p.destroy()}return}if(y.subscribe){y.subscribe("configupdated",p._reinitConfig)}d=true;e="loaded";w={type:"load",target:window.window,srcElement:window.window,currentTarget:window.window,bubbles:true,cancelBubble:false,cancelable:true,timeStamp:+new Date(),customLoad:true};t=p.getService("browserBase");s=new t.WebEvent(w);p._publishEvent(s);if(typeof i==="function"){try{i("initialized")}catch(x){}}};(function(){var t=null,u,s;for(t in f){if(f.hasOwnProperty(t)){for(u=0,s=f[t].length;u<s;u+=1){(function(w,v){p[v]=function(){var x=this.getService(w);if(x){return x[v].apply(x,arguments)}}}(t,f[t][u]))}}}}());return p}());(function(){var e=window.navigator.userAgent.toLowerCase(),d=(e.indexOf("msie")!==-1),c=(function(){var h=!!window.performance;return(d&&(!h||document.documentMode<9))}()),f=(e.indexOf("android")!==-1),a=/(ipad|iphone|ipod)/.test(e),g=1,b={isIE:d,isLegacyIE:c,isAndroid:f,isiOS:a,isUndefOrNull:function(h){return typeof h==="undefined"||h===null},getSerialNumber:function(){var h;h=g;g+=1;return h},getValue:function(n,m,j){var l,h,k;j=j||null;if(!n||typeof n!=="object"||typeof m!=="string"){return j}k=m.split(".");for(l=0,h=k.length;l<h;l+=1){if(this.isUndefOrNull(n)||typeof n[k[l]]==="undefined"){return j}n=n[k[l]]}return n},indexOf:function(l,k){var j,h;if(l&&l instanceof Array){for(j=0,h=l.length;j<h;j+=1){if(l[j]===k){return j}}}return -1},forEach:function(m,l,k){var j,h;if(!m||!m.length||!l||!l.call){return}for(j=0,h=m.length;j<h;j+=1){l.call(k,m[j],j,m)}},some:function(m,l){var j,h,k=false;for(j=0,h=m.length;j<h;j+=1){k=l(m[j],j,m);if(k){return k}}return k},convertToArray:function(k){var l=0,j=k.length,h=[];while(l<j){h.push(k[l]);l+=1}return h},mixin:function(l){var k,j,i,h;for(i=1,h=arguments.length;i<h;i+=1){j=arguments[i];for(k in j){if(Object.prototype.hasOwnProperty.call(j,k)){l[k]=j[k]}}}return l},extend:function(h,i,j){var k="";for(k in j){if(Object.prototype.hasOwnProperty.call(j,k)){if(h&&Object.prototype.toString.call(j[k])==="[object Object]"){if(typeof i[k]==="undefined"){i[k]={}}b.extend(h,i[k],j[k])}else{i[k]=j[k]}}}return i},clone:function(i){var j,h;if(null===i||"object"!==typeof i){return i}if(i instanceof Object){j=(Object.prototype.toString.call(i)==="[object Array]")?[]:{};for(h in i){if(Object.prototype.hasOwnProperty.call(i,h)){j[h]=b.clone(i[h])}}return j}},createObject:(function(){var h=null,i=null;if(typeof Object.create==="function"){h=Object.create}else{i=function(){};h=function(j){if(typeof j!=="object"&&typeof j!=="function"){throw new TypeError("Object prototype need to be an object!")}i.prototype=j;return new i()}}return h}()),access:function(n,l){var m=l||window,j,k,h;if(typeof n!=="string"||(typeof m!=="object"&&m!==null)){return}j=n.split(".");for(k=0,h=j.length;k<h;k+=1){if(k===0&&j[k]==="window"){continue}if(!Object.prototype.hasOwnProperty.call(m,j[k])){return}m=m[j[k]];if(k<(h-1)&&!(m instanceof Object)){return}}return m},isNumeric:function(h){return !isNaN(h+1-1)},isUpperCase:function(h){return h===h.toUpperCase()&&h!==h.toLowerCase()},isLowerCase:function(h){return h===h.toLowerCase()&&h!==h.toUpperCase()},getDocument:function(h){if(h.nodeType!==9){return(!b.isUndefOrNull(h.ownerDocument))?(h.ownerDocument):(h.document)}return h},getWindow:function(i){if(i.self!==i){var h=b.getDocument(i);return(!b.isUndefOrNull(h.defaultView))?(h.defaultView):(h.parentWindow)}return i},getIFrameWindow:function(j){var h=null;if(!j){return h}try{h=j.contentWindow||(j.contentDocument?j.contentDocument.parentWindow:null)}catch(i){}return h},getTagName:function(h){if(h===document){return"document"}if(h===window||h===window.window){return"window"}if(typeof h==="string"){return h.toLowerCase()}if(typeof h==="object"&&!b.isUndefOrNull(h)&&typeof h.tagName==="string"){return h.tagName.toLowerCase()}return""},isIFrameDescendant:function(h){return b.getWindow(h)!=TLT._getLocalTop()},getOrientationMode:function(h){var i="INVALID";if(typeof h!=="number"){return i}switch(h){case 0:case 180:case 360:i="PORTRAIT";break;case 90:case -90:case 270:i="LANDSCAPE";break;default:i="UNKNOWN";break}return i},clog:(function(h){return function(){}}(window)),trim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/^\s+|\s+$/g,"")},ltrim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/^\s+/,"")},rtrim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/\s+$/,"")},getCookieValue:function(o,q){var l,m,k,p,j=null,h;try{q=q||document.cookie;if(!o||!o.toString){return null}o+="=";h=o.length;p=q.split(";");for(l=0,m=p.length;l<m;l+=1){k=p[l];k=b.ltrim(k);if(k.indexOf(o)===0){j=k.substring(h,k.length);break}}}catch(n){j=null}return j},getQueryStringValue:function(n,q,h){var m,l,r,k=null,o;try{h=h||window.location.search;r=h.length;if(!n||!n.toString||!r){return null}q=q||"&";h=q+h.substring(1);n=q+n+"=";m=h.indexOf(n);if(m!==-1){o=m+n.length;l=h.indexOf(q,o);if(l===-1){l=r}k=decodeURIComponent(h.substring(o,l))}}catch(p){}return k},addEventListener:(function(){if(window.addEventListener){return function(i,h,j){i.addEventListener(h,j,false)}}return function(i,h,j){i.attachEvent("on"+h,j)}}()),matchTarget:function(t,o){var m,l,s=-1,q,h,k,r,n,p;if(!t||!o){return s}if(!this.browserService||!this.browserBaseService){this.browserService=TLT.getService("browser");this.browserBaseService=TLT.getService("browserBase")}for(m=0,n=t.length;m<n&&s===-1;m+=1){p=t[m];if(typeof p==="string"){q=this.browserService.queryAll(p);for(l=0,h=q?q.length:0;l<h;l+=1){if(q[l]){k=this.browserBaseService.ElementData.prototype.examineID(q[l]);if(k.type===o.idType&&k.id===o.id){s=m;break}}}}else{if(p.id&&p.idType&&o.idType.toString()===p.idType.toString()){switch(typeof p.id){case"string":if(p.id===o.id){s=m}break;case"object":r=new RegExp(p.id.regex,p.id.flags);if(r.test(o.id)){s=m}break}}}}return s},WeakMap:(function(){function h(m,l){var k,j;m=m||[];for(k=0,j=m.length;k<j;k+=1){if(m[k][0]===l){return k}}return -1}return function(){var i=[];this.set=function(k,l){var j=h(i,k);i[j>-1?j:i.length]=[k,l]};this.get=function(k){var j=i[h(i,k)];return(j?j[1]:undefined)};this.clear=function(){i=[]};this.has=function(j){return(h(i,j)>=0)};this.remove=function(k){var j=h(i,k);if(j>=0){i.splice(j,1)}};this["delete"]=this.remove}}())};if(typeof TLT==="undefined"||!TLT){window.TLT={}}TLT.utils=b}());(function(){TLT.EventTarget=function(){this._handlers={}};TLT.EventTarget.prototype={constructor:TLT.EventTarget,publish:function(c,f){var d=0,a=0,b=this._handlers[c],e={type:c,data:f};if(typeof b!=="undefined"){for(a=b.length;d<a;d+=1){b[d](e)}}},subscribe:function(a,b){if(!this._handlers.hasOwnProperty(a)){this._handlers[a]=[]}this._handlers[a].push(b)},unsubscribe:function(c,e){var d=0,a=0,b=this._handlers[c];if(b){for(a=b.length;d<a;d+=1){if(b[d]===e){b.splice(d,1);return}}}}}}());TLT.ModuleContext=(function(){var a=["broadcast","getConfig:getModuleConfig","listen","post","getXPathFromNode","performDOMCapture","getStartTime"];return function(f,d){var h={},g=0,b=a.length,j=null,e=null,c=null;for(g=0;g<b;g+=1){j=a[g].split(":");if(j.length>1){c=j[0];e=j[1]}else{c=j[0];e=j[0]}h[c]=(function(i){return function(){var k=d.utils.convertToArray(arguments);k.unshift(f);return d[i].apply(d,k)}}(e))}h.utils=d.utils;return h}}());TLT.addService("config",function(a){function d(f,e){a.utils.extend(true,f,e);c.publish("configupdated",c.getConfig())}var b={core:{},modules:{},services:{}},c=a.utils.extend(false,a.utils.createObject(new TLT.EventTarget()),{getConfig:function(){return b},updateConfig:function(e){d(b,e)},getCoreConfig:function(){return b.core},updateCoreConfig:function(e){d(b.core,e)},getServiceConfig:function(e){return b.services[e]||null},updateServiceConfig:function(f,e){if(typeof b.services[f]==="undefined"){b.services[f]={}}d(b.services[f],e)},getModuleConfig:function(e){return b.modules[e]||null},updateModuleConfig:function(f,e){if(typeof b.modules[f]==="undefined"){b.modules[f]={}}d(b.modules[f],e)},destroy:function(){b={core:{},modules:{},services:{}}}});return c});TLT.addService("queue",function(q){var B=null,f=q.getService("ajax"),k=q.getService("browser"),l=q.getService("encoder"),i=q.getService("serializer"),y=q.getService("config"),g=q.getService("message"),o=null,z={},c=true,n=false,j=(function(){var G={};function J(K){return typeof G[K]!=="undefined"}function C(K,L){if(!J(K)){G[K]={data:[],queueId:K,url:L.url,threshold:L.threshold,serializer:L.serializer,encoder:L.encoder,crossDomainEnabled:!!L.crossDomainEnabled,crossDomainIFrame:L.crossDomainIFrame}}return G[K]}function E(K){if(J(K)){delete G[K]}}function H(K){if(J(K)){return G[K]}return null}function F(L){var K=H(L);if(K!==null){K.data=[]}}function I(K){var L=null;if(J(K)){L=H(K).data;F(K)}return L}function D(N,O){var L=null,K=null,P=window.tlBridge,M=window.iOSJSONShuttle;if((typeof P!=="undefined")&&(typeof P.addMessage==="function")){K=i.serialize(O);P.addMessage(K)}else{if((typeof M!=="undefined")&&(typeof M==="function")){K=i.serialize(O);M(K)}else{if(J(N)){L=H(N);L.data.push(O);L.data=q.redirectQueue(L.data);return L.data.length}}}return 0}return{exists:J,add:C,remove:E,get:H,clear:F,flush:I,push:D}}());function a(){}function m(){return window.location.pathname}function b(E,I,F,H){var C=j.get(E),G={name:I,value:F},D=null;if(typeof I!=="string"||typeof F!=="string"){return}if(!C.headers){C.headers={once:[],always:[]}}D=!!H?C.headers.always:C.headers.once;D.push(G)}function A(E,H){var G=0,D=0,C=j.get(E),I=C.headers,F=null;H=H||{};function J(L,N){var M=0,K=0,O=null;for(M=0,K=L.length;M<K;M+=1){O=L[M];N[O.name]=O.value}}if(I){F=[I.always,I.once];for(G=0,D=F.length;G<D;G+=1){J(F[G],H)}}return H}function s(D){var C=null,E=null;if(!j.exists(D)){throw new Error("Queue: "+D+" does not exist!")}C=j.get(D);E=C?C.headers:null;if(E){E.once=[]}}function x(){var D=0,C,F,E=q.provideRequestHeaders();if(E&&E.length){for(D=0,C=E.length;D<C;D+=1){F=E[D];b("DEFAULT",F.name,F.value,F.recurring)}}return D}function u(D,M){var H=j.flush(D),J=H!==null?H.length:0,I=j.get(D),E={"Content-Type":"application/json","X-Tealeaf":"device (UIC) Lib/4.0.0.1607","X-TealeafType":"GUI","X-TeaLeaf-Page-Url":m()},N=I.serializer||"json",C=I.encoder,F,G,L=null;if(!J){return}H=g.wrapMessages(H);if(N){H=i.serialize(H,N)}if(C){G=l.encode(H,C);if(G&&G.data&&!G.error){H=G.data;E["Content-Encoding"]=G.encoding}}x();A(D,E);if(I.crossDomainEnabled){L=q.utils.getIFrameWindow(I.crossDomainIFrame);if(!L){return}F={request:{url:I.url,async:!M,headers:E,data:H}};if(!q.utils.isIE&&typeof window.postMessage==="function"){L.postMessage(F,I.crossDomainIFrame.src)}else{try{L.sendMessage(F)}catch(K){return}}}else{f.sendRequest({oncomplete:a,url:I.url,async:!M,headers:E,data:H})}s(D)}function e(F){var C=null,E=B.queues,D=0;for(D=0;D<E.length;D+=1){C=E[D];u(C.qid,F)}return true}function h(C,E){var D=j.push(C,g.createMessage(E));if(D>=j.get(C).threshold&&c&&q.getState()!=="unloading"){u(C)}}function d(E){var D=null,H=B.queues,G="",F=0,C=0;for(F=0;F<H.length;F+=1){D=H[F];if(D&&D.modules){for(C=0;C<D.modules.length;C+=1){G=D.modules[C];if(G===E){return D.qid}}}}return o.qid}function v(E,C){z[E]=window.setTimeout(function D(){u(E);z[E]=window.setTimeout(D,C)},C)}function t(){var C=0;for(C in z){if(z.hasOwnProperty(C)){window.clearTimeout(z[C]);delete z[C]}}z={}}function r(C){}function p(C){B=C;q.utils.forEach(B.queues,function(D,E){var F=null;if(D.qid==="DEFAULT"){o=D}if(D.crossDomainEnabled){F=k.query(D.crossDomainFrameSelector);if(!F){q.fail("Cross domain iframe not found")}}j.add(D.qid,{url:D.endpoint,threshold:D.maxEvents,serializer:D.serializer,encoder:D.encoder,timerInterval:D.timerInterval||0,crossDomainEnabled:D.crossDomainEnabled||false,crossDomainIFrame:F});if(typeof D.timerInterval!=="undefined"&&D.timerInterval>0){v(D.qid,D.timerInterval)}});y.subscribe("configupdated",r);n=true}function w(){if(c){e(!B.asyncReqOnUnload)}y.unsubscribe("configupdated",r);t();B=null;o=null;n=false}return{init:function(){if(!n){p(y.getServiceConfig("queue")||{})}else{}},destroy:function(){w()},_getQueue:function(C){return j.get(C).data},setAutoFlush:function(C){if(C===true){c=true}else{c=false}},flush:function(C){if(!j.exists(C)){throw new Error("Queue: "+C+" does not exist!")}u(C)},flushAll:function(C){return e(!!C)},post:function(D,E,C){C=C||d(D);if(!j.exists(C)){throw new Error("Queue: "+C+" does not exist!")}h(C,E)}}});TLT.addService("browserBase",function(w){var z={OPTGROUP:true,OPTION:true,NOBR:true},f={},A=w.getService("config"),d=null,B,g,a,e,r=false;function j(){A=w.getService("config");d=w.getService("serializer");B=w.getService("config").getServiceConfig("browser")||{};g=B.hasOwnProperty("blacklist")?B.blacklist:[];a=B.hasOwnProperty("customid")?B.customid:[]}function o(){j();A.subscribe("configupdated",j);d=w.getService("serializer");r=true}function y(){A.unsubscribe("configupdated",j);r=false}function v(H){var F,E,G;if(!H||!H.id||typeof H.id!=="string"){return false}for(F=0,E=g.length;F<E;F+=1){if(typeof g[F]==="string"){if(H.id===g[F]){return false}}else{if(typeof g[F]==="object"){G=new RegExp(g[F].regex,g[F].flags);if(G.test(H.id)){return false}}}}return true}function q(G,H){var E={type:null,subType:null},F;if(!G){return E}F=G.type;switch(F){case"focusin":F="focus";break;case"focusout":F="blur";break;default:break}E.type=F;return E}function t(F){var E={type:null,subType:null};if(!F){return E}E.type=F.tagName;E.subType=F.type||null;return E}function c(E,G,F){var K={HTML_ID:"-1",XPATH_ID:"-2",ATTRIBUTE_ID:"-3"},J,H=null,I;if(!E||!G){return H}J=F||window.document;G=G.toString();if(G===K.HTML_ID){if(J.getElementById){H=J.getElementById(E)}else{if(J.querySelector){H=J.querySelector("#"+E)}}}else{if(G===K.ATTRIBUTE_ID){I=E.split("=");if(J.querySelector){H=J.querySelector("["+I[0]+'="'+I[1]+'"]')}}else{if(G===K.XPATH_ID){H=f.xpath(E,J)}}}return H}e=(function(){var E={NOBR:true,P:true};function F(I){var L,J,K=false,O=null,G=null,P=null,N=[],M=true,H=w._getLocalTop();while(M){M=false;if(!w.utils.isUndefOrNull(I)){if(!w.utils.isUndefOrNull(I.tagName)){if(E.hasOwnProperty(I.tagName)){I=I.parentNode}}for(K=v(I);I!==document&&!K;K=v(I)){P=I.parentNode;if(!P){G=w.utils.getWindow(I);P=(G!==H)?G.frameElement:document}O=P.firstChild;if(typeof O==="undefined"){return N}for(J=0;O;O=O.nextSibling){if(O.nodeType===1&&O.tagName===I.tagName){if(O===I){N[N.length]=[I.tagName,J];break}J+=1}}I=P}if(K){N[N.length]=[I.id];if(w.utils.isIFrameDescendant(I)){M=true;I=w.utils.getWindow(I).frameElement}}}}return N}return function(I){var G=F(I),J=[],H=G.length;if(H<1){return"null"}while(H){H-=1;if(G[H].length>1){J[J.length]='["'+G[H][0]+'",'+G[H][1]+"]"}else{J[J.length]="["+d.serialize(G[H][0],"json")+"]"}}return("["+J.join(",")+"]")}}());function p(F){var G={left:-1,top:-1},E;F=F||document;E=F.documentElement||F.body.parentNode||F.body;G.left=(typeof window.pageXOffset==="number")?window.pageXOffset:E.scrollLeft;G.top=(typeof window.pageYOffset==="number")?window.pageYOffset:E.scrollTop;return G}function s(E){return E&&typeof E.originalEvent!=="undefined"&&typeof E.isDefaultPrevented!=="undefined"&&!E.isSimulated}function m(E){if(!E){return null}if(E.type&&E.type.indexOf("touch")===0){if(s(E)){E=E.originalEvent}if(E.type==="touchstart"){E=E.touches[E.touches.length-1]}else{if(E.type==="touchend"){E=E.changedTouches[0]}}}return E}function l(H){var K=H||window.event,J=document.documentElement,E=document.body,I=false,G=null,F=0;if(s(K)){K=K.originalEvent}if(typeof H==="undefined"||typeof K.target==="undefined"){K.target=K.srcElement||window.window;K.timeStamp=Number(new Date());if(K.pageX===null||typeof K.pageX==="undefined"){K.pageX=K.clientX+((J&&J.scrollLeft)||(E&&E.scrollLeft)||0)-((J&&J.clientLeft)||(E&&E.clientLeft)||0);K.pageY=K.clientY+((J&&J.scrollTop)||(E&&E.scrollTop)||0)-((J&&J.clientTop)||(E&&E.clientTop)||0)}K.preventDefault=function(){this.returnValue=false};K.stopPropagation=function(){this.cancelBubble=true}}if(window.chrome&&K.path!==undefined&&K.type==="click"){if(K.path.length===undefined){return K}for(F=0;F<K.path.length;F++){if(K.path[F].tagName==="BUTTON"){I=true;G=K.path[F];F=K.path.length}}if(I){return{originalEvent:K,target:G,srcElement:G,type:K.type,pageX:document.body.scrollLeft+G.getBoundingClientRect().left,pageY:document.body.scrollTop+G.getBoundingClientRect().top}}}return K}function u(F){var E=null;if(!F){return null}if(F.srcElement){E=F.srcElement}else{E=F.target;if(!E){E=F.explicitOriginalTarget}if(!E){E=F.originalTarget}}if(!E&&F.type.indexOf("touch")===0){E=m(F).target}while(E&&z[E.tagName]){E=E.parentNode}if(!E&&F.srcElement===null){E=window.window}return E}function i(F){var I=0,H=0,G=document.documentElement,E=document.body;F=m(F);if(F){if(F.pageX||F.pageY){I=F.pageX;H=F.pageY}else{if(F.clientX||F.clientY){I=F.clientX+(G?G.scrollLeft:(E?E.scrollLeft:0))-(G?G.clientLeft:(E?E.clientLeft:0));H=F.clientY+(G?G.scrollTop:(E?E.scrollTop:0))-(G?G.clientTop:(E?E.clientTop:0))}}}return{x:I,y:H}}f.xpath=function(L,N){var J=null,E,K=null,H,G,F,I,M;if(!L){return null}J=d.parse(L);N=N||document;E=N;if(!J){return null}for(H=0,I=J.length;H<I&&E;H+=1){K=J[H];if(K.length===1){if(N.getElementById){E=N.getElementById(K[0])}else{if(N.querySelector){E=N.querySelector("#"+K[0])}else{E=null}}}else{for(G=0,F=-1,M=E.childNodes.length;G<M;G+=1){if(E.childNodes[G].nodeType===1&&E.childNodes[G].tagName.toUpperCase()===K[0]){F+=1;if(F===K[1]){E=E.childNodes[G];break}}}if(F===-1){return null}}}return(E===N||!E)?null:E};function C(E,F){this.x=E||0;this.y=F||0}function x(F,E){this.width=F||0;this.height=E||0}function b(F,G){var I,E,H;G=u(F);I=this.examineID(G);E=t(G);H=this.examinePosition(F,G);this.element=G;this.id=I.id;this.idType=I.type;this.type=E.type;this.subType=E.subType;this.state=this.examineState(G);this.position=new C(H.x,H.y);this.size=new x(H.width,H.height);this.xPath=I.xPath;this.name=I.name}b.HTML_ID=-1;b.XPATH_ID=-2;b.ATTRIBUTE_ID=-3;b.prototype.examineID=function(K){var G,M,N,E,F,I=a.length,H;try{N=e(K)}catch(J){}F=K.name;try{if(!w.utils.isIFrameDescendant(K)){if(v(K)){G=K.id;M=b.HTML_ID}else{if(a.length&&K.attributes){while(I){I-=1;H=K.attributes[a[I]];if(typeof H!=="undefined"){G=a[I]+"="+(H.value||H);M=b.ATTRIBUTE_ID}}}}}}catch(L){}if(!G){G=N;M=b.XPATH_ID}return{id:G,type:M,xPath:N,name:F}};b.prototype.examineState=function(K){var E={a:["innerText","href"],input:{range:["maxValue:max","value"],checkbox:["value","checked"],radio:["value","checked"],image:["src"]},select:["value"],button:["value","innerText"],textarea:["value"]},F=typeof K.tagName!=="undefined"?K.tagName.toLowerCase():"",L=E[F]||null,G=null,N=null,H=0,J=0,I=null,M="";if(L!==null){if(Object.prototype.toString.call(L)==="[object Object]"){L=L[K.type]||["value"]}N={};for(M in L){if(L.hasOwnProperty(M)){if(L[M].indexOf(":")!==-1){I=L[M].split(":");N[I[0]]=K[I[1]]}else{if(L[M]==="innerText"){N[L[M]]=w.utils.trim(K.innerText||K.textContent)}else{N[L[M]]=K[L[M]]}}}}}if(F==="select"&&K.options&&!isNaN(K.selectedIndex)){N.index=K.selectedIndex;if(N.index>=0&&N.index<K.options.length){G=K.options[K.selectedIndex];N.value=G.getAttribute("value")||G.getAttribute("label")||G.text||G.innerText;N.text=G.text||G.innerText}}return N};function n(){var F=1,G,I,E;if(document.body.getBoundingClientRect){try{G=document.body.getBoundingClientRect()}catch(H){w.utils.clog("getBoundingClientRect failed.",H);return F}I=G.right-G.left;E=document.body.offsetWidth;F=Math.round((I/E)*100)/100}return F}function h(F){var H,E,G,J;if(!F||!F.getBoundingClientRect){return{x:0,y:0,width:0,height:0}}try{H=F.getBoundingClientRect();J=p(document)}catch(I){w.utils.clog("getBoundingClientRect failed.",I);return{x:0,y:0,width:0,height:0}}E={x:H.left+J.left,y:H.top+J.top,width:H.right-H.left,height:H.bottom-H.top};if(w.utils.isIE){E.x-=document.documentElement.clientLeft;E.y-=document.documentElement.clientTop;G=n();if(G!==1){E.x=Math.round(E.x/G);E.y=Math.round(E.y/G);E.width=Math.round(E.width/G);E.height=Math.round(E.height/G)}}return E}b.prototype.examinePosition=function(F,G){var H=i(F),E=h(G);E.x=(H.x||H.y)?Math.round(Math.abs(H.x-E.x)):E.width/2;E.y=(H.x||H.y)?Math.round(Math.abs(H.y-E.y)):E.height/2;return E};function k(F){var G,E;this.data=F.data||null;this.delegateTarget=F.delegateTarget||null;if(F.gesture||(F.originalEvent&&F.originalEvent.gesture)){this.gesture=F.gesture||F.originalEvent.gesture}F=l(F);G=i(F);this.custom=false;this.nativeEvent=this.custom===true?null:F;this.position=new C(G.x,G.y);this.target=new b(F,F.target);this.timestamp=(new Date()).getTime();E=q(F,this.target);this.type=E.type;this.subType=E.subType}function D(E){w._publishEvent(new k(E))}return{init:function(){if(!r){o()}else{}},destroy:function(){y()},WebEvent:k,ElementData:b,processDOMEvent:D,getXPathFromNode:function(E,F){return e(F)},getNodeFromID:c,queryDom:f}});TLT.addService("browser",function(d){var o,a,m,e={JQUERY_NOT_SUPPORTED:"JQUERYNOTSUPPORTED",JQUERY_NOT_FOUND:"JQUERYNOTFOUND"},g=d.getService("config"),b=d.getService("browserBase"),h=g.getServiceConfig("browser")||{},f=null,c=null,l=false;function n(p){return function(r){var q=new b.WebEvent(r);p(q)}}function i(p,q){if(typeof p[q]!=="function"){d.fail("jQuery Object does not support "+q,e.JQUERY_NOT_SUPPORTED)}}function k(){var w=["on","off"],v=["ajax","find","getScript"],s=(typeof o==="function"&&typeof o.fn==="object")?o.fn.jquery:0,u=s!==0?parseInt(s.split(".")[0],10):0,q=s!==0?parseInt(s.split(".")[1],10):0,r,p=0,t=null;if(typeof o!=="function"){d.fail("jQuery not found.",e.JQUERY_NOT_FOUND)}for(r=0,p=v.length;r<p;r+=1){i(o,v[r])}for(r=0,p=w.length,t=o({});r<p;r+=1){i(t,w[r])}if(!(u>=2||(u===1&&q>=7))){d.fail("jQuery Object has the wrong version ("+s+")",e.JQUERY_NOT_SUPPORTED)}}a={list2Array:function(r){var q=r.length,p=[],s;if(!r){return p}if(typeof r.length==="undefined"){return[r]}for(s=0;s<q;s+=1){p[s]=r[s]}return p},find:function(r,q,p){p=p||"css";return this.list2Array(this[p](r,q))},css:function(q,p){p=p||document;return o(p).find(q).get()}};m=(function(){var p=new d.utils.WeakMap();return{add:function(q){var r=p.get(q)||[n(q),0];r[1]+=1;p.set(q,r);return r[0]},find:function(q){var r=p.get(q);return r?r[0]:null},remove:function(q){var r=p.get(q);if(r){r[1]-=1;if(r[1]<=0){p.remove(q)}}}}}());function j(q){var p=(h.useCapture===true);a.xpath=b.queryDom.xpath;if(q.hasOwnProperty("jQueryObject")){o=d.utils.access(q.jQueryObject)}else{o=window.jQuery}k();if(p&&typeof document.addEventListener==="function"){f=function(u,s,t){var r=function(v){t(o.event.fix(v))};u.addEventListener(s,r,p)};c=function(u,s,t){var r=function(v){t(o.event.fix(v))};u.removeEventListener(s,r,p)}}else{f=function(t,r,s){o(t).on(r,s)};c=function(t,r,s){o(t).off(r,s)}}l=true}return{init:function(){if(!l){j(g.getServiceConfig("browser")||{})}else{}},destroy:function(){l=false},getServiceName:function(){return"jQuery"},query:function(s,q,p){try{return a.find(s,q,p)[0]||null}catch(r){return[]}},queryAll:function(s,q,p){try{return a.find(s,q,p)}catch(r){return[]}},loadScript:function(p){o.getScript(p)},subscribe:function(p,u,q,t,s){var r=m.add(q);if(!t){f(u,p,r)}else{o(t).on(p,u,s,r)}},unsubscribe:function(p,u,q,s){var r=m.find(q);if(r){try{if(!s){c(u,p,r)}else{o(s).off(p,u,r)}}catch(t){}m.remove(q)}},getJQuery:function(){return o}}});TLT.addService("ajax",function(d){var c,f=d.getService("config"),g=d.getService("browser"),i,h=false;function e(l){l=l.split("\n");var n={},k=0,j=l.length,m=null;for(k=0;k<j;k+=1){m=l[k].split(": ");n[m[0]]=m[1]}return n}function a(j){return function k(m,l,o){var n=m,p=false;if(l==="success"){n=o||m;p=true}j({headers:e(n.getAllResponseHeaders()),responseText:n.responseText,statusCode:n.status,success:p})}}c={init:function(k){var j=parseFloat(i.fn.jquery);if(j<=1.7){this.init=c["jQuery<=1.7"]}else{this.init=c["jQuery>=1.8"]}this.init(k)},"jQuery<=1.7":function(j){j.complete=a(j.oncomplete);delete j.oncomplete;i.ajax(j)},"jQuery>=1.8":function(l){var k=a(l.oncomplete),j;delete l.oncomplete;j=i.ajax(l.url,l);j.always(k)}};function b(j){if(j.hasOwnProperty("jQueryObject")){i=d.utils.access(j.jQueryObject)}else{i=window.jQuery}h=true}return{init:function(){if(!h){b(f.getServiceConfig("browser")||{})}else{}},destroy:function(){h=false},sendRequest:function(j){j.type=j.type||"POST";j.processData=j.processData||false;c.init(j)}}});TLT.addService("domCapture",function(o){var s=o.getService("config"),k,m=false,b=1,j=function(){},r=function(){},g=function(){};function d(t){s.subscribe("configupdated",g);k=o.getService("message");m=true}function f(){s.unsubscribe("configupdated",g);m=false}function a(){var t;t="tlt-"+o.utils.getSerialNumber();return t}function l(w,v){var u,t;if(!w||!w.getElementsByTagName||!v){return}t=w.getElementsByTagName(v);if(t&&t.length){for(u=t.length-1;u>=0;u-=1){t[u].parentNode.removeChild(t[u])}}return w}function h(v){var u,t=null;if(!v||!v.doctype){return null}u=v.doctype;if(u){t="<!DOCTYPE "+u.name+(u.publicId?' PUBLIC "'+u.publicId+'"':"")+(!u.publicId&&u.systemId?" SYSTEM":"")+(u.systemId?' "'+u.systemId+'"':"")+">"}return t}function i(A){var y,w,B,t,z,u,x,v;if(!A){return}t=A.getElementsByTagName("input");if(t){for(y=0,z=t.length;y<z;y+=1){B=t[y];switch(B.type){case"checkbox":case"radio":if(B.checked){B.setAttribute("checked","checked")}else{B.removeAttribute("checked")}break;default:B.setAttribute("value",B.value);break}}}}function n(t,y){var u,A,z,B,w,v,x;if(!t||!t.getElementsByTagName||!y||!y.getElementsByTagName){return}A=t.getElementsByTagName("select");B=y.getElementsByTagName("select");if(A){for(w=0,x=A.length;w<x;w+=1){u=A[w];z=B[w];for(v=0;v<u.options.length;v+=1){if(v===u.selectedIndex||u.options[v].selected){z.options[v].setAttribute("selected","selected")}else{z.options[v].removeAttribute("selected")}}}}}function q(u){var t,v=null;if(u){t=u.nodeType||-1;switch(t){case 9:v=u.documentElement.outerHTML;break;case 1:v=u.outerHTML;break;default:v=null;break}}return v}function e(v){var t,u=false;if(v){t=v.nodeType||-1;switch(t){case 9:case 1:u=true;break;default:u=false;break}}return u}function p(t,G,J){var B,z,E,D,x=["iframe","frame"],I,v,H,w,u,C={frames:[],canvas:[]},A,y;for(z=0;z<x.length;z+=1){D=x[z];A=t.getElementsByTagName(D);y=G.getElementsByTagName(D);if(A){for(B=0,E=A.length;B<E;B+=1){try{I=A[B];v=o.utils.getIFrameWindow(I);if(v&&v.document){H=v.document;w=r(H,H,J);u=a();y[B].setAttribute("tltid",u);C.frames.push({root:w.root,charset:H.characterSet||H.charset,tltid:u});C.frames=C.frames.concat(w.frames);C.canvas=C.canvas.concat(w.canvas)}}catch(F){}}}}return C}function c(v){var u,t,w=0;if(!v||!v.root){return w}w=v.root.length;for(u=0,t=v.frames.length;u<t;u+=1){if(v.frames[u].root){w+=v.frames[u].root.length}}return w}j=function(t){var u=null;if(e(t)){u=t.cloneNode(true);if(!u&&t.documentElement){u=t.documentElement.cloneNode(true)}}return u};r=function(x,u,v){var z=null,w,t,y={};if(!x||!u){return y}z=j(u,x);if(v.removeScripts){l(z,"script")}n(u,z);i(z);z=k.applyPrivacyToDocument(z);if(v.captureCanvas){w=null}if(v.captureFrames){t=p(u,z,v)}if(t){y=o.utils.mixin(y,t)}if(w){if(!y.canvas){y.canvas=[]}y.canvas=y.canvas.concat(w)}y.root=(h(u)||"")+q(z);y.charset=x.characterSet||x.charset;return y};g=function(){s=o.getService("config");d(s.getServiceConfig("domCapture")||{})};return{init:function(){s=o.getService("config");if(!m){d(s.getServiceConfig("domCapture")||{})}else{}},destroy:function(){f()},captureDOM:function(t,u){var v=null,w=0;if(!m||o.utils.isLegacyIE){return v}if(!u||typeof u!=="object"){u={}}t=t||window.document;v=r(window.document,t,u);if(u.maxLength){w=c(v);if(w>u.maxLength){v={errorCode:101,error:"Captured length ("+w+") exceeded limit ("+u.maxLength+")."}}}return v}}});TLT.addService("encoder",function(a){var f={},g=null,b=null,d=false;function e(j){var i=null;if(!j){return i}i=f[j];if(i&&typeof i.encode==="string"){i.encode=a.utils.access(i.encode)}return i}function h(i){f=i;g.subscribe("configupdated",b);d=true}function c(){g.unsubscribe("configupdated",b);d=false}b=function(){g=a.getService("config");h(g.getServiceConfig("encoder")||{})};return{init:function(){g=a.getService("config");if(!d){h(g.getServiceConfig("encoder")||{})}else{}},destroy:function(){c()},encode:function(m,l){var k,i,j={data:null,encoding:null,error:null};if((typeof m!=="string"&&!m)||!l){j.error="Invalid "+(!m?"data":"type")+" parameter.";return j}k=e(l);if(!k){j.error="Specified encoder ("+l+") not found.";return j}if(typeof k.encode!=="function"){j.error="Configured encoder ("+l+") encode method is not a function.";return j}i=k.encode(m);if(!i||a.utils.getValue(i,"buffer",null)===null){j.error="Encoder ("+l+") returned an invalid result.";return j}j.data=i.buffer;j.encoding=k.defaultEncoding;return j}}});TLT.addService("message",function(r){var o=null,B=0,i=0,m=new Date(),p=new Date(),h=r.getService("browserBase"),a=r.getService("browser"),g=r.getService("config"),v=g.getServiceConfig("message")||{},k=window.location.href,G="TODO",J="ID"+p.getHours()+"H"+p.getMinutes()+"M"+p.getSeconds()+"S"+p.getMilliseconds()+"R"+Math.random(),K=v.hasOwnProperty("privacy")?v.privacy:[],y={},H={lower:"x",upper:"X",numeric:"9",symbol:"@"},q=navigator.userAgent.indexOf("iPhone")>-1||navigator.userAgent.indexOf("iPod")>-1||navigator.userAgent.indexOf("iPad")>-1,n=navigator.userAgent.indexOf("Chrome")>-1&&navigator.userAgent.indexOf("Android")>-1,f=window.devicePixelRatio||1,e=window.screen?window.screen.width:0,u=window.screen?window.screen.height:0,I=window.orientation||0,j=q||n?e:e<=320?e:e/f,x=q||n?u:e<=320?u:u/f,E=(window.screen?window.screen.height-window.screen.availHeight:0),D=window.innerWidth||document.documentElement.clientWidth,l=window.innerHeight||document.documentElement.clientHeight,A=false;function c(M){var L="";this.type=M.type;this.offset=(new Date()).getTime()-m.getTime();if((M.type===2)||(o===null)){o=new Date()}this.screenviewOffset=(new Date()).getTime()-o.getTime();this.count=(i+=1);this.fromWeb=true;for(L in M){if(M.hasOwnProperty(L)){this[L]=M[L]}}}y.PVC_MASK_EMPTY=function(L){return""};y.PVC_MASK_BASIC=function(M){var L="XXXXX";if(typeof M!=="string"){return""}return(M.length?L:"")};y.PVC_MASK_TYPE=function(P){var M,O=0,L=0,N="";if(typeof P!=="string"){return N}M=P.split("");for(O=0,L=M.length;O<L;O+=1){if(r.utils.isNumeric(M[O])){N+=H.numeric}else{if(r.utils.isUpperCase(M[O])){N+=H.upper}else{if(r.utils.isLowerCase(M[O])){N+=H.lower}else{N+=H.symbol}}}}return N};y.PVC_MASK_EMPTY.maskType=1;y.PVC_MASK_BASIC.maskType=2;y.PVC_MASK_TYPE.maskType=3;y.PVC_MASK_CUSTOM={maskType:4};function b(L,N){var M=y.PVC_MASK_BASIC;if(typeof N!=="string"){return N}if(!L){M=y.PVC_MASK_BASIC}else{if(L.maskType===y.PVC_MASK_EMPTY.maskType){M=y.PVC_MASK_EMPTY}else{if(L.maskType===y.PVC_MASK_BASIC.maskType){M=y.PVC_MASK_BASIC}else{if(L.maskType===y.PVC_MASK_TYPE.maskType){M=y.PVC_MASK_TYPE}else{if(L.maskType===y.PVC_MASK_CUSTOM.maskType){if(typeof L.maskFunction==="string"){M=r.utils.access(L.maskFunction)}else{M=L.maskFunction}if(typeof M!=="function"){M=y.PVC_MASK_BASIC}}}}}}return M(N)}function w(L,M){if(!M||!M.target){return}if(typeof M.target.prevState!=="undefined"&&M.target.prevState.hasOwnProperty("value")){M.target.prevState.value=b(L,M.target.prevState.value)}if(typeof M.target.currState!=="undefined"&&M.target.currState.hasOwnProperty("value")){M.target.currState.value=b(L,M.target.currState.value)}}function F(S,T){var P,O,Q,U,L,N,V,R,M;if(!S||!T||!T.id){return false}for(P=0,R=S.length;P<R;P+=1){M=S[P];if(typeof M==="string"){U=a.queryAll(M);for(O=0,L=U?U.length:0;O<L;O+=1){if(U[O]){N=h.ElementData.prototype.examineID(U[O]);if(N.type===T.idType&&N.id===T.id){return true}}}}else{if(M.id&&M.idType&&T.idType.toString()===M.idType.toString()){switch(typeof M.id){case"string":if(M.id===T.id){return true}break;case"object":V=new RegExp(M.id.regex,M.id.flags);if(V.test(T.id)){return true}break}}}}return false}function z(O){var N,L,M;if(!O||!O.hasOwnProperty("target")){return O}for(N=0,L=K.length;N<L;N+=1){M=K[N];if(F(M.targets,O.target)){w(M,O);break}}return O}function d(V){var O,N,M,P,R,W,U,L,T,Q,S;if(!V){return V}for(O=0,R=K.length;O<R;O+=1){W=K[O];Q=W.targets;for(N=0,S=Q.length;N<S;N+=1){T=Q[N];if(typeof T==="string"){U=a.queryAll(T,V);for(M=0,L=U.length;M<L;M+=1){P=U[M];if(P.value){P.setAttribute("value",b(W,P.value))}}}else{if(typeof T.id==="string"){P=h.getNodeFromID(T.id,T.idType,V);if(P&&P.value){P.setAttribute("value",b(W,P.value))}}}}}return V}function s(){g=r.getService("config");v=g.getServiceConfig("message")||{};K=v.hasOwnProperty("privacy")?v.privacy:[]}function t(){if(g.subscribe){g.subscribe("configupdated",s)}A=true}function C(){g.unsubscribe("configupdated",s);A=false}return{init:function(){if(!A){t()}else{}},destroy:function(){C()},applyPrivacyToDocument:d,createMessage:function(L){if(typeof L.type==="undefined"){throw new TypeError("Invalid queueEvent given!")}return z(new c(L))},wrapMessages:function(M){var L={messageVersion:"4.0.0.0",serialNumber:(B+=1),sessions:[{id:J,startTime:p.getTime(),timezoneOffset:p.getTimezoneOffset(),messages:M,clientEnvironment:{webEnvironment:{libVersion:"4.0.0.1607",page:k,windowId:G,screen:{devicePixelRatio:f,deviceOriginalWidth:q||n?e*f:e,deviceOriginalHeight:q||n?u*f:u,deviceWidth:j,deviceHeight:x,deviceToolbarHeight:E,width:D,height:l,orientation:I}}}}]},N=L.sessions[0].clientEnvironment.webEnvironment.screen;N.orientationMode=r.utils.getOrientationMode(N.orientation);return L}}});TLT.addService("serializer",function(core){function serializeToJSON(obj){var str,key,len=0;if(typeof obj!=="object"||obj===null){switch(typeof obj){case"function":case"undefined":return"null";case"string":return'"'+obj.replace(/\"/g,'\\"')+'"';default:return String(obj)}}else{if(Object.prototype.toString.call(obj)==="[object Array]"){str="[";for(key=0,len=obj.length;key<len;key+=1){if(Object.prototype.hasOwnProperty.call(obj,key)){str+=serializeToJSON(obj[key])+","}}}else{str="{";for(key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){str=str.concat('"',key,'":',serializeToJSON(obj[key]),",");len+=1}}}}if(len>0){str=str.substring(0,str.length-1)}str+=String.fromCharCode(str.charCodeAt(0)+2);return str}var configService=core.getService("config"),serialize={},parse={},defaultSerializers={json:(function(){if(typeof window.JSON!=="undefined"){return{serialize:window.JSON.stringify,parse:window.JSON.parse}}return{serialize:serializeToJSON,parse:function(data){return eval("("+data+")")}}}())},updateConfig=null,isInitialized=false;function addObjectIfExist(paths,rootObj,propertyName){var i,len,obj;paths=paths||[];for(i=0,len=paths.length;i<len;i+=1){obj=paths[i];if(typeof obj==="string"){obj=core.utils.access(obj)}if(typeof obj==="function"){rootObj[propertyName]=obj;break}}}function checkParserAndSerializer(){var isParserAndSerializerInvalid;if(typeof serialize.json!=="function"||typeof parse.json!=="function"){isParserAndSerializerInvalid=true}else{if(typeof parse.json('{"foo": "bar"}')==="undefined"){isParserAndSerializerInvalid=true}else{isParserAndSerializerInvalid=parse.json('{"foo": "bar"}').foo!=="bar"}if(typeof parse.json("[1, 2]")==="undefined"){isParserAndSerializerInvalid=true}else{isParserAndSerializerInvalid=isParserAndSerializerInvalid||parse.json("[1, 2]")[0]!==1;isParserAndSerializerInvalid=isParserAndSerializerInvalid||parse.json("[1,2]")[1]!==2}isParserAndSerializerInvalid=isParserAndSerializerInvalid||serialize.json({foo:"bar"})!=='{"foo":"bar"}';isParserAndSerializerInvalid=isParserAndSerializerInvalid||serialize.json([1,2])!=="[1,2]"}return isParserAndSerializerInvalid}function initSerializerService(config){var format;for(format in config){if(config.hasOwnProperty(format)){addObjectIfExist(config[format].stringifiers,serialize,format);addObjectIfExist(config[format].parsers,parse,format)}}if(!(config.json&&config.json.hasOwnProperty("defaultToBuiltin"))||config.json.defaultToBuiltin===true){serialize.json=serialize.json||defaultSerializers.json.serialize;parse.json=parse.json||defaultSerializers.json.parse}if(typeof serialize.json!=="function"||typeof parse.json!=="function"){core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.")}if(checkParserAndSerializer()){core.fail("JSON stringification and parsing are not working as expected")}if(configService.subscribe){configService.subscribe("configupdated",updateConfig)}isInitialized=true}function destroy(){serialize={};parse={};configService.unsubscribe("configupdated",updateConfig);isInitialized=false}updateConfig=function(){configService=core.getService("config");initSerializerService(configService.getServiceConfig("serializer")||{})};return{init:function(){if(!isInitialized){initSerializerService(configService.getServiceConfig("serializer")||{})}else{}},destroy:function(){destroy()},parse:function(data,type){type=type||"json";return parse[type](data)},serialize:function(data,type){type=type||"json";return serialize[type](data)}}});if(TLT&&typeof TLT.addModule==="function"){TLT.addModule("overstat",function(e){var n={"input:radio":"radioButton","input:checkbox":"checkBox","input:text":"textBox","input:password":"textBox","input:file":"fileInput","input:button":"button","input:submit":"submitButton","input:reset":"resetButton","input:image":"image","input:color":"color","input:date":"date","input:datetime":"datetime","input:datetime-local":"datetime-local","input:number":"number","input:email":"email","input:tel":"tel","input:search":"search","input:url":"url","input:time":"time","input:week":"week","input:month":"month","textarea:":"textBox","select:":"selectList","button:":"button","a:":"link"},p={},B={UPDATE_INTERVAL:250,HOVER_THRESHOLD_MIN:1000,HOVER_THRESHOLD_MAX:2*60*1000,GRIDCELL_MAX_X:10,GRIDCELL_MAX_Y:10,GRIDCELL_MIN_WIDTH:20,GRIDCELL_MIN_HEIGHT:20};function d(J,I){var H,G;if(!J||typeof J!=="object"){return null}G=I.split(".");for(H=0;H<G.length;H+=1){if((typeof J==="undefined")||(J[G[H]]===null)){return null}J=J[G[H]]}return J}function x(G){var H=e.getConfig()||{},I=H[G];return typeof I==="number"?I:B[G]}function F(L,G){var H=d(L,"webEvent.target.element.tagName")||"",I=H.toLowerCase()==="input"?d(L,"webEvent.target.element.type"):"",K=n[H.toLowerCase()+":"+I]||H,J={type:9,event:{hoverDuration:L.hoverDuration,hoverToClick:d(G,"hoverToClick")},target:{id:d(L,"webEvent.target.id")||"",idType:d(L,"webEvent.target.idType")||"",name:d(L,"webEvent.target.name")||"",tlType:K,type:H,subType:I,position:{width:d(L,"webEvent.target.element.offsetWidth")||0,height:d(L,"webEvent.target.element.offsetHeight")||0,relXY:L.gridX+","+L.gridY}}};if((typeof J.target.id)===undefined||J.target.id===""){return}e.post(J)}function s(G){if(G&&G.element){G=G.element}return !G||G===document.body||G===document.html||G===document}function j(G){if(!G){return null}return G.element?G.element.parentNode:G.parentNode}function o(H){if(!H){return null}var G=H.element?H.element.offsetParent:H.offsetParent;return G||j(H)}function w(G,H){if(!H||H===G){return false}H=j(H);while(!s(H)){if(H===G){return true}H=j(H)}return false}function D(G){if(G.nativeEvent){G=G.nativeEvent}return G}function y(G){return D(G).target}function i(G){if(!G){return null}return G.element||G}function h(G){if(!G){return -1}if(G.element){G=G.element}return G.nodeType||-1}function C(G){if(!G){return""}if(G.element){G=G.element}return G.tagName?G.tagName.toUpperCase():""}function z(G){if(G&&G.element){G=G.element}return G}function t(G){if(!G){return}if(G.nativeEvent){G=G.nativeEvent}if(G.stopPropagation){G.stopPropagation()}else{if(G.cancelBubble){G.cancelBubble()}}}function m(H){var G=C(H);return h(H)!==1||G==="TR"||G==="TBODY"||G==="THEAD"}function g(G){if(!G){return""}if(G.xPath){return G.xPath}G=i(G);return e.getXPathFromNode(G)}function A(H,G){var I=p[H];if(I&&I[G]){return I[G]()}}function v(H,J,I,G){this.xPath=H!==null?g(H):"";this.domNode=H;this.hoverDuration=0;this.hoverUpdateTime=0;this.gridX=Math.max(J,0);this.gridY=Math.max(I,0);this.parentKey="";this.updateTimer=-1;this.disposed=false;this.childKeys={};this.webEvent=G;this.getKey=function(){return this.xPath+":"+this.gridX+","+this.gridY};this.update=function(){var L=new Date().getTime(),K=this.getKey();if(this.hoverUpdateTime!==0){this.hoverDuration+=L-this.hoverUpdateTime}this.hoverUpdateTime=L;clearTimeout(this.updateTimer);this.updateTimer=setTimeout(function(){A(K,"update")},x("UPDATE_INTERVAL"))};this.dispose=function(K){clearTimeout(this.updateTimer);delete p[this.getKey()];this.disposed=true;if(K){var L=this.clone();p[L.getKey()]=L;L.update()}};this.process=function(N){clearTimeout(this.updateTimer);if(this.disposed){return false}var L=false,M=this,K=null;if(this.hoverDuration>=x("HOVER_THRESHOLD_MIN")){this.hoverDuration=Math.min(this.hoverDuration,x("HOVER_THRESHOLD_MAX"));L=true;F(this,{hoverToClick:!!N});while(typeof M!=="undefined"){M.dispose(N);M=p[M.parentKey]}}else{this.dispose(N)}return L};this.clone=function(){var K=new v(this.domNode,this.gridX,this.gridY);K.parentKey=this.parentKey;return K}}function E(I,G,J,H){return new v(I,G,J,H)}function r(M){if(M&&M.position){return{x:M.position.x,y:M.position.y}}M=z(M);var G=M.offsetLeft,N=M.offsetTop,L=G,K=N,I=0,H=0,J=o(M);while(J){if(s(J)){break}I=J.offsetLeft-(J.scrollLeft||0);H=J.offsetTop-(J.scrollTop||0);if(I!==L||H!==K){G+=I;N+=H;L=I;K=H}J=o(J)}if(isNaN(G)){G=0}if(isNaN(N)){N=0}return{x:G,y:N}}function a(K,I,H){K=z(K);var J=r(K),G=I-J.x,L=H-J.y;if(!isFinite(G)){G=0}if(!isFinite(L)){L=0}return{x:G,y:L}}function f(J,H,M){J=z(J);var I=J.offsetWidth>0?Math.max(J.offsetWidth/x("GRIDCELL_MAX_X"),x("GRIDCELL_MIN_WIDTH")):x("GRIDCELL_MIN_WIDTH"),G=J.offsetHeight>0?Math.max(J.offsetHeight/x("GRIDCELL_MAX_X"),x("GRIDCELL_MIN_HEIGHT")):x("GRIDCELL_MIN_HEIGHT"),L=Math.floor(H/I),K=Math.floor(M/G);if(!isFinite(L)){L=0}if(!isFinite(K)){K=0}return{x:L,y:K}}function c(J){var K=J,L=J.getKey(),G={},H=null,I=null;G[L]=true;while(typeof K!=="undefined"){G[K.parentKey]=true;if(K.parentKey===""||K.parentKey===K.getKey()){break}K=p[K.parentKey]}for(H in p){if(p.hasOwnProperty(H)&&!G[H]){K=p[H];if(K){K.process()}}}}function u(H,I){var J=null,G=null;for(G in p){if(p.hasOwnProperty(G)){J=p[G];if(J.domNode===H&&J.getKey()!==I){J.process()}}}}function b(K,I,J){if(!I){I=K.target}if(s(I)){return null}if(e.utils.isiOS||e.utils.isAndroid){return null}var G,P,L,O,M,N,H;if(!m(I)){G=a(I,K.position.x,K.position.y);P=f(I,G.x,G.y);L=new v(I,P.x,P.y,K);O=L.getKey();if(p[O]){L=p[O]}else{p[O]=L}L.update();if(!J){H=o(I);if(H){N=b(K,H,true);if(N!==null){M=N.getKey();O=L.getKey();if(O!==M){L.parentKey=M}}}c(L)}}else{L=b(K,o(I),J)}return L}function q(G){G=D(G);if(w(G.target,G.relatedTarget)){return}u(G.target)}function l(H){var I=null,G;for(G in p){if(p.hasOwnProperty(G)){I=p[G];I.process(true)}}}function k(H){var G=d(H,"target.id");if(!G){return}switch(H.type){case"mousemove":b(H);break;case"mouseout":q(H);break;case"click":l(H);break}}return{init:function(){},destroy:function(){var H,G;for(H in p){if(p.hasOwnProperty(H)){p[H].dispose();delete p[H]}}},onevent:function(G){if(typeof G!=="object"||!G.type){return}k(G)},onmessage:function(G){},createHoverEvent:E,cleanupHoverEvents:c,eventMap:p}})}else{}if(TLT&&typeof TLT.addModule==="function"){TLT.addModule("performance",function(f){var h={loadReceived:false,unloadReceived:false,perfEventSent:false},g=0;function b(j,i){if(typeof j!=="string"){return false}if(!i||typeof i!=="object"){return false}return(i[j]===true)}function e(k,i){var m=0,j={},n="",l=0;if(!k||typeof k!=="object"||!k.navigationStart){return{}}m=k.navigationStart;for(n in k){if(Object.prototype.hasOwnProperty.call(k,n)||typeof k[n]==="number"){if(!b(n,i)){l=k[n];if(typeof l==="number"&&l&&n!=="navigationStart"){j[n]=l-m}else{j[n]=l}}}}return j}function d(l){var m=0,k,j,i=f.utils;if(l){k=(l.responseEnd>0&&l.responseEnd<l.domLoading)?l.responseEnd:l.domLoading;j=l.loadEventStart;if(i.isNumeric(k)&&i.isNumeric(j)&&j>k){m=j-k}}return m}function c(j){var i=f.getStartTime();if(j.timestamp>i&&!g){g=j.timestamp-i}}function a(m){var k=f.getConfig()||{},j="UNKNOWN",n={type:7,performance:{}},i,o,l;if(!m||h.perfEventSent){return}o=m.performance||{};l=o.timing;i=o.navigation;if(l){n.performance.timing=e(l,k.filter);n.performance.timing.renderTime=d(l)}else{if(k.calculateRenderTime){n.performance.timing={renderTime:g,calculated:true}}else{return}}if(k.renderTimeThreshold&&n.performance.timing.renderTime>k.renderTimeThreshold){n.performance.timing.invalidRenderTime=n.performance.timing.renderTime;delete n.performance.timing.renderTime}if(i){switch(i.type){case 0:j="NAVIGATE";break;case 1:j="RELOAD";break;case 2:j="BACKFORWARD";break;default:j="UNKNOWN";break}n.performance.navigation={type:j,redirectCount:i.redirectCount}}f.post(n);h.perfEventSent=true}return{init:function(){},destroy:function(){},onevent:function(i){if(typeof i!=="object"||!i.type){return}switch(i.type){case"load":h.loadReceived=true;c(i);break;case"unload":h.unloadReceived=true;if(!h.perfEventSent){a(window)}break;default:break}},onmessage:function(i){}}})}else{}TLT.addModule("replay",function(an){var C={"a:":"link","button:button":"button","button:submit":"button","input:button":"button","input:checkbox":"checkBox","input:color":"colorPicker","input:date":"datePicker","input:datetime":"datetimePicker","input:datetime-local":"datetime-local","input:email":"emailInput","input:file":"fileInput","input:image":"image","input:month":"month","input:number":"numberPicker","input:password":"textBox","input:radio":"radioButton","input:range":"slider","input:reset":"resetButton","input:search":"searchBox","input:submit":"submitButton","input:tel":"tel","input:text":"textBox","input:time":"timePicker","input:url":"urlBox","input:week":"week","select:":"selectList","select:select-one":"selectList","textarea:":"textBox","textarea:textarea":"textBox"},ao=an.utils,N=window.orientation||0,ai={scale:0,timestamp:0},ac={},D=window.location.hash,J=null,e=[],ad=0,af=null,B=null,l=0,W="",y="",R=(new Date()).getTime(),k=0,U=null,al=null,S=null,E=null,aj=null,X=null,aa=0,v=0,ag=null,u={inFocus:false},O=null,z=ao.isiOS,x=navigator.userAgent.indexOf("Chrome")>-1&&ao.isAndroid,r=window.devicePixelRatio||1,q=(window.screen?window.screen.width:0),I=(window.screen?window.screen.height:0),Y=(window.screen?window.screen.height-window.screen.availHeight:0),M=an.getConfig(),ah=1,F=1,T;function s(ar){var ap=false,aq="|button|image|submit|reset|checkbox|radio|",at=null;if(typeof ar!=="object"||!ar.type){return ap}switch(ar.type){case"INPUT":at="|"+(ar.subType||"")+"|";if(aq.indexOf(at.toLowerCase())===-1){ap=false}else{ap=true}break;case"SELECT":case"TEXTAREA":ap=false;break;default:ap=true;break}return ap}function h(aq){var ap=[];aq=aq.parentNode;while(aq){ap.push(aq);aq=aq.parentNode}return ap}function w(ap){return an.utils.some(ap,function(aq){if(aq.tagName==="A"||aq.tagName==="BUTTON"){return aq}return null})}function n(ap){var aq=ap.type,ar=ap.target;if(typeof aq==="string"){aq=aq.toLowerCase()}else{aq="unknown"}if(aq==="blur"){aq="focusout"}if(aq==="change"){if(ar.type==="INPUT"){switch(ar.subType){case"text":case"date":case"time":aq=ar.subType+"Change";break;default:aq="valueChange";break}}else{if(ar.type==="TEXTAREA"){aq="textChange"}else{aq="valueChange"}}}return aq}function A(ap,ar,aq){var at=null;if(!ap){return at}ar=ar||{};if(aq){at="dcid-"+an.utils.getSerialNumber()+"."+(new Date()).getTime()+"s";window.setTimeout(function(){ar.dcid=at;an.performDOMCapture(ap,ar)},aq)}else{delete ar.dcid;at=an.performDOMCapture(ap,ar)}return at}function L(ap,az,aq){var av,aC=false,ar,aB=false,at,aw,ay=null,au=0,ax,aA;if(!ap||(!az&&!aq)){return ay}if(!az&&!(ap==="load"||ap==="unload")){return ay}aA=an.getConfig()||{};aB=ao.getValue(aA,"domCapture.enabled",false);if(!aB||an.utils.isLegacyIE){return ay}aw=ao.getValue(aA,"domCapture.triggers")||[];for(av=0,ax=aw.length;av<ax;av+=1){at=aw[av];if(at.event===ap){if(ap==="load"||ap==="unload"){if(at.screenviews){aC=(-1!==ao.indexOf(at.screenviews,aq))}else{aC=true}}else{if(at.targets){aC=(-1!==ao.matchTarget(at.targets,az))}else{aC=true}}}if(aC){ar=ao.getValue(aA,"domCapture.options",{});au=at.delay||0;ay=A(window.document,ar,au);break}}return ay}function ab(aA){var ar,at,au=ao.getValue(aA,"webEvent.target",{}),ap=au.type,aw=au.subType||null,aq=C[ap.toLowerCase()+":"+aw]||ap,ax=h(ao.getValue(au,"element")),az=null,av=ao.getValue(au,"position.relXY"),ay=ao.getValue(aA,"webEvent.subType",null);ar={type:4,target:{id:au.id||"",idType:au.idType,name:au.name,tlType:aq,type:ap,position:{width:ao.getValue(au,"element.offsetWidth"),height:ao.getValue(au,"element.offsetHeight")},currState:aA.currState||null},event:{tlEvent:n(ao.getValue(aA,"webEvent")),type:ao.getValue(aA,"webEvent.type","UNKNOWN")}};if(aw){ar.target.subType=aw}if(av){ar.target.position.relXY=av}if(typeof aA.dwell==="number"&&aA.dwell>0){ar.target.dwell=aA.dwell}if(typeof aA.visitedCount==="number"){ar.target.visitedCount=aA.visitedCount}if(typeof aA.prevState!=="undefined"){ar.prevState=aA.prevState}if(ay){ar.event.subType=ay}az=w(ax);ar.target.isParentLink=!!az;if(az){if(az.href){ar.target.currState=ar.target.currState||{};ar.target.currState.href=ar.target.currState.href||az.href}if(az.value){ar.target.currState=ar.target.currState||{};ar.target.currState.value=ar.target.currState.value||az.value}if(az.innerText||az.textContent){ar.target.currState=ar.target.currState||{};ar.target.currState.innerText=ao.trim(ar.target.currState.innerText||az.innerText||az.textContent)}}if(ao.isUndefOrNull(ar.target.currState)){delete ar.target.currState}if(ao.isUndefOrNull(ar.target.name)){delete ar.target.name}if(ar.event.type!=="click"||s(au)){at=L(ar.event.type,au);if(at){ar.dcid=at}}return ar}function G(ap){an.post(ap)}function K(au){var ar=0,ap,av=au.length,ax,aw,at,ay={mouseout:true,mouseover:true},aq=[];for(ar=0;ar<av;ar+=1){ax=au[ar];if(!ax){continue}if(ay[ax.event.type]){aq.push(ax)}else{for(ap=ar+1;ap<av&&au[ap];ap+=1){if(!ay[au[ap].event.type]){break}}if(ap<av){aw=au[ap];if(aw&&ax.target.id===aw.target.id&&ax.event.type!==aw.event.type){if(ax.event.type==="click"){at=ax;ax=aw;aw=at}if(aw.event.type==="click"){ax.target.position=aw.target.position;ar+=1}else{if(aw.event.type==="blur"){ax.target.dwell=aw.target.dwell;ax.target.visitedCount=aw.target.visitedCount;ax.focusInOffset=aw.focusInOffset;ax.target.position=aw.target.position;ar+=1}}au[ap]=null;au[ar]=ax}}aq.push(au[ar])}}for(ax=aq.shift();ax;ax=aq.shift()){an.post(ax)}au.splice(0,au.length)}if(typeof window.onerror!=="function"){window.onerror=function(at,ar,ap){var aq=null;if(typeof at!=="string"){return}ap=ap||-1;aq={type:6,exception:{description:at,url:ar,line:ap}};l+=1;an.post(aq)}}function o(aq,ap){u=ap;u.inFocus=true;if(typeof ac[aq]==="undefined"){ac[aq]={}}ac[aq].focus=u.dwellStart=Number(new Date());ac[aq].focusInOffset=S?u.dwellStart-Number(S):-1;ac[aq].prevState=ao.getValue(ap,"target.state");ac[aq].visitedCount=ac[aq].visitedCount+1||1}function Z(ap,aq){e.push(ab({webEvent:ap,id:aq,currState:ao.getValue(ap,"target.state")}))}function d(av,aq){var ar=false,au,ap,at=0;if(typeof av==="undefined"||av===null||typeof aq==="undefined"||aq===null){return}u.inFocus=false;if(typeof ac[av]!=="undefined"&&ac[av].hasOwnProperty("focus")){ac[av].dwell=Number(new Date())-ac[av].focus}else{ac[av]={};ac[av].dwell=0}if(e.length===0){Z(aq,av)}if(e[e.length-1]){for(at=e.length-1;at>=0;at--){e[at].target.visitedCount=ac[av].visitedCount}}ap=e[e.length-1];if(ap){ap.target.dwell=ac[av].dwell;ap.focusInOffset=ac[av].focusInOffset;ap.target.visitedCount=ac[av].visitedCount;if(ap.event.type==="click"){if(!s(ap.target)){ap.target.currState=ao.getValue(aq,"target.state");ar=true}}else{if(ap.event.type==="focus"){ar=true}}if(ar){ap.event.type="blur";ap.event.tlEvent="focusout";au=L(ap.event.type,aq.target);if(au){ap.dcid=au}}}K(e)}function m(ar,aq){var ap=false;if(e.length>0&&e[e.length-1]&&e[e.length-1].target.id!==ar&&aq.type!=="scroll"&&aq.type!=="resize"&&aq.type!=="mouseout"&&aq.type!=="mouseover"&&(e[e.length-1].target.tlType!=="textBox"&&e[e.length-1].target.tlType!=="selectList")){d(e[e.length-1].target.id,e[e.length-1]);ap=true}return ap}function c(aq,ap){if(typeof ac[aq]!=="undefined"&&!ac[aq].hasOwnProperty("focus")){o(aq,ap)}Z(ap,aq);if(typeof ac[aq]!=="undefined"&&typeof ac[aq].prevState!=="undefined"){if(e[e.length-1].target.tlType==="textBox"||e[e.length-1].target.tlType==="selectList"){e[e.length-1].target.prevState=ac[aq].prevState}}}function H(ar){var aq=ar.target.position.x,aw=ar.target.position.y,at=ar.target.size.width,ap=ar.target.size.height,av=Math.abs(aq/at).toFixed(1),au=Math.abs(aw/ap).toFixed(1);av=av>1||av<0?0.5:av;au=au>1||au<0?0.5:au;return av+","+au}function b(au,ar){var aq,ap=true,at=0;if(ar.target.element.tagName==="SELECT"&&O&&O.target.id===au){O=null;return}if(!u.inFocus){o(au,ar)}at=e.length;if(at&&ao.getValue(e[at-1],"event.type")!=="change"){c(au,ar)}aq=H(ar);at=e.length;if(ar.position.x===0&&ar.position.y===0&&at&&ao.getValue(e[at-1],"target.tlType")==="radioButton"){ap=false}else{ar.target.position.relXY=aq}if(at&&ao.getValue(e[at-1],"target.id")===au){if(ap){e[at-1].target.position.relXY=aq}}else{Z(ar,au)}O=ar}function ae(aq){var ap=0;if(window.orientation){ap=window.orientation}else{if(aq!==undefined&&aq.orientation){ap=aq.orientation}}return ap}function a(aq){var ap=ae(aq),ar={type:4,event:{type:"orientationchange"},target:{prevState:{orientation:N,orientationMode:ao.getOrientationMode(N)},currState:{orientation:ap,orientationMode:ao.getOrientationMode(ap)}}};G(ar);N=ap}function am(aq){var ap=false;if(!aq){return ap}ap=(ai.scale===aq.scale&&Math.abs((new Date()).getTime()-ai.timestamp)<500);return ap}function j(ap){ai.scale=ap.scale;ai.rotation=ap.rotation;ai.timestamp=(new Date()).getTime()}function Q(){var ap,aq;ap=ah-F;if(isNaN(ap)){aq="INVALID"}else{if(ap<0){aq="CLOSE"}else{if(ap>0){aq="OPEN"}else{aq="NONE"}}}return aq}function g(ap){var at=document.documentElement,ar=document.body,av={type:1,clientState:{pageWidth:document.width||(!at?0:at.offsetWidth),pageHeight:Math.max((!document.height?0:document.height),(!at?0:at.offsetHeight),(!at?0:at.scrollHeight)),viewPortWidth:window.innerWidth||at.clientWidth,viewPortHeight:window.innerHeight||at.clientHeight,viewPortX:window.pageXOffset||(!at?(!ar?0:ar.scrollLeft):at.scrollLeft||0),viewPortY:window.pageYOffset||(!at?(!ar?0:ar.scrollTop):at.scrollTop||0),deviceOrientation:window.orientation||0,event:ao.getValue(ap,"type")}},aq=1,au=1;B=B||av;if(Math.abs(av.clientState.deviceOrientation)===90){if(z||x){aq=I-Y}else{aq=q<=320?I-Y:((I/r)-Y)}}else{if(z||x){aq=q+Y}else{aq=q<=320?q-Y:((q/r)-Y)}}au=(av.clientState.viewPortWidth===0?1:aq/av.clientState.viewPortWidth);av.clientState.deviceScale=(au-0.02).toFixed(3);av.clientState.viewTime=0;if(E&&aj){av.clientState.viewTime=aj.getTime()-E.getTime()}if(ap.type==="scroll"){av.clientState.viewPortXStart=B.clientState.viewPortX;av.clientState.viewPortYStart=B.clientState.viewPortY}return av}function p(){if(af){G(af);B=af;af=null;E=X||E;aj=null}}function V(ap){var aq=null;af=g(ap);if(ap.type==="scroll"||ap.type==="resize"){if(p.timeoutId){window.clearTimeout(p.timeoutId);p.timeoutId=0}p.timeoutId=window.setTimeout(p,ao.getValue(M,"scrollTimeout",2000))}else{if(ap.type==="touchstart"||ap.type==="load"){if(af){F=parseFloat(af.clientState.deviceScale)}}else{if(ap.type==="touchend"){if(af){ah=parseFloat(af.clientState.deviceScale);p()}}}}if(ap.type==="load"||ap.type==="unload"){if(ap.type==="unload"&&R){aq=ao.clone(af);aq.clientState.event="attention";aq.clientState.viewTime=(new Date()).getTime()-R}p();if(aq){af=aq;p()}}return af}function ak(aq){var ap=ao.getValue(aq,"nativeEvent.touches.length",0);if(ap===2){V(aq)}}function i(at){var ar,aq={},au=ao.getValue(at,"nativeEvent.rotation",0)||ao.getValue(at,"nativeEvent.touches[0].webkitRotationAngle",0),av=ao.getValue(at,"nativeEvent.scale",1),ap=null,aw={type:4,event:{type:"touchend"},target:{id:ao.getValue(at,"target.id"),idType:ao.getValue(at,"target.idType")}};ar=ao.getValue(at,"nativeEvent.changedTouches.length",0)+ao.getValue(at,"nativeEvent.touches.length",0);if(ar!==2){return}V(at);ap={rotation:au?au.toFixed(2):0,scale:ah?ah.toFixed(2):1};ap.pinch=Q();aq.scale=F?F.toFixed(2):1;aw.target.prevState=aq;aw.target.currState=ap;G(aw)}function f(aA,at){var ax=["type","target.id"],ar=null,au,aw,av=true,ay=10,aq=0,az=0,ap=0;if(!aA||!at||typeof aA!=="object"||typeof at!=="object"){av=false}for(au=0,aw=ax.length;av&&au<aw;au+=1){ar=ax[au];if(ao.getValue(aA,ar)!==ao.getValue(at,ar)){av=false;break}}if(av){az=ao.getValue(aA,"timestamp");ap=ao.getValue(at,"timestamp");if(!(isNaN(az)&&isNaN(ap))){aq=Math.abs(ao.getValue(aA,"timestamp")-ao.getValue(at,"timestamp"));if(isNaN(aq)||aq>ay){av=false}}}return av}function P(){var ap=window.location.hash;if(ap===D){return}if(D){TLT.logScreenviewUnload(D)}if(ap){TLT.logScreenviewLoad(ap)}D=ap}function t(ap){var aq={type:4,event:{type:ap.type},target:{id:ao.getValue(ap,"target.id"),idType:ao.getValue(ap,"target.idType")}};G(aq)}return{init:function(){e=[]},destroy:function(){d(J);e=[]},onevent:function(ap){var ar=null,aq=null;if(typeof ap!=="object"||!ap.type){return}if(f(ap,U)){U=ap;return}U=ap;ar=ao.getValue(ap,"target.id");if(Object.prototype.toString.call(ac[ar])!=="[object Object]"){ac[ar]={}}m(ar,ap);ag=new Date();switch(ap.type){case"hashchange":P();break;case"focus":aq=o(ar,ap);break;case"blur":aq=d(ar,ap);break;case"click":aq=b(ar,ap);break;case"change":aq=c(ar,ap);break;case"orientationchange":aq=a(ap);break;case"touchstart":ak(ap);break;case"touchend":aq=i(ap);break;case"load":E=new Date();V(ap);TLT.logScreenviewLoad("root");break;case"screenview_load":S=new Date();aq=L("load",null,ap.name);break;case"screenview_unload":aq=L("unload",null,ap.name);break;case"resize":case"scroll":if(!aj){aj=new Date()}X=new Date();V(ap);break;case"unload":if(e!==null){K(e)}aj=new Date();V(ap);TLT.logScreenviewUnload("root");break;default:t(ap);break}J=ar;return aq},onmessage:function(){}}});TLT.addModule("saas",function(a){var c=function(){if(typeof TLT.getCoreConfig().modules.saas!=="undefined"){var d;for(d in TLT.getCoreConfig().modules.saas){if(TLT.getCoreConfig().modules.saas.hasOwnProperty(d)&&typeof d==="string"&&typeof TLT.getCoreConfig().modules.saas[d]==="string"){this[d]=TLT.getCoreConfig().modules.saas[d];document.cookie=d+"="+this[d]}}this.get=function(e){if(typeof e!=="string"||typeof this==="undefined"){return"SaaS Data undefined or key is not a string"}if(typeof this[e]==="undefined"){return"Key does not exist within saasData"}return this[e]};this.set=function(e,f){if(typeof e!=="string"||typeof f!=="string"||typeof this==="undefined"||e==="get"||e==="set"||e==="toSaasString"||e==="clear"||e==="remove"){return false}this[e]=f;document.cookie=e+"="+f;return true};this.clear=function(){var e;for(e in this){if(this.hasOwnProperty(e)&&e!=="get"&&e!=="set"&&e!=="toSaasString"&&e!=="clear"&&e!=="remove"){document.cookie=e+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";delete this[e]}}return};this.remove=function(e){if(this.hasOwnProperty(e)&&e!=="get"&&e!=="set"&&e!=="toSaasString"&&e!=="clear"&&e!=="remove"){document.cookie=e+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";delete this[e]}return};this.toSaasString=function(){var f="",e;for(e in this){if(this.hasOwnProperty(e)&&typeof this.get(e)==="string"){f+=e+"="+this.get(e)+";"}}return f}}},b=new c();return{init:function(){TLT.saasData=b},destroy:function(){},onevent:function(d){}}});</script>
<script type="text/tljs" id="UIC-SDK-FILE-w3c-prod-min">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags w3c,NDEBUG
 */
if(window.TLT){throw"Attempting to recreate TLT. Library may be included more than once on the page."}var TLT=(function(){function n(A,t,u,B){var z=null,C=null,y=TLT.getService("queue"),x=TLT.getModule("replay"),v=null,w=window.location,D=w.origin||null,s=w.pathname;if(!t||typeof t!=="string"){return}if(!u||typeof u!=="string"){u=""}if(!D){D=(w.protocol||"")+"//"+(w.host||"")}if(D.indexOf("file://")>-1){s=s.replace(/(.*?)(?=\/[^.\/]*\.app)/g,"").replace(".app//",".app/")}C={type:2,screenview:{type:A,name:t,url:s,host:D,referrer:u}};if(A==="LOAD"){v={type:"screenview_load",name:t}}else{if(A==="UNLOAD"){v={type:"screenview_unload",name:t}}}if(v&&x){z=x.onevent(v)}if(z){C.dcid=z}if(A==="LOAD"||A==="UNLOAD"){y.post("",C,"DEFAULT")}}var q=(new Date()).getTime(),r={},b={},d=false,e=null,k=(function(){var t,v=[];function u(A){var z=p.getService("browser"),w=p.getCoreConfig().framesBlacklist,y,x;t=t||[];A=A||null;if(typeof w!=="undefined"&&w.length>0){for(x=0;x<w.length;x+=1){y=z.queryAll(w[x],A);if(y&&y.length>0){t=t.concat(y)}}v=v.concat(z.queryAll("iframe",A))}}function s(w){if(p.utils.indexOf(v,w)<0){u(w.ownerDocument)}return p.utils.indexOf(t,w)>-1}s.clearCache=function(){t=null};return s}()),l=null,f={config:["getConfig","updateConfig","getCoreConfig","updateCoreConfig","getModuleConfig","updateModuleConfig","getServiceConfig","updateServiceConfig"],queue:["post","setAutoFlush","flushAll"],browserBase:["getXPathFromNode","processDOMEvent"]},o=(function(){var s={};return{normalizeModuleEvents:function(w,u,z,t){var y=false,v=false,x=p.getService("browser");z=z||p._getLocalTop();t=t||z.document;s[w]={loadFired:false,pageHideFired:false};p.utils.forEach(u,function(A){switch(A.name){case"load":y=true;u.push(p.utils.mixin(p.utils.mixin({},A),{name:"pageshow"}));break;case"unload":v=true;u.push(p.utils.mixin(p.utils.mixin({},A),{name:"pagehide"}));u.push(p.utils.mixin(p.utils.mixin({},A),{name:"beforeunload"}));break;case"change":if(p.utils.isLegacyIE&&p.getFlavor()==="w3c"){u.push(p.utils.mixin(p.utils.mixin({},A),{name:"propertychange"}))}break}});if(!y&&!v){delete s[w];return}s[w].silentLoad=!y;s[w].silentUnload=!v;if(!y){u.push({name:"load",target:z})}if(!v){u.push({name:"unload",target:z})}},canPublish:function(t,v){var u;if(s.hasOwnProperty(t)===false){return true}u=s[t];switch(v.type){case"load":u.pageHideFired=false;u.loadFired=true;return !u.silentLoad;case"pageshow":u.pageHideFired=false;v.type="load";return !u.loadFired&&!u.silentLoad;case"pagehide":v.type="unload";u.loadFired=false;u.pageHideFired=true;return !u.silentUnload;case"unload":case"beforeunload":v.type="unload";u.loadFired=false;return !u.pageHideFired&&!u.silentUnload}return true},isUnload:function(t){return typeof t==="object"?(t.type==="unload"||t.type==="beforeunload"||t.type==="pagehide"):false}}}()),c={},a={},g=function(){},i=null,j=true,m=null,h=function(){},p={getStartTime:function(){return q},init:function(t,u){var s;i=u;if(!j){throw"init must only be called once!"}j=false;s=function(v){v=v||window.event||{};if(document.addEventListener||v.type==="load"||document.readyState==="complete"){if(document.removeEventListener){document.removeEventListener("DOMContentLoaded",s,false);window.removeEventListener("load",s,false)}else{document.detachEvent("onreadystatechange",s);window.detachEvent("onload",s)}g(t,u)}};if(document.readyState==="complete"){setTimeout(s)}else{if(document.addEventListener){document.addEventListener("DOMContentLoaded",s,false);window.addEventListener("load",s,false)}else{document.attachEvent("onreadystatechange",s);window.attachEvent("onload",s)}}},isInitialized:function(){return d},getState:function(){return e},destroy:function(t){var s="",v="",y=null,z=null,w=null,u=null,A=false;if(j){return false}this.stopAll();if(!t){u=this.getService("browser");for(s in c){if(c.hasOwnProperty(s)&&u!==null){v=s.split("|")[0];y=c[s].target;A=c[s].delegateTarget||undefined;u.unsubscribe(v,y,this._publishEvent,A)}}}for(z in b){if(b.hasOwnProperty(z)){w=b[z].instance;if(w&&typeof w.destroy==="function"){w.destroy()}b[z].instance=null}}k.clearCache();c={};d=false;j=true;e="destroyed";if(typeof i==="function"){try{i("destroyed")}catch(x){}}},_updateModules:function(v){var u=this.getCoreConfig(),t=this.getService("browser"),x=null,s=null;if(u&&t&&u.modules){try{for(s in u.modules){if(u.modules.hasOwnProperty(s)){x=u.modules[s];if(r.hasOwnProperty(s)){if(x.enabled===false){this.stop(s);continue}this.start(s);if(x.events){this._registerModuleEvents(s,x.events,v)}}else{if(t.loadScript){t.loadScript(u.moduleBase+s+".js")}}}}this._registerModuleEvents.clearCache()}catch(w){p.destroy();return false}}else{return false}return true},rebind:function(s){p._updateModules(s)},getSessionData:function(){if(!p.isInitialized()){return}var w=null,t=null,u,v,s=p.getCoreConfig();if(!s||!s.sessionDataEnabled){return null}t=s.sessionData||{};u=t.sessionQueryName;if(u){v=p.utils.getQueryStringValue(u,t.sessionQueryDelim)}else{u=t.sessionCookieName||"TLTSID";v=p.utils.getCookieValue(u)}if(u&&v){w=w||{};w.tltSCN=u;w.tltSCV=v;w.tltSCVNeedsHashing=!!t.sessionValueNeedsHashing}return w},logCustomEvent:function(v,t){if(!p.isInitialized()){return}var u=null,s=this.getService("queue");if(!v||typeof v!=="string"){v="CUSTOM"}t=t||{};u={type:5,customEvent:{name:v,data:t}};s.post("",u,"DEFAULT")},logExceptionEvent:function(w,u,t){if(!p.isInitialized()){return}var v=null,s=this.getService("queue");if(!w||typeof w!=="string"){return}u=u||"";t=t||"";v={type:6,exception:{description:w,url:u,line:t}};s.post("",v,"DEFAULT")},logScreenviewLoad:function(u,t,s){if(!p.isInitialized()){return}n("LOAD",u,t,s)},logScreenviewUnload:function(s){if(!p.isInitialized()){return}n("UNLOAD",s)},logDOMCapture:function(u,w){var x=null,v,t,y,s;if(!this.isInitialized()){return x}if(p.utils.isLegacyIE){return x}t=this.getService("domCapture");if(t){u=u||window.document;w=w||{};v=t.captureDOM(u,w);if(v){x=w.dcid||("dcid-"+this.utils.getSerialNumber()+"."+(new Date()).getTime());v.dcid=x;y={type:12,domCapture:v};s=this.getService("queue");s.post("",y,"DEFAULT")}else{x=null}}return x},performDOMCapture:function(u,s,t){return this.logDOMCapture(s,t)},_bridgeCallback:function(t){var s=a[t];if(s&&s.enabled){return s}return null},logScreenCapture:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("screenCapture");if(s!==null){s.cbFunction()}},enableTealeafFramework:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("enableTealeafFramework");if(s!==null){s.cbFunction()}},disableTealeafFramework:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("disableTealeafFramework");if(s!==null){s.cbFunction()}},startNewTLFSession:function(){if(!p.isInitialized()){return}var s=p._bridgeCallback("startNewTLFSession");if(s!==null){s.cbFunction()}},currentSessionId:function(){if(!p.isInitialized()){return}var t,s=p._bridgeCallback("currentSessionId");if(s!==null){t=s.cbFunction()}return t},defaultValueForConfigurableItem:function(s){if(!p.isInitialized()){return}var u,t=p._bridgeCallback("defaultValueForConfigurableItem");if(t!==null){u=t.cbFunction(s)}return u},valueForConfigurableItem:function(s){if(!p.isInitialized()){return}var u,t=p._bridgeCallback("valueForConfigurableItem");if(t!==null){u=t.cbFunction(s)}return u},setConfigurableItem:function(t,v){if(!p.isInitialized()){return}var s=false,u=p._bridgeCallback("setConfigurableItem");if(u!==null){s=u.cbFunction(t,v)}return s},addAdditionalHttpHeader:function(t,v){if(!p.isInitialized()){return}var s=false,u=p._bridgeCallback("addAdditionalHttpHeader");if(u!==null){s=u.cbFunction(t,v)}return s},logCustomEventBridge:function(u,v,t){if(!p.isInitialized()){return}var s=false,w=p._bridgeCallback("logCustomEventBridge");if(w!==null){s=w.cbFunction(u,v,t)}return s},registerBridgeCallbacks:function(v){var u=0,t=0,s=null;if(!v){return false}if(v.length===0){a={};return false}try{for(u=0,t=v.length;u<t;u+=1){s=v[u];if(typeof s==="object"&&s.cbType&&s.cbFunction){a[s.cbType]={enabled:s.enabled,cbFunction:s.cbFunction}}}}catch(w){return false}return true},redirectQueue:function(u){var x,t,s,v,w;if(!u||!u.length){return u}s=a.messageRedirect;if(s&&s.enabled){w=p.getService("serializer");for(x=0,t=u.length;x<t;x+=1){v=s.cbFunction(w.serialize(u[x]),u[x]);if(v&&typeof v==="object"){u[x]=v}else{u.splice(x,1);x-=1;t=u.length}}}return u},_hasSameOrigin:function(s){try{return s.document.location.host===document.location.host&&s.document.location.protocol===document.location.protocol}catch(t){}return false},provideRequestHeaders:function(){var t=null,s=a.addRequestHeaders;if(s&&s.enabled){t=s.cbFunction()}return t},_registerModuleEvents:(function(){var u,v=function(z,y,x){if(z==="window"){return y}if(z==="document"){return x}return z};function w(x,E,H){var G=p.getService("browserBase"),B=p.getService("browser"),F=p.utils.getDocument(H),z=p._getLocalTop(),y=p.utils.isIFrameDescendant(H),D,C,A;H=H||F;o.normalizeModuleEvents(x,E,z,F);if(y){D=G.ElementData.prototype.examineID(H).id;if(typeof D==="string"){D=D.slice(0,D.length-1);for(C in c){if(c.hasOwnProperty(C)){for(A=0;A<c[C].length;A+=1){if(x===c[C][A]){if(C.indexOf(D)!==-1){delete c[C];break}}}}}}}p.utils.forEach(E,function(I){var L=v(I.target,z,F)||F,K=v(I.delegateTarget,z,F),J="";if(I.recurseFrames!==true&&y){return}if(typeof L==="string"){if(I.delegateTarget&&p.getFlavor()==="jQuery"){J=p._buildToken4delegateTarget(I.name,L,I.delegateTarget);if(!c.hasOwnProperty(J)){c[J]=[x];c[J].target=L;c[J].delegateTarget=K;B.subscribe(I.name,L,p._publishEvent,K,J)}else{c[J].push(x)}}else{p.utils.forEach(B.queryAll(L,H),function(M){var N=u.get(M);if(!N){N=G.ElementData.prototype.examineID(M);u.set(M,N)}J=I.name+"|"+N.id+N.type;if(p.utils.indexOf(c[J],x)!==-1){return}c[J]=c[J]||[];c[J].push(x);c[J].target=M;B.subscribe(I.name,M,p._publishEvent)})}}else{J=p._buildToken4bubbleTarget(I.name,L,typeof I.target==="undefined");if(!c.hasOwnProperty(J)){c[J]=[x];B.subscribe(I.name,L,p._publishEvent)}else{if(p.utils.indexOf(c[J],x)===-1){c[J].push(x)}}}if(J!==""){if(typeof L!=="string"){c[J].target=L}}})}function t(x){var y=p.utils.getIFrameWindow(x);return(y!==null)&&p._hasSameOrigin(y)&&(y.document!==null)&&y.document.readyState==="complete"}function s(y,E,F){F=F||p._getLocalTop().document;u=u||new p.utils.WeakMap();w(y,E,F);if(y!=="performance"){var C=null,x=null,z=p.getService("browser"),D=z.queryAll("iframe, frame",F),B,A;for(B=0,A=D.length;B<A;B+=1){C=D[B];if(k(C)){continue}if(t(C)){x=p.utils.getIFrameWindow(C);p._registerModuleEvents(y,E,x.document)}(function(I,G,J){var H=null,K={moduleName:I,moduleEvents:G,hIFrame:J,_registerModuleEventsDelayed:function(){var L=null;if(!k(J)){L=p.utils.getIFrameWindow(J);if(p._hasSameOrigin(L)){p._registerModuleEvents(I,G,L.document)}}}};p.utils.addEventListener(J,"load",function(){K._registerModuleEventsDelayed()});if(p.utils.isLegacyIE&&t(J)){H=p.utils.getIFrameWindow(J);p.utils.addEventListener(H.document,"readystatechange",function(){K._registerModuleEventsDelayed()})}}(y,E,C))}}}s.clearCache=function(){if(u){u.clear();u=null}};return s}()),_buildToken4currentTarget:function(t){var u=t.nativeEvent?t.nativeEvent.currentTarget:null,s=u?this.getService("browserBase").ElementData.prototype.examineID(u):{id:t.target.id,type:t.target.idType};return t.type+"|"+s.id+s.type},_buildToken4delegateTarget:function(s,u,t){return s+"|"+u+"|"+t},_buildToken4bubbleTarget:function(t,A,z,E){var x=p._getLocalTop(),s,u=p.getService("browser"),F=function(G){var H=null;if(p._hasSameOrigin(s.parent)){p.utils.forEach(u.queryAll("iframe, frame",s.parent.document),function(I){var J=null;if(!k(I)){J=p.utils.getIFrameWindow(I);if(p._hasSameOrigin(J)&&J.document===G){H=I}}})}return H},B=p.utils.getDocument(A),D=this.getService("browserBase"),C=null,w,v=t,y;if(B){s=B.defaultView||B.parentWindow}if(A===window||A===window.window){v+="|null-2|window"}else{if(z&&s&&p._hasSameOrigin(s.parent)&&typeof B!=="undefined"&&x.document!==B){C=F(B);if(C){w=D.ElementData.prototype.examineID(C);v+="|"+w.xPath+"-2"}}else{if(E&&E!==document&&p.getFlavor()==="jQuery"){v+="|null-2|"+p.utils.getTagName(A)+"|"+p.utils.getTagName(E)}else{v+="|null-2|document"}}}return v},_reinitConfig:function(){p._updateModules()},_publishEvent:function(s){var t=null,w=null,y=(s.delegateTarget&&s.data)?s.data:p._buildToken4currentTarget(s),z=null,A,B,C,v=null,D=false,E=false,x=p.getCoreConfig(),u=p.getService("browser"),F=s.delegateTarget||null;if(m){clearTimeout(m)}m=setTimeout(h,p.utils.getValue(x,"inactivityTimeout",600000));if((s.type==="load"||s.type==="pageshow")&&!s.nativeEvent.customLoad){return}if(p.utils.isIE){if(s.type==="click"){l=s.target.element}if(s.type==="beforeunload"){D=false;p.utils.forEach(x.ieExcludedLinks,function(H){var I,G,J=u.queryAll(H);for(I=0,G=J?J.length:0;I<G;I+=1){if(typeof J[I]!==undefined&&J[I]===l){D=true;return}}});if(D){return}}}if(o.isUnload(s)){e="unloading"}if(s.type==="change"&&p.utils.isLegacyIE&&p.getFlavor()==="w3c"&&(s.target.element.type==="checkbox"||s.target.element.type==="radio")){return}if(s.type==="propertychange"){if(s.nativeEvent.propertyName==="checked"&&(s.target.element.type==="checkbox"||(s.target.element.type==="radio"&&s.target.element.checked))){s.type="change";s.target.type="INPUT"}else{return}}if(!c.hasOwnProperty(y)){if(s.hasOwnProperty("nativeEvent")){C=s.nativeEvent.currentTarget||s.nativeEvent.target}y=p._buildToken4bubbleTarget(s.type,C,true,F)}if(c.hasOwnProperty(y)){z=c[y];for(A=0,B=z.length;A<B;A+=1){t=z[A];w=p.getModule(t);v=p.utils.mixin({},s);if(w&&p.isStarted(t)&&typeof w.onevent==="function"){E=o.canPublish(t,v);if(E){w.onevent(v)}}}}if(v&&v.type==="unload"&&E){p.destroy()}},_getLocalTop:function(){return window.window},addModule:function(s,t){r[s]={creator:t,instance:null,context:null,messages:[]};if(this.isInitialized()){this.start(s)}},getModule:function(s){if(r[s]&&r[s].instance){return r[s].instance}return null},removeModule:function(s){this.stop(s);delete r[s]},isStarted:function(s){return r.hasOwnProperty(s)&&r[s].instance!==null},start:function(t){var u=r[t],s=null;if(u&&u.instance===null){u.context=new TLT.ModuleContext(t,this);s=u.instance=u.creator(u.context);if(typeof s.init==="function"){s.init()}}},startAll:function(){var s=null;for(s in r){if(r.hasOwnProperty(s)){this.start(s)}}},stop:function(t){var u=r[t],s=null;if(u&&u.instance!==null){s=u.instance;if(typeof s.destroy==="function"){s.destroy()}u.instance=u.context=null}},stopAll:function(){var s=null;for(s in r){if(r.hasOwnProperty(s)){this.stop(s)}}},addService:function(t,s){b[t]={creator:s,instance:null}},getService:function(s){if(b.hasOwnProperty(s)){if(!b[s].instance){try{b[s].instance=b[s].creator(this);if(typeof b[s].instance.init==="function"){b[s].instance.init()}}catch(t){return null}if(typeof b[s].instance.getServiceName!=="function"){b[s].instance.getServiceName=function(){return s}}}return b[s].instance}return null},removeService:function(s){delete b[s]},broadcast:function(v){var u=0,s=0,w=null,t=null;if(v&&typeof v==="object"){for(w in r){if(r.hasOwnProperty(w)){t=r[w];if(p.utils.indexOf(t.messages,v.type)>-1){if(typeof t.instance.onmessage==="function"){t.instance.onmessage(v)}}}}}},listen:function(s,u){var t=null;if(this.isStarted(s)){t=r[s];if(p.utils.indexOf(t.messages,u)===-1){t.messages.push(u)}}},fail:function(u,t,s){u="UIC FAILED. "+u;try{p.destroy(!!s)}finally{p.utils.clog(u);throw new p.UICError(u,t)}},UICError:(function(){function s(t,u){this.message=t;this.code=u}s.prototype=new Error();s.prototype.name="UICError";s.prototype.constructor=s;return s}()),getFlavor:function(){return"w3c"}};h=function(){p.logExceptionEvent("Inactivity timeout.");p.destroy()};g=function(u,z){var y,w,s,t,v;if(d){p.utils.clog("TLT.init() called more than once. Ignoring.");return}if(TLT&&TLT.replay){return}y=p.getService("config");y.updateConfig(u);if(!p._updateModules()){if(e!=="destroyed"){p.destroy()}return}if(y.subscribe){y.subscribe("configupdated",p._reinitConfig)}d=true;e="loaded";w={type:"load",target:window.window,srcElement:window.window,currentTarget:window.window,bubbles:true,cancelBubble:false,cancelable:true,timeStamp:+new Date(),customLoad:true};t=p.getService("browserBase");s=new t.WebEvent(w);p._publishEvent(s);if(typeof i==="function"){try{i("initialized")}catch(x){}}};(function(){var t=null,u,s;for(t in f){if(f.hasOwnProperty(t)){for(u=0,s=f[t].length;u<s;u+=1){(function(w,v){p[v]=function(){var x=this.getService(w);if(x){return x[v].apply(x,arguments)}}}(t,f[t][u]))}}}}());return p}());(function(){var e=window.navigator.userAgent.toLowerCase(),d=(e.indexOf("msie")!==-1),c=(function(){var h=!!window.performance;return(d&&(!h||document.documentMode<9))}()),f=(e.indexOf("android")!==-1),a=/(ipad|iphone|ipod)/.test(e),g=1,b={isIE:d,isLegacyIE:c,isAndroid:f,isiOS:a,isUndefOrNull:function(h){return typeof h==="undefined"||h===null},getSerialNumber:function(){var h;h=g;g+=1;return h},getValue:function(n,m,j){var l,h,k;j=j||null;if(!n||typeof n!=="object"||typeof m!=="string"){return j}k=m.split(".");for(l=0,h=k.length;l<h;l+=1){if(this.isUndefOrNull(n)||typeof n[k[l]]==="undefined"){return j}n=n[k[l]]}return n},indexOf:function(l,k){var j,h;if(l&&l instanceof Array){for(j=0,h=l.length;j<h;j+=1){if(l[j]===k){return j}}}return -1},forEach:function(m,l,k){var j,h;if(!m||!m.length||!l||!l.call){return}for(j=0,h=m.length;j<h;j+=1){l.call(k,m[j],j,m)}},some:function(m,l){var j,h,k=false;for(j=0,h=m.length;j<h;j+=1){k=l(m[j],j,m);if(k){return k}}return k},convertToArray:function(k){var l=0,j=k.length,h=[];while(l<j){h.push(k[l]);l+=1}return h},mixin:function(l){var k,j,i,h;for(i=1,h=arguments.length;i<h;i+=1){j=arguments[i];for(k in j){if(Object.prototype.hasOwnProperty.call(j,k)){l[k]=j[k]}}}return l},extend:function(h,i,j){var k="";for(k in j){if(Object.prototype.hasOwnProperty.call(j,k)){if(h&&Object.prototype.toString.call(j[k])==="[object Object]"){if(typeof i[k]==="undefined"){i[k]={}}b.extend(h,i[k],j[k])}else{i[k]=j[k]}}}return i},clone:function(i){var j,h;if(null===i||"object"!==typeof i){return i}if(i instanceof Object){j=(Object.prototype.toString.call(i)==="[object Array]")?[]:{};for(h in i){if(Object.prototype.hasOwnProperty.call(i,h)){j[h]=b.clone(i[h])}}return j}},createObject:(function(){var h=null,i=null;if(typeof Object.create==="function"){h=Object.create}else{i=function(){};h=function(j){if(typeof j!=="object"&&typeof j!=="function"){throw new TypeError("Object prototype need to be an object!")}i.prototype=j;return new i()}}return h}()),access:function(n,l){var m=l||window,j,k,h;if(typeof n!=="string"||(typeof m!=="object"&&m!==null)){return}j=n.split(".");for(k=0,h=j.length;k<h;k+=1){if(k===0&&j[k]==="window"){continue}if(!Object.prototype.hasOwnProperty.call(m,j[k])){return}m=m[j[k]];if(k<(h-1)&&!(m instanceof Object)){return}}return m},isNumeric:function(h){return !isNaN(h+1-1)},isUpperCase:function(h){return h===h.toUpperCase()&&h!==h.toLowerCase()},isLowerCase:function(h){return h===h.toLowerCase()&&h!==h.toUpperCase()},getDocument:function(h){if(h.nodeType!==9){return(!b.isUndefOrNull(h.ownerDocument))?(h.ownerDocument):(h.document)}return h},getWindow:function(i){if(i.self!==i){var h=b.getDocument(i);return(!b.isUndefOrNull(h.defaultView))?(h.defaultView):(h.parentWindow)}return i},getIFrameWindow:function(j){var h=null;if(!j){return h}try{h=j.contentWindow||(j.contentDocument?j.contentDocument.parentWindow:null)}catch(i){}return h},getTagName:function(h){if(h===document){return"document"}if(h===window||h===window.window){return"window"}if(typeof h==="string"){return h.toLowerCase()}if(typeof h==="object"&&!b.isUndefOrNull(h)&&typeof h.tagName==="string"){return h.tagName.toLowerCase()}return""},isIFrameDescendant:function(h){return b.getWindow(h)!=TLT._getLocalTop()},getOrientationMode:function(h){var i="INVALID";if(typeof h!=="number"){return i}switch(h){case 0:case 180:case 360:i="PORTRAIT";break;case 90:case -90:case 270:i="LANDSCAPE";break;default:i="UNKNOWN";break}return i},clog:(function(h){return function(){}}(window)),trim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/^\s+|\s+$/g,"")},ltrim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/^\s+/,"")},rtrim:function(h){if(!h||!h.toString){return h}return h.toString().replace(/\s+$/,"")},getCookieValue:function(o,q){var l,m,k,p,j=null,h;try{q=q||document.cookie;if(!o||!o.toString){return null}o+="=";h=o.length;p=q.split(";");for(l=0,m=p.length;l<m;l+=1){k=p[l];k=b.ltrim(k);if(k.indexOf(o)===0){j=k.substring(h,k.length);break}}}catch(n){j=null}return j},getQueryStringValue:function(n,q,h){var m,l,r,k=null,o;try{h=h||window.location.search;r=h.length;if(!n||!n.toString||!r){return null}q=q||"&";h=q+h.substring(1);n=q+n+"=";m=h.indexOf(n);if(m!==-1){o=m+n.length;l=h.indexOf(q,o);if(l===-1){l=r}k=decodeURIComponent(h.substring(o,l))}}catch(p){}return k},addEventListener:(function(){if(window.addEventListener){return function(i,h,j){i.addEventListener(h,j,false)}}return function(i,h,j){i.attachEvent("on"+h,j)}}()),matchTarget:function(t,o){var m,l,s=-1,q,h,k,r,n,p;if(!t||!o){return s}if(!this.browserService||!this.browserBaseService){this.browserService=TLT.getService("browser");this.browserBaseService=TLT.getService("browserBase")}for(m=0,n=t.length;m<n&&s===-1;m+=1){p=t[m];if(typeof p==="string"){q=this.browserService.queryAll(p);for(l=0,h=q?q.length:0;l<h;l+=1){if(q[l]){k=this.browserBaseService.ElementData.prototype.examineID(q[l]);if(k.type===o.idType&&k.id===o.id){s=m;break}}}}else{if(p.id&&p.idType&&o.idType.toString()===p.idType.toString()){switch(typeof p.id){case"string":if(p.id===o.id){s=m}break;case"object":r=new RegExp(p.id.regex,p.id.flags);if(r.test(o.id)){s=m}break}}}}return s},WeakMap:(function(){function h(m,l){var k,j;m=m||[];for(k=0,j=m.length;k<j;k+=1){if(m[k][0]===l){return k}}return -1}return function(){var i=[];this.set=function(k,l){var j=h(i,k);i[j>-1?j:i.length]=[k,l]};this.get=function(k){var j=i[h(i,k)];return(j?j[1]:undefined)};this.clear=function(){i=[]};this.has=function(j){return(h(i,j)>=0)};this.remove=function(k){var j=h(i,k);if(j>=0){i.splice(j,1)}};this["delete"]=this.remove}}())};if(typeof TLT==="undefined"||!TLT){window.TLT={}}TLT.utils=b}());(function(){TLT.EventTarget=function(){this._handlers={}};TLT.EventTarget.prototype={constructor:TLT.EventTarget,publish:function(c,f){var d=0,a=0,b=this._handlers[c],e={type:c,data:f};if(typeof b!=="undefined"){for(a=b.length;d<a;d+=1){b[d](e)}}},subscribe:function(a,b){if(!this._handlers.hasOwnProperty(a)){this._handlers[a]=[]}this._handlers[a].push(b)},unsubscribe:function(c,e){var d=0,a=0,b=this._handlers[c];if(b){for(a=b.length;d<a;d+=1){if(b[d]===e){b.splice(d,1);return}}}}}}());TLT.ModuleContext=(function(){var a=["broadcast","getConfig:getModuleConfig","listen","post","getXPathFromNode","performDOMCapture","getStartTime"];return function(f,d){var h={},g=0,b=a.length,j=null,e=null,c=null;for(g=0;g<b;g+=1){j=a[g].split(":");if(j.length>1){c=j[0];e=j[1]}else{c=j[0];e=j[0]}h[c]=(function(i){return function(){var k=d.utils.convertToArray(arguments);k.unshift(f);return d[i].apply(d,k)}}(e))}h.utils=d.utils;return h}}());TLT.addService("config",function(a){function d(f,e){a.utils.extend(true,f,e);c.publish("configupdated",c.getConfig())}var b={core:{},modules:{},services:{}},c=a.utils.extend(false,a.utils.createObject(new TLT.EventTarget()),{getConfig:function(){return b},updateConfig:function(e){d(b,e)},getCoreConfig:function(){return b.core},updateCoreConfig:function(e){d(b.core,e)},getServiceConfig:function(e){return b.services[e]||null},updateServiceConfig:function(f,e){if(typeof b.services[f]==="undefined"){b.services[f]={}}d(b.services[f],e)},getModuleConfig:function(e){return b.modules[e]||null},updateModuleConfig:function(f,e){if(typeof b.modules[f]==="undefined"){b.modules[f]={}}d(b.modules[f],e)},destroy:function(){b={core:{},modules:{},services:{}}}});return c});TLT.addService("queue",function(q){var B=null,f=q.getService("ajax"),k=q.getService("browser"),l=q.getService("encoder"),i=q.getService("serializer"),y=q.getService("config"),g=q.getService("message"),o=null,z={},c=true,n=false,j=(function(){var G={};function J(K){return typeof G[K]!=="undefined"}function C(K,L){if(!J(K)){G[K]={data:[],queueId:K,url:L.url,threshold:L.threshold,serializer:L.serializer,encoder:L.encoder,crossDomainEnabled:!!L.crossDomainEnabled,crossDomainIFrame:L.crossDomainIFrame}}return G[K]}function E(K){if(J(K)){delete G[K]}}function H(K){if(J(K)){return G[K]}return null}function F(L){var K=H(L);if(K!==null){K.data=[]}}function I(K){var L=null;if(J(K)){L=H(K).data;F(K)}return L}function D(N,O){var L=null,K=null,P=window.tlBridge,M=window.iOSJSONShuttle;if((typeof P!=="undefined")&&(typeof P.addMessage==="function")){K=i.serialize(O);P.addMessage(K)}else{if((typeof M!=="undefined")&&(typeof M==="function")){K=i.serialize(O);M(K)}else{if(J(N)){L=H(N);L.data.push(O);L.data=q.redirectQueue(L.data);return L.data.length}}}return 0}return{exists:J,add:C,remove:E,get:H,clear:F,flush:I,push:D}}());function a(){}function m(){return window.location.pathname}function b(E,I,F,H){var C=j.get(E),G={name:I,value:F},D=null;if(typeof I!=="string"||typeof F!=="string"){return}if(!C.headers){C.headers={once:[],always:[]}}D=!!H?C.headers.always:C.headers.once;D.push(G)}function A(E,H){var G=0,D=0,C=j.get(E),I=C.headers,F=null;H=H||{};function J(L,N){var M=0,K=0,O=null;for(M=0,K=L.length;M<K;M+=1){O=L[M];N[O.name]=O.value}}if(I){F=[I.always,I.once];for(G=0,D=F.length;G<D;G+=1){J(F[G],H)}}return H}function s(D){var C=null,E=null;if(!j.exists(D)){throw new Error("Queue: "+D+" does not exist!")}C=j.get(D);E=C?C.headers:null;if(E){E.once=[]}}function x(){var D=0,C,F,E=q.provideRequestHeaders();if(E&&E.length){for(D=0,C=E.length;D<C;D+=1){F=E[D];b("DEFAULT",F.name,F.value,F.recurring)}}return D}function u(D,M){var H=j.flush(D),J=H!==null?H.length:0,I=j.get(D),E={"Content-Type":"application/json","X-Tealeaf":"device (UIC) Lib/4.0.0.1607","X-TealeafType":"GUI","X-TeaLeaf-Page-Url":m()},N=I.serializer||"json",C=I.encoder,F,G,L=null;if(!J){return}H=g.wrapMessages(H);if(N){H=i.serialize(H,N)}if(C){G=l.encode(H,C);if(G&&G.data&&!G.error){H=G.data;E["Content-Encoding"]=G.encoding}}x();A(D,E);if(I.crossDomainEnabled){L=q.utils.getIFrameWindow(I.crossDomainIFrame);if(!L){return}F={request:{url:I.url,async:!M,headers:E,data:H}};if(!q.utils.isIE&&typeof window.postMessage==="function"){L.postMessage(F,I.crossDomainIFrame.src)}else{try{L.sendMessage(F)}catch(K){return}}}else{f.sendRequest({oncomplete:a,url:I.url,async:!M,headers:E,data:H})}s(D)}function e(F){var C=null,E=B.queues,D=0;for(D=0;D<E.length;D+=1){C=E[D];u(C.qid,F)}return true}function h(C,E){var D=j.push(C,g.createMessage(E));if(D>=j.get(C).threshold&&c&&q.getState()!=="unloading"){u(C)}}function d(E){var D=null,H=B.queues,G="",F=0,C=0;for(F=0;F<H.length;F+=1){D=H[F];if(D&&D.modules){for(C=0;C<D.modules.length;C+=1){G=D.modules[C];if(G===E){return D.qid}}}}return o.qid}function v(E,C){z[E]=window.setTimeout(function D(){u(E);z[E]=window.setTimeout(D,C)},C)}function t(){var C=0;for(C in z){if(z.hasOwnProperty(C)){window.clearTimeout(z[C]);delete z[C]}}z={}}function r(C){}function p(C){B=C;q.utils.forEach(B.queues,function(D,E){var F=null;if(D.qid==="DEFAULT"){o=D}if(D.crossDomainEnabled){F=k.query(D.crossDomainFrameSelector);if(!F){q.fail("Cross domain iframe not found")}}j.add(D.qid,{url:D.endpoint,threshold:D.maxEvents,serializer:D.serializer,encoder:D.encoder,timerInterval:D.timerInterval||0,crossDomainEnabled:D.crossDomainEnabled||false,crossDomainIFrame:F});if(typeof D.timerInterval!=="undefined"&&D.timerInterval>0){v(D.qid,D.timerInterval)}});y.subscribe("configupdated",r);n=true}function w(){if(c){e(!B.asyncReqOnUnload)}y.unsubscribe("configupdated",r);t();B=null;o=null;n=false}return{init:function(){if(!n){p(y.getServiceConfig("queue")||{})}else{}},destroy:function(){w()},_getQueue:function(C){return j.get(C).data},setAutoFlush:function(C){if(C===true){c=true}else{c=false}},flush:function(C){if(!j.exists(C)){throw new Error("Queue: "+C+" does not exist!")}u(C)},flushAll:function(C){return e(!!C)},post:function(D,E,C){C=C||d(D);if(!j.exists(C)){throw new Error("Queue: "+C+" does not exist!")}h(C,E)}}});TLT.addService("browserBase",function(w){var z={OPTGROUP:true,OPTION:true,NOBR:true},f={},A=w.getService("config"),d=null,B,g,a,e,r=false;function j(){A=w.getService("config");d=w.getService("serializer");B=w.getService("config").getServiceConfig("browser")||{};g=B.hasOwnProperty("blacklist")?B.blacklist:[];a=B.hasOwnProperty("customid")?B.customid:[]}function o(){j();A.subscribe("configupdated",j);d=w.getService("serializer");r=true}function y(){A.unsubscribe("configupdated",j);r=false}function v(H){var F,E,G;if(!H||!H.id||typeof H.id!=="string"){return false}for(F=0,E=g.length;F<E;F+=1){if(typeof g[F]==="string"){if(H.id===g[F]){return false}}else{if(typeof g[F]==="object"){G=new RegExp(g[F].regex,g[F].flags);if(G.test(H.id)){return false}}}}return true}function q(G,H){var E={type:null,subType:null},F;if(!G){return E}F=G.type;switch(F){case"focusin":F="focus";break;case"focusout":F="blur";break;default:break}E.type=F;return E}function t(F){var E={type:null,subType:null};if(!F){return E}E.type=F.tagName;E.subType=F.type||null;return E}function c(E,G,F){var K={HTML_ID:"-1",XPATH_ID:"-2",ATTRIBUTE_ID:"-3"},J,H=null,I;if(!E||!G){return H}J=F||window.document;G=G.toString();if(G===K.HTML_ID){if(J.getElementById){H=J.getElementById(E)}else{if(J.querySelector){H=J.querySelector("#"+E)}}}else{if(G===K.ATTRIBUTE_ID){I=E.split("=");if(J.querySelector){H=J.querySelector("["+I[0]+'="'+I[1]+'"]')}}else{if(G===K.XPATH_ID){H=f.xpath(E,J)}}}return H}e=(function(){var E={NOBR:true,P:true};function F(I){var L,J,K=false,O=null,G=null,P=null,N=[],M=true,H=w._getLocalTop();while(M){M=false;if(!w.utils.isUndefOrNull(I)){if(!w.utils.isUndefOrNull(I.tagName)){if(E.hasOwnProperty(I.tagName)){I=I.parentNode}}for(K=v(I);I!==document&&!K;K=v(I)){P=I.parentNode;if(!P){G=w.utils.getWindow(I);P=(G!==H)?G.frameElement:document}O=P.firstChild;if(typeof O==="undefined"){return N}for(J=0;O;O=O.nextSibling){if(O.nodeType===1&&O.tagName===I.tagName){if(O===I){N[N.length]=[I.tagName,J];break}J+=1}}I=P}if(K){N[N.length]=[I.id];if(w.utils.isIFrameDescendant(I)){M=true;I=w.utils.getWindow(I).frameElement}}}}return N}return function(I){var G=F(I),J=[],H=G.length;if(H<1){return"null"}while(H){H-=1;if(G[H].length>1){J[J.length]='["'+G[H][0]+'",'+G[H][1]+"]"}else{J[J.length]="["+d.serialize(G[H][0],"json")+"]"}}return("["+J.join(",")+"]")}}());function p(F){var G={left:-1,top:-1},E;F=F||document;E=F.documentElement||F.body.parentNode||F.body;G.left=(typeof window.pageXOffset==="number")?window.pageXOffset:E.scrollLeft;G.top=(typeof window.pageYOffset==="number")?window.pageYOffset:E.scrollTop;return G}function s(E){return E&&typeof E.originalEvent!=="undefined"&&typeof E.isDefaultPrevented!=="undefined"&&!E.isSimulated}function m(E){if(!E){return null}if(E.type&&E.type.indexOf("touch")===0){if(s(E)){E=E.originalEvent}if(E.type==="touchstart"){E=E.touches[E.touches.length-1]}else{if(E.type==="touchend"){E=E.changedTouches[0]}}}return E}function l(H){var K=H||window.event,J=document.documentElement,E=document.body,I=false,G=null,F=0;if(s(K)){K=K.originalEvent}if(typeof H==="undefined"||typeof K.target==="undefined"){K.target=K.srcElement||window.window;K.timeStamp=Number(new Date());if(K.pageX===null||typeof K.pageX==="undefined"){K.pageX=K.clientX+((J&&J.scrollLeft)||(E&&E.scrollLeft)||0)-((J&&J.clientLeft)||(E&&E.clientLeft)||0);K.pageY=K.clientY+((J&&J.scrollTop)||(E&&E.scrollTop)||0)-((J&&J.clientTop)||(E&&E.clientTop)||0)}K.preventDefault=function(){this.returnValue=false};K.stopPropagation=function(){this.cancelBubble=true}}if(window.chrome&&K.path!==undefined&&K.type==="click"){if(K.path.length===undefined){return K}for(F=0;F<K.path.length;F++){if(K.path[F].tagName==="BUTTON"){I=true;G=K.path[F];F=K.path.length}}if(I){return{originalEvent:K,target:G,srcElement:G,type:K.type,pageX:document.body.scrollLeft+G.getBoundingClientRect().left,pageY:document.body.scrollTop+G.getBoundingClientRect().top}}}return K}function u(F){var E=null;if(!F){return null}if(F.srcElement){E=F.srcElement}else{E=F.target;if(!E){E=F.explicitOriginalTarget}if(!E){E=F.originalTarget}}if(!E&&F.type.indexOf("touch")===0){E=m(F).target}while(E&&z[E.tagName]){E=E.parentNode}if(!E&&F.srcElement===null){E=window.window}return E}function i(F){var I=0,H=0,G=document.documentElement,E=document.body;F=m(F);if(F){if(F.pageX||F.pageY){I=F.pageX;H=F.pageY}else{if(F.clientX||F.clientY){I=F.clientX+(G?G.scrollLeft:(E?E.scrollLeft:0))-(G?G.clientLeft:(E?E.clientLeft:0));H=F.clientY+(G?G.scrollTop:(E?E.scrollTop:0))-(G?G.clientTop:(E?E.clientTop:0))}}}return{x:I,y:H}}f.xpath=function(L,N){var J=null,E,K=null,H,G,F,I,M;if(!L){return null}J=d.parse(L);N=N||document;E=N;if(!J){return null}for(H=0,I=J.length;H<I&&E;H+=1){K=J[H];if(K.length===1){if(N.getElementById){E=N.getElementById(K[0])}else{if(N.querySelector){E=N.querySelector("#"+K[0])}else{E=null}}}else{for(G=0,F=-1,M=E.childNodes.length;G<M;G+=1){if(E.childNodes[G].nodeType===1&&E.childNodes[G].tagName.toUpperCase()===K[0]){F+=1;if(F===K[1]){E=E.childNodes[G];break}}}if(F===-1){return null}}}return(E===N||!E)?null:E};function C(E,F){this.x=E||0;this.y=F||0}function x(F,E){this.width=F||0;this.height=E||0}function b(F,G){var I,E,H;G=u(F);I=this.examineID(G);E=t(G);H=this.examinePosition(F,G);this.element=G;this.id=I.id;this.idType=I.type;this.type=E.type;this.subType=E.subType;this.state=this.examineState(G);this.position=new C(H.x,H.y);this.size=new x(H.width,H.height);this.xPath=I.xPath;this.name=I.name}b.HTML_ID=-1;b.XPATH_ID=-2;b.ATTRIBUTE_ID=-3;b.prototype.examineID=function(K){var G,M,N,E,F,I=a.length,H;try{N=e(K)}catch(J){}F=K.name;try{if(!w.utils.isIFrameDescendant(K)){if(v(K)){G=K.id;M=b.HTML_ID}else{if(a.length&&K.attributes){while(I){I-=1;H=K.attributes[a[I]];if(typeof H!=="undefined"){G=a[I]+"="+(H.value||H);M=b.ATTRIBUTE_ID}}}}}}catch(L){}if(!G){G=N;M=b.XPATH_ID}return{id:G,type:M,xPath:N,name:F}};b.prototype.examineState=function(K){var E={a:["innerText","href"],input:{range:["maxValue:max","value"],checkbox:["value","checked"],radio:["value","checked"],image:["src"]},select:["value"],button:["value","innerText"],textarea:["value"]},F=typeof K.tagName!=="undefined"?K.tagName.toLowerCase():"",L=E[F]||null,G=null,N=null,H=0,J=0,I=null,M="";if(L!==null){if(Object.prototype.toString.call(L)==="[object Object]"){L=L[K.type]||["value"]}N={};for(M in L){if(L.hasOwnProperty(M)){if(L[M].indexOf(":")!==-1){I=L[M].split(":");N[I[0]]=K[I[1]]}else{if(L[M]==="innerText"){N[L[M]]=w.utils.trim(K.innerText||K.textContent)}else{N[L[M]]=K[L[M]]}}}}}if(F==="select"&&K.options&&!isNaN(K.selectedIndex)){N.index=K.selectedIndex;if(N.index>=0&&N.index<K.options.length){G=K.options[K.selectedIndex];N.value=G.getAttribute("value")||G.getAttribute("label")||G.text||G.innerText;N.text=G.text||G.innerText}}return N};function n(){var F=1,G,I,E;if(document.body.getBoundingClientRect){try{G=document.body.getBoundingClientRect()}catch(H){w.utils.clog("getBoundingClientRect failed.",H);return F}I=G.right-G.left;E=document.body.offsetWidth;F=Math.round((I/E)*100)/100}return F}function h(F){var H,E,G,J;if(!F||!F.getBoundingClientRect){return{x:0,y:0,width:0,height:0}}try{H=F.getBoundingClientRect();J=p(document)}catch(I){w.utils.clog("getBoundingClientRect failed.",I);return{x:0,y:0,width:0,height:0}}E={x:H.left+J.left,y:H.top+J.top,width:H.right-H.left,height:H.bottom-H.top};if(w.utils.isIE){E.x-=document.documentElement.clientLeft;E.y-=document.documentElement.clientTop;G=n();if(G!==1){E.x=Math.round(E.x/G);E.y=Math.round(E.y/G);E.width=Math.round(E.width/G);E.height=Math.round(E.height/G)}}return E}b.prototype.examinePosition=function(F,G){var H=i(F),E=h(G);E.x=(H.x||H.y)?Math.round(Math.abs(H.x-E.x)):E.width/2;E.y=(H.x||H.y)?Math.round(Math.abs(H.y-E.y)):E.height/2;return E};function k(F){var G,E;this.data=F.data||null;this.delegateTarget=F.delegateTarget||null;if(F.gesture||(F.originalEvent&&F.originalEvent.gesture)){this.gesture=F.gesture||F.originalEvent.gesture}F=l(F);G=i(F);this.custom=false;this.nativeEvent=this.custom===true?null:F;this.position=new C(G.x,G.y);this.target=new b(F,F.target);this.timestamp=(new Date()).getTime();E=q(F,this.target);this.type=E.type;this.subType=E.subType}function D(E){w._publishEvent(new k(E))}return{init:function(){if(!r){o()}else{}},destroy:function(){y()},WebEvent:k,ElementData:b,processDOMEvent:D,getXPathFromNode:function(E,F){return e(F)},getNodeFromID:c,queryDom:f}});TLT.addService("browser",function(core){var configService=core.getService("config"),browserBaseService=core.getService("browserBase"),ajaxService=core.getService("ajax"),addEventListener=null,removeEventListener=null,serviceConfig=configService.getServiceConfig("browser")||{},useCapture=(serviceConfig.useCapture===true),isInitialized=false,errorCodes={NO_QUERY_SELECTOR:"NOQUERYSELECTOR"},wrapWebEvent=function(handler){return function(event){handler(new browserBaseService.WebEvent(event))}},loadScript=function(url){var fjs=document.getElementsByTagName("script")[0],js=document.createElement("script");js.src=url;fjs.parentNode.insertBefore(js,fjs)},queryDom={list2Array:function(nodeList){var len=nodeList.length,result=[],i;if(typeof nodeList.length==="undefined"){return[nodeList]}for(i=0;i<len;i+=1){result[i]=nodeList[i]}return result},find:function(query,scope,type){type=type||"css";return this.list2Array(this[type](query,scope))},css:function(query,scope){var self=this,message=null,bodyEl=document.getElementsByTagName("body")[0],bConfig=configService.getServiceConfig("browser")||{},sizzleURL=bConfig.sizzleURL||null,jQuery=bConfig.hasOwnProperty("jQueryObject")?core.utils.access(bConfig.jQueryObject):window.jQuery,sizzle=bConfig.hasOwnProperty("sizzleObject")?core.utils.access(bConfig.sizzleObject):window.Sizzle;if(typeof document.querySelectorAll==="undefined"){self.css=function(query,scope){scope=scope||document;return self.Sizzle(query,scope)};if(typeof self.Sizzle==="undefined"){if(sizzleURL){message={type:"GET",url:sizzleURL,async:false,oncomplete:function(result){function define(definition){self.Sizzle=definition()}define.amd=true;eval(result.responseText)}};ajaxService.sendRequest(message)}else{try{if(bodyEl===sizzle("html > body",document)[0]){self.Sizzle=sizzle}}catch(e){try{if(bodyEl===jQuery(document).find("html > body").get()[0]){self.Sizzle=function(query,scope){return jQuery(scope).find(query).get()}}}catch(ex){core.fail("Sizzle was not found",errorCodes.NO_QUERY_SELECTOR)}}}}}else{self.css=function(query,scope){scope=scope||document;return scope.querySelectorAll(query)}}return self.css(query,scope)}},handlerMappings=(function(){var data=new core.utils.WeakMap();return{add:function(originalHandler){var handlers=data.get(originalHandler)||[wrapWebEvent(originalHandler),0];handlers[1]+=1;data.set(originalHandler,handlers);return handlers[0]},find:function(originalHandler){var handlers=data.get(originalHandler);return handlers?handlers[0]:null},remove:function(originalHandler){var handlers=data.get(originalHandler);if(handlers){handlers[1]-=1;if(handlers[1]<=0){data.remove(originalHandler)}}}}}());function initBrowserServiceW3C(){queryDom.xpath=browserBaseService.queryDom.xpath;if(typeof document.addEventListener==="function"){addEventListener=function(target,eventName,handler){target.addEventListener(eventName,handler,useCapture)};removeEventListener=function(target,eventName,handler){target.removeEventListener(eventName,handler,useCapture)}}else{if(typeof document.attachEvent!=="undefined"){addEventListener=function(target,eventName,handler){target.attachEvent("on"+eventName,handler)};removeEventListener=function(target,eventName,handler){target.detachEvent("on"+eventName,handler)}}else{throw new Error("Unsupported browser")}}isInitialized=true}return{init:function(){if(!isInitialized){initBrowserServiceW3C()}else{}},destroy:function(){isInitialized=false},getServiceName:function(){return"W3C"},query:function(query,scope,type){try{return queryDom.find(query,scope,type)[0]||null}catch(err){return[]}},queryAll:function(query,scope,type){try{return queryDom.find(query,scope,type)}catch(err){return[]}},loadScript:function(url){loadScript(url)},subscribe:function(eventName,target,handler){var wrappedHandler=handlerMappings.add(handler);addEventListener(target,eventName,wrappedHandler)},unsubscribe:function(eventName,target,handler){var wrappedHandler=handlerMappings.find(handler);if(wrappedHandler){try{removeEventListener(target,eventName,wrappedHandler)}catch(e){}handlerMappings.remove(handler)}}}});TLT.addService("ajax",function(b){var a,e=function(j){var i="",h=[];for(i in j){if(j.hasOwnProperty(i)){h.push([i,j[i]])}}return h},d=false;function c(k){k=k.split("\n");var m={},j=0,h=k.length,l=null;for(j=0;j<h;j+=1){l=k[j].split(": ");m[l[0]]=l[1]}return m}function g(q){var p=a(),j=[["X-Requested-With","XMLHttpRequest"]],o=0,k=typeof q.async!=="boolean"?true:q.async,m="",n=null,l,h;if(q.headers){j=j.concat(e(q.headers))}if(q.contentType){j.push(["Content-Type",q.contentType])}p.open(q.type.toUpperCase(),q.url,k);for(l=0,h=j.length;l<h;l+=1){m=j[l];if(m[0]&&m[1]){p.setRequestHeader(m[0],m[1])}}p.onreadystatechange=n=function(){if(p.readyState===4){p.onreadystatechange=n=function(){};if(q.timeout){window.clearTimeout(o)}q.oncomplete({headers:c(p.getAllResponseHeaders()),responseText:(p.responseText||null),statusCode:p.status,success:(p.status===200)});p=null}};p.send(q.data||null);n();if(q.timeout){o=window.setTimeout(function(){if(!p){return}p.onreadystatechange=function(){};if(p.readyState!==4){p.abort()}p=null},q.timeout)}}function f(){if(typeof window.XMLHttpRequest!=="undefined"){a=function(){return new XMLHttpRequest()}}else{a=function(){return new ActiveXObject("Microsoft.XMLHTTP")}}d=true}return{init:function(){if(!d){f()}},destroy:function(){d=false},sendRequest:function(h){h.type=h.type||"POST";g(h)}}});TLT.addService("domCapture",function(o){var s=o.getService("config"),k,m=false,b=1,j=function(){},r=function(){},g=function(){};function d(t){s.subscribe("configupdated",g);k=o.getService("message");m=true}function f(){s.unsubscribe("configupdated",g);m=false}function a(){var t;t="tlt-"+o.utils.getSerialNumber();return t}function l(w,v){var u,t;if(!w||!w.getElementsByTagName||!v){return}t=w.getElementsByTagName(v);if(t&&t.length){for(u=t.length-1;u>=0;u-=1){t[u].parentNode.removeChild(t[u])}}return w}function h(v){var u,t=null;if(!v||!v.doctype){return null}u=v.doctype;if(u){t="<!DOCTYPE "+u.name+(u.publicId?' PUBLIC "'+u.publicId+'"':"")+(!u.publicId&&u.systemId?" SYSTEM":"")+(u.systemId?' "'+u.systemId+'"':"")+">"}return t}function i(A){var y,w,B,t,z,u,x,v;if(!A){return}t=A.getElementsByTagName("input");if(t){for(y=0,z=t.length;y<z;y+=1){B=t[y];switch(B.type){case"checkbox":case"radio":if(B.checked){B.setAttribute("checked","checked")}else{B.removeAttribute("checked")}break;default:B.setAttribute("value",B.value);break}}}}function n(t,y){var u,A,z,B,w,v,x;if(!t||!t.getElementsByTagName||!y||!y.getElementsByTagName){return}A=t.getElementsByTagName("select");B=y.getElementsByTagName("select");if(A){for(w=0,x=A.length;w<x;w+=1){u=A[w];z=B[w];for(v=0;v<u.options.length;v+=1){if(v===u.selectedIndex||u.options[v].selected){z.options[v].setAttribute("selected","selected")}else{z.options[v].removeAttribute("selected")}}}}}function q(u){var t,v=null;if(u){t=u.nodeType||-1;switch(t){case 9:v=u.documentElement.outerHTML;break;case 1:v=u.outerHTML;break;default:v=null;break}}return v}function e(v){var t,u=false;if(v){t=v.nodeType||-1;switch(t){case 9:case 1:u=true;break;default:u=false;break}}return u}function p(t,G,J){var B,z,E,D,x=["iframe","frame"],I,v,H,w,u,C={frames:[],canvas:[]},A,y;for(z=0;z<x.length;z+=1){D=x[z];A=t.getElementsByTagName(D);y=G.getElementsByTagName(D);if(A){for(B=0,E=A.length;B<E;B+=1){try{I=A[B];v=o.utils.getIFrameWindow(I);if(v&&v.document){H=v.document;w=r(H,H,J);u=a();y[B].setAttribute("tltid",u);C.frames.push({root:w.root,charset:H.characterSet||H.charset,tltid:u});C.frames=C.frames.concat(w.frames);C.canvas=C.canvas.concat(w.canvas)}}catch(F){}}}}return C}function c(v){var u,t,w=0;if(!v||!v.root){return w}w=v.root.length;for(u=0,t=v.frames.length;u<t;u+=1){if(v.frames[u].root){w+=v.frames[u].root.length}}return w}j=function(t){var u=null;if(e(t)){u=t.cloneNode(true);if(!u&&t.documentElement){u=t.documentElement.cloneNode(true)}}return u};r=function(x,u,v){var z=null,w,t,y={};if(!x||!u){return y}z=j(u,x);if(v.removeScripts){l(z,"script")}n(u,z);i(z);z=k.applyPrivacyToDocument(z);if(v.captureCanvas){w=null}if(v.captureFrames){t=p(u,z,v)}if(t){y=o.utils.mixin(y,t)}if(w){if(!y.canvas){y.canvas=[]}y.canvas=y.canvas.concat(w)}y.root=(h(u)||"")+q(z);y.charset=x.characterSet||x.charset;return y};g=function(){s=o.getService("config");d(s.getServiceConfig("domCapture")||{})};return{init:function(){s=o.getService("config");if(!m){d(s.getServiceConfig("domCapture")||{})}else{}},destroy:function(){f()},captureDOM:function(t,u){var v=null,w=0;if(!m||o.utils.isLegacyIE){return v}if(!u||typeof u!=="object"){u={}}t=t||window.document;v=r(window.document,t,u);if(u.maxLength){w=c(v);if(w>u.maxLength){v={errorCode:101,error:"Captured length ("+w+") exceeded limit ("+u.maxLength+")."}}}return v}}});TLT.addService("encoder",function(a){var f={},g=null,b=null,d=false;function e(j){var i=null;if(!j){return i}i=f[j];if(i&&typeof i.encode==="string"){i.encode=a.utils.access(i.encode)}return i}function h(i){f=i;g.subscribe("configupdated",b);d=true}function c(){g.unsubscribe("configupdated",b);d=false}b=function(){g=a.getService("config");h(g.getServiceConfig("encoder")||{})};return{init:function(){g=a.getService("config");if(!d){h(g.getServiceConfig("encoder")||{})}else{}},destroy:function(){c()},encode:function(m,l){var k,i,j={data:null,encoding:null,error:null};if((typeof m!=="string"&&!m)||!l){j.error="Invalid "+(!m?"data":"type")+" parameter.";return j}k=e(l);if(!k){j.error="Specified encoder ("+l+") not found.";return j}if(typeof k.encode!=="function"){j.error="Configured encoder ("+l+") encode method is not a function.";return j}i=k.encode(m);if(!i||a.utils.getValue(i,"buffer",null)===null){j.error="Encoder ("+l+") returned an invalid result.";return j}j.data=i.buffer;j.encoding=k.defaultEncoding;return j}}});TLT.addService("message",function(r){var o=null,B=0,i=0,m=new Date(),p=new Date(),h=r.getService("browserBase"),a=r.getService("browser"),g=r.getService("config"),v=g.getServiceConfig("message")||{},k=window.location.href,G="TODO",J="ID"+p.getHours()+"H"+p.getMinutes()+"M"+p.getSeconds()+"S"+p.getMilliseconds()+"R"+Math.random(),K=v.hasOwnProperty("privacy")?v.privacy:[],y={},H={lower:"x",upper:"X",numeric:"9",symbol:"@"},q=navigator.userAgent.indexOf("iPhone")>-1||navigator.userAgent.indexOf("iPod")>-1||navigator.userAgent.indexOf("iPad")>-1,n=navigator.userAgent.indexOf("Chrome")>-1&&navigator.userAgent.indexOf("Android")>-1,f=window.devicePixelRatio||1,e=window.screen?window.screen.width:0,u=window.screen?window.screen.height:0,I=window.orientation||0,j=q||n?e:e<=320?e:e/f,x=q||n?u:e<=320?u:u/f,E=(window.screen?window.screen.height-window.screen.availHeight:0),D=window.innerWidth||document.documentElement.clientWidth,l=window.innerHeight||document.documentElement.clientHeight,A=false;function c(M){var L="";this.type=M.type;this.offset=(new Date()).getTime()-m.getTime();if((M.type===2)||(o===null)){o=new Date()}this.screenviewOffset=(new Date()).getTime()-o.getTime();this.count=(i+=1);this.fromWeb=true;for(L in M){if(M.hasOwnProperty(L)){this[L]=M[L]}}}y.PVC_MASK_EMPTY=function(L){return""};y.PVC_MASK_BASIC=function(M){var L="XXXXX";if(typeof M!=="string"){return""}return(M.length?L:"")};y.PVC_MASK_TYPE=function(P){var M,O=0,L=0,N="";if(typeof P!=="string"){return N}M=P.split("");for(O=0,L=M.length;O<L;O+=1){if(r.utils.isNumeric(M[O])){N+=H.numeric}else{if(r.utils.isUpperCase(M[O])){N+=H.upper}else{if(r.utils.isLowerCase(M[O])){N+=H.lower}else{N+=H.symbol}}}}return N};y.PVC_MASK_EMPTY.maskType=1;y.PVC_MASK_BASIC.maskType=2;y.PVC_MASK_TYPE.maskType=3;y.PVC_MASK_CUSTOM={maskType:4};function b(L,N){var M=y.PVC_MASK_BASIC;if(typeof N!=="string"){return N}if(!L){M=y.PVC_MASK_BASIC}else{if(L.maskType===y.PVC_MASK_EMPTY.maskType){M=y.PVC_MASK_EMPTY}else{if(L.maskType===y.PVC_MASK_BASIC.maskType){M=y.PVC_MASK_BASIC}else{if(L.maskType===y.PVC_MASK_TYPE.maskType){M=y.PVC_MASK_TYPE}else{if(L.maskType===y.PVC_MASK_CUSTOM.maskType){if(typeof L.maskFunction==="string"){M=r.utils.access(L.maskFunction)}else{M=L.maskFunction}if(typeof M!=="function"){M=y.PVC_MASK_BASIC}}}}}}return M(N)}function w(L,M){if(!M||!M.target){return}if(typeof M.target.prevState!=="undefined"&&M.target.prevState.hasOwnProperty("value")){M.target.prevState.value=b(L,M.target.prevState.value)}if(typeof M.target.currState!=="undefined"&&M.target.currState.hasOwnProperty("value")){M.target.currState.value=b(L,M.target.currState.value)}}function F(S,T){var P,O,Q,U,L,N,V,R,M;if(!S||!T||!T.id){return false}for(P=0,R=S.length;P<R;P+=1){M=S[P];if(typeof M==="string"){U=a.queryAll(M);for(O=0,L=U?U.length:0;O<L;O+=1){if(U[O]){N=h.ElementData.prototype.examineID(U[O]);if(N.type===T.idType&&N.id===T.id){return true}}}}else{if(M.id&&M.idType&&T.idType.toString()===M.idType.toString()){switch(typeof M.id){case"string":if(M.id===T.id){return true}break;case"object":V=new RegExp(M.id.regex,M.id.flags);if(V.test(T.id)){return true}break}}}}return false}function z(O){var N,L,M;if(!O||!O.hasOwnProperty("target")){return O}for(N=0,L=K.length;N<L;N+=1){M=K[N];if(F(M.targets,O.target)){w(M,O);break}}return O}function d(V){var O,N,M,P,R,W,U,L,T,Q,S;if(!V){return V}for(O=0,R=K.length;O<R;O+=1){W=K[O];Q=W.targets;for(N=0,S=Q.length;N<S;N+=1){T=Q[N];if(typeof T==="string"){U=a.queryAll(T,V);for(M=0,L=U.length;M<L;M+=1){P=U[M];if(P.value){P.setAttribute("value",b(W,P.value))}}}else{if(typeof T.id==="string"){P=h.getNodeFromID(T.id,T.idType,V);if(P&&P.value){P.setAttribute("value",b(W,P.value))}}}}}return V}function s(){g=r.getService("config");v=g.getServiceConfig("message")||{};K=v.hasOwnProperty("privacy")?v.privacy:[]}function t(){if(g.subscribe){g.subscribe("configupdated",s)}A=true}function C(){g.unsubscribe("configupdated",s);A=false}return{init:function(){if(!A){t()}else{}},destroy:function(){C()},applyPrivacyToDocument:d,createMessage:function(L){if(typeof L.type==="undefined"){throw new TypeError("Invalid queueEvent given!")}return z(new c(L))},wrapMessages:function(M){var L={messageVersion:"4.0.0.0",serialNumber:(B+=1),sessions:[{id:J,startTime:p.getTime(),timezoneOffset:p.getTimezoneOffset(),messages:M,clientEnvironment:{webEnvironment:{libVersion:"4.0.0.1607",page:k,windowId:G,screen:{devicePixelRatio:f,deviceOriginalWidth:q||n?e*f:e,deviceOriginalHeight:q||n?u*f:u,deviceWidth:j,deviceHeight:x,deviceToolbarHeight:E,width:D,height:l,orientation:I}}}}]},N=L.sessions[0].clientEnvironment.webEnvironment.screen;N.orientationMode=r.utils.getOrientationMode(N.orientation);return L}}});TLT.addService("serializer",function(core){function serializeToJSON(obj){var str,key,len=0;if(typeof obj!=="object"||obj===null){switch(typeof obj){case"function":case"undefined":return"null";case"string":return'"'+obj.replace(/\"/g,'\\"')+'"';default:return String(obj)}}else{if(Object.prototype.toString.call(obj)==="[object Array]"){str="[";for(key=0,len=obj.length;key<len;key+=1){if(Object.prototype.hasOwnProperty.call(obj,key)){str+=serializeToJSON(obj[key])+","}}}else{str="{";for(key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){str=str.concat('"',key,'":',serializeToJSON(obj[key]),",");len+=1}}}}if(len>0){str=str.substring(0,str.length-1)}str+=String.fromCharCode(str.charCodeAt(0)+2);return str}var configService=core.getService("config"),serialize={},parse={},defaultSerializers={json:(function(){if(typeof window.JSON!=="undefined"){return{serialize:window.JSON.stringify,parse:window.JSON.parse}}return{serialize:serializeToJSON,parse:function(data){return eval("("+data+")")}}}())},updateConfig=null,isInitialized=false;function addObjectIfExist(paths,rootObj,propertyName){var i,len,obj;paths=paths||[];for(i=0,len=paths.length;i<len;i+=1){obj=paths[i];if(typeof obj==="string"){obj=core.utils.access(obj)}if(typeof obj==="function"){rootObj[propertyName]=obj;break}}}function checkParserAndSerializer(){var isParserAndSerializerInvalid;if(typeof serialize.json!=="function"||typeof parse.json!=="function"){isParserAndSerializerInvalid=true}else{if(typeof parse.json('{"foo": "bar"}')==="undefined"){isParserAndSerializerInvalid=true}else{isParserAndSerializerInvalid=parse.json('{"foo": "bar"}').foo!=="bar"}if(typeof parse.json("[1, 2]")==="undefined"){isParserAndSerializerInvalid=true}else{isParserAndSerializerInvalid=isParserAndSerializerInvalid||parse.json("[1, 2]")[0]!==1;isParserAndSerializerInvalid=isParserAndSerializerInvalid||parse.json("[1,2]")[1]!==2}isParserAndSerializerInvalid=isParserAndSerializerInvalid||serialize.json({foo:"bar"})!=='{"foo":"bar"}';isParserAndSerializerInvalid=isParserAndSerializerInvalid||serialize.json([1,2])!=="[1,2]"}return isParserAndSerializerInvalid}function initSerializerService(config){var format;for(format in config){if(config.hasOwnProperty(format)){addObjectIfExist(config[format].stringifiers,serialize,format);addObjectIfExist(config[format].parsers,parse,format)}}if(!(config.json&&config.json.hasOwnProperty("defaultToBuiltin"))||config.json.defaultToBuiltin===true){serialize.json=serialize.json||defaultSerializers.json.serialize;parse.json=parse.json||defaultSerializers.json.parse}if(typeof serialize.json!=="function"||typeof parse.json!=="function"){core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.")}if(checkParserAndSerializer()){core.fail("JSON stringification and parsing are not working as expected")}if(configService.subscribe){configService.subscribe("configupdated",updateConfig)}isInitialized=true}function destroy(){serialize={};parse={};configService.unsubscribe("configupdated",updateConfig);isInitialized=false}updateConfig=function(){configService=core.getService("config");initSerializerService(configService.getServiceConfig("serializer")||{})};return{init:function(){if(!isInitialized){initSerializerService(configService.getServiceConfig("serializer")||{})}else{}},destroy:function(){destroy()},parse:function(data,type){type=type||"json";return parse[type](data)},serialize:function(data,type){type=type||"json";return serialize[type](data)}}});if(TLT&&typeof TLT.addModule==="function"){TLT.addModule("overstat",function(e){var n={"input:radio":"radioButton","input:checkbox":"checkBox","input:text":"textBox","input:password":"textBox","input:file":"fileInput","input:button":"button","input:submit":"submitButton","input:reset":"resetButton","input:image":"image","input:color":"color","input:date":"date","input:datetime":"datetime","input:datetime-local":"datetime-local","input:number":"number","input:email":"email","input:tel":"tel","input:search":"search","input:url":"url","input:time":"time","input:week":"week","input:month":"month","textarea:":"textBox","select:":"selectList","button:":"button","a:":"link"},p={},B={UPDATE_INTERVAL:250,HOVER_THRESHOLD_MIN:1000,HOVER_THRESHOLD_MAX:2*60*1000,GRIDCELL_MAX_X:10,GRIDCELL_MAX_Y:10,GRIDCELL_MIN_WIDTH:20,GRIDCELL_MIN_HEIGHT:20};function d(J,I){var H,G;if(!J||typeof J!=="object"){return null}G=I.split(".");for(H=0;H<G.length;H+=1){if((typeof J==="undefined")||(J[G[H]]===null)){return null}J=J[G[H]]}return J}function x(G){var H=e.getConfig()||{},I=H[G];return typeof I==="number"?I:B[G]}function F(L,G){var H=d(L,"webEvent.target.element.tagName")||"",I=H.toLowerCase()==="input"?d(L,"webEvent.target.element.type"):"",K=n[H.toLowerCase()+":"+I]||H,J={type:9,event:{hoverDuration:L.hoverDuration,hoverToClick:d(G,"hoverToClick")},target:{id:d(L,"webEvent.target.id")||"",idType:d(L,"webEvent.target.idType")||"",name:d(L,"webEvent.target.name")||"",tlType:K,type:H,subType:I,position:{width:d(L,"webEvent.target.element.offsetWidth")||0,height:d(L,"webEvent.target.element.offsetHeight")||0,relXY:L.gridX+","+L.gridY}}};if((typeof J.target.id)===undefined||J.target.id===""){return}e.post(J)}function s(G){if(G&&G.element){G=G.element}return !G||G===document.body||G===document.html||G===document}function j(G){if(!G){return null}return G.element?G.element.parentNode:G.parentNode}function o(H){if(!H){return null}var G=H.element?H.element.offsetParent:H.offsetParent;return G||j(H)}function w(G,H){if(!H||H===G){return false}H=j(H);while(!s(H)){if(H===G){return true}H=j(H)}return false}function D(G){if(G.nativeEvent){G=G.nativeEvent}return G}function y(G){return D(G).target}function i(G){if(!G){return null}return G.element||G}function h(G){if(!G){return -1}if(G.element){G=G.element}return G.nodeType||-1}function C(G){if(!G){return""}if(G.element){G=G.element}return G.tagName?G.tagName.toUpperCase():""}function z(G){if(G&&G.element){G=G.element}return G}function t(G){if(!G){return}if(G.nativeEvent){G=G.nativeEvent}if(G.stopPropagation){G.stopPropagation()}else{if(G.cancelBubble){G.cancelBubble()}}}function m(H){var G=C(H);return h(H)!==1||G==="TR"||G==="TBODY"||G==="THEAD"}function g(G){if(!G){return""}if(G.xPath){return G.xPath}G=i(G);return e.getXPathFromNode(G)}function A(H,G){var I=p[H];if(I&&I[G]){return I[G]()}}function v(H,J,I,G){this.xPath=H!==null?g(H):"";this.domNode=H;this.hoverDuration=0;this.hoverUpdateTime=0;this.gridX=Math.max(J,0);this.gridY=Math.max(I,0);this.parentKey="";this.updateTimer=-1;this.disposed=false;this.childKeys={};this.webEvent=G;this.getKey=function(){return this.xPath+":"+this.gridX+","+this.gridY};this.update=function(){var L=new Date().getTime(),K=this.getKey();if(this.hoverUpdateTime!==0){this.hoverDuration+=L-this.hoverUpdateTime}this.hoverUpdateTime=L;clearTimeout(this.updateTimer);this.updateTimer=setTimeout(function(){A(K,"update")},x("UPDATE_INTERVAL"))};this.dispose=function(K){clearTimeout(this.updateTimer);delete p[this.getKey()];this.disposed=true;if(K){var L=this.clone();p[L.getKey()]=L;L.update()}};this.process=function(N){clearTimeout(this.updateTimer);if(this.disposed){return false}var L=false,M=this,K=null;if(this.hoverDuration>=x("HOVER_THRESHOLD_MIN")){this.hoverDuration=Math.min(this.hoverDuration,x("HOVER_THRESHOLD_MAX"));L=true;F(this,{hoverToClick:!!N});while(typeof M!=="undefined"){M.dispose(N);M=p[M.parentKey]}}else{this.dispose(N)}return L};this.clone=function(){var K=new v(this.domNode,this.gridX,this.gridY);K.parentKey=this.parentKey;return K}}function E(I,G,J,H){return new v(I,G,J,H)}function r(M){if(M&&M.position){return{x:M.position.x,y:M.position.y}}M=z(M);var G=M.offsetLeft,N=M.offsetTop,L=G,K=N,I=0,H=0,J=o(M);while(J){if(s(J)){break}I=J.offsetLeft-(J.scrollLeft||0);H=J.offsetTop-(J.scrollTop||0);if(I!==L||H!==K){G+=I;N+=H;L=I;K=H}J=o(J)}if(isNaN(G)){G=0}if(isNaN(N)){N=0}return{x:G,y:N}}function a(K,I,H){K=z(K);var J=r(K),G=I-J.x,L=H-J.y;if(!isFinite(G)){G=0}if(!isFinite(L)){L=0}return{x:G,y:L}}function f(J,H,M){J=z(J);var I=J.offsetWidth>0?Math.max(J.offsetWidth/x("GRIDCELL_MAX_X"),x("GRIDCELL_MIN_WIDTH")):x("GRIDCELL_MIN_WIDTH"),G=J.offsetHeight>0?Math.max(J.offsetHeight/x("GRIDCELL_MAX_X"),x("GRIDCELL_MIN_HEIGHT")):x("GRIDCELL_MIN_HEIGHT"),L=Math.floor(H/I),K=Math.floor(M/G);if(!isFinite(L)){L=0}if(!isFinite(K)){K=0}return{x:L,y:K}}function c(J){var K=J,L=J.getKey(),G={},H=null,I=null;G[L]=true;while(typeof K!=="undefined"){G[K.parentKey]=true;if(K.parentKey===""||K.parentKey===K.getKey()){break}K=p[K.parentKey]}for(H in p){if(p.hasOwnProperty(H)&&!G[H]){K=p[H];if(K){K.process()}}}}function u(H,I){var J=null,G=null;for(G in p){if(p.hasOwnProperty(G)){J=p[G];if(J.domNode===H&&J.getKey()!==I){J.process()}}}}function b(K,I,J){if(!I){I=K.target}if(s(I)){return null}if(e.utils.isiOS||e.utils.isAndroid){return null}var G,P,L,O,M,N,H;if(!m(I)){G=a(I,K.position.x,K.position.y);P=f(I,G.x,G.y);L=new v(I,P.x,P.y,K);O=L.getKey();if(p[O]){L=p[O]}else{p[O]=L}L.update();if(!J){H=o(I);if(H){N=b(K,H,true);if(N!==null){M=N.getKey();O=L.getKey();if(O!==M){L.parentKey=M}}}c(L)}}else{L=b(K,o(I),J)}return L}function q(G){G=D(G);if(w(G.target,G.relatedTarget)){return}u(G.target)}function l(H){var I=null,G;for(G in p){if(p.hasOwnProperty(G)){I=p[G];I.process(true)}}}function k(H){var G=d(H,"target.id");if(!G){return}switch(H.type){case"mousemove":b(H);break;case"mouseout":q(H);break;case"click":l(H);break}}return{init:function(){},destroy:function(){var H,G;for(H in p){if(p.hasOwnProperty(H)){p[H].dispose();delete p[H]}}},onevent:function(G){if(typeof G!=="object"||!G.type){return}k(G)},onmessage:function(G){},createHoverEvent:E,cleanupHoverEvents:c,eventMap:p}})}else{}if(TLT&&typeof TLT.addModule==="function"){TLT.addModule("performance",function(f){var h={loadReceived:false,unloadReceived:false,perfEventSent:false},g=0;function b(j,i){if(typeof j!=="string"){return false}if(!i||typeof i!=="object"){return false}return(i[j]===true)}function e(k,i){var m=0,j={},n="",l=0;if(!k||typeof k!=="object"||!k.navigationStart){return{}}m=k.navigationStart;for(n in k){if(Object.prototype.hasOwnProperty.call(k,n)||typeof k[n]==="number"){if(!b(n,i)){l=k[n];if(typeof l==="number"&&l&&n!=="navigationStart"){j[n]=l-m}else{j[n]=l}}}}return j}function d(l){var m=0,k,j,i=f.utils;if(l){k=(l.responseEnd>0&&l.responseEnd<l.domLoading)?l.responseEnd:l.domLoading;j=l.loadEventStart;if(i.isNumeric(k)&&i.isNumeric(j)&&j>k){m=j-k}}return m}function c(j){var i=f.getStartTime();if(j.timestamp>i&&!g){g=j.timestamp-i}}function a(m){var k=f.getConfig()||{},j="UNKNOWN",n={type:7,performance:{}},i,o,l;if(!m||h.perfEventSent){return}o=m.performance||{};l=o.timing;i=o.navigation;if(l){n.performance.timing=e(l,k.filter);n.performance.timing.renderTime=d(l)}else{if(k.calculateRenderTime){n.performance.timing={renderTime:g,calculated:true}}else{return}}if(k.renderTimeThreshold&&n.performance.timing.renderTime>k.renderTimeThreshold){n.performance.timing.invalidRenderTime=n.performance.timing.renderTime;delete n.performance.timing.renderTime}if(i){switch(i.type){case 0:j="NAVIGATE";break;case 1:j="RELOAD";break;case 2:j="BACKFORWARD";break;default:j="UNKNOWN";break}n.performance.navigation={type:j,redirectCount:i.redirectCount}}f.post(n);h.perfEventSent=true}return{init:function(){},destroy:function(){},onevent:function(i){if(typeof i!=="object"||!i.type){return}switch(i.type){case"load":h.loadReceived=true;c(i);break;case"unload":h.unloadReceived=true;if(!h.perfEventSent){a(window)}break;default:break}},onmessage:function(i){}}})}else{}TLT.addModule("replay",function(an){var C={"a:":"link","button:button":"button","button:submit":"button","input:button":"button","input:checkbox":"checkBox","input:color":"colorPicker","input:date":"datePicker","input:datetime":"datetimePicker","input:datetime-local":"datetime-local","input:email":"emailInput","input:file":"fileInput","input:image":"image","input:month":"month","input:number":"numberPicker","input:password":"textBox","input:radio":"radioButton","input:range":"slider","input:reset":"resetButton","input:search":"searchBox","input:submit":"submitButton","input:tel":"tel","input:text":"textBox","input:time":"timePicker","input:url":"urlBox","input:week":"week","select:":"selectList","select:select-one":"selectList","textarea:":"textBox","textarea:textarea":"textBox"},ao=an.utils,N=window.orientation||0,ai={scale:0,timestamp:0},ac={},D=window.location.hash,J=null,e=[],ad=0,af=null,B=null,l=0,W="",y="",R=(new Date()).getTime(),k=0,U=null,al=null,S=null,E=null,aj=null,X=null,aa=0,v=0,ag=null,u={inFocus:false},O=null,z=ao.isiOS,x=navigator.userAgent.indexOf("Chrome")>-1&&ao.isAndroid,r=window.devicePixelRatio||1,q=(window.screen?window.screen.width:0),I=(window.screen?window.screen.height:0),Y=(window.screen?window.screen.height-window.screen.availHeight:0),M=an.getConfig(),ah=1,F=1,T;function s(ar){var ap=false,aq="|button|image|submit|reset|checkbox|radio|",at=null;if(typeof ar!=="object"||!ar.type){return ap}switch(ar.type){case"INPUT":at="|"+(ar.subType||"")+"|";if(aq.indexOf(at.toLowerCase())===-1){ap=false}else{ap=true}break;case"SELECT":case"TEXTAREA":ap=false;break;default:ap=true;break}return ap}function h(aq){var ap=[];aq=aq.parentNode;while(aq){ap.push(aq);aq=aq.parentNode}return ap}function w(ap){return an.utils.some(ap,function(aq){if(aq.tagName==="A"||aq.tagName==="BUTTON"){return aq}return null})}function n(ap){var aq=ap.type,ar=ap.target;if(typeof aq==="string"){aq=aq.toLowerCase()}else{aq="unknown"}if(aq==="blur"){aq="focusout"}if(aq==="change"){if(ar.type==="INPUT"){switch(ar.subType){case"text":case"date":case"time":aq=ar.subType+"Change";break;default:aq="valueChange";break}}else{if(ar.type==="TEXTAREA"){aq="textChange"}else{aq="valueChange"}}}return aq}function A(ap,ar,aq){var at=null;if(!ap){return at}ar=ar||{};if(aq){at="dcid-"+an.utils.getSerialNumber()+"."+(new Date()).getTime()+"s";window.setTimeout(function(){ar.dcid=at;an.performDOMCapture(ap,ar)},aq)}else{delete ar.dcid;at=an.performDOMCapture(ap,ar)}return at}function L(ap,az,aq){var av,aC=false,ar,aB=false,at,aw,ay=null,au=0,ax,aA;if(!ap||(!az&&!aq)){return ay}if(!az&&!(ap==="load"||ap==="unload")){return ay}aA=an.getConfig()||{};aB=ao.getValue(aA,"domCapture.enabled",false);if(!aB||an.utils.isLegacyIE){return ay}aw=ao.getValue(aA,"domCapture.triggers")||[];for(av=0,ax=aw.length;av<ax;av+=1){at=aw[av];if(at.event===ap){if(ap==="load"||ap==="unload"){if(at.screenviews){aC=(-1!==ao.indexOf(at.screenviews,aq))}else{aC=true}}else{if(at.targets){aC=(-1!==ao.matchTarget(at.targets,az))}else{aC=true}}}if(aC){ar=ao.getValue(aA,"domCapture.options",{});au=at.delay||0;ay=A(window.document,ar,au);break}}return ay}function ab(aA){var ar,at,au=ao.getValue(aA,"webEvent.target",{}),ap=au.type,aw=au.subType||null,aq=C[ap.toLowerCase()+":"+aw]||ap,ax=h(ao.getValue(au,"element")),az=null,av=ao.getValue(au,"position.relXY"),ay=ao.getValue(aA,"webEvent.subType",null);ar={type:4,target:{id:au.id||"",idType:au.idType,name:au.name,tlType:aq,type:ap,position:{width:ao.getValue(au,"element.offsetWidth"),height:ao.getValue(au,"element.offsetHeight")},currState:aA.currState||null},event:{tlEvent:n(ao.getValue(aA,"webEvent")),type:ao.getValue(aA,"webEvent.type","UNKNOWN")}};if(aw){ar.target.subType=aw}if(av){ar.target.position.relXY=av}if(typeof aA.dwell==="number"&&aA.dwell>0){ar.target.dwell=aA.dwell}if(typeof aA.visitedCount==="number"){ar.target.visitedCount=aA.visitedCount}if(typeof aA.prevState!=="undefined"){ar.prevState=aA.prevState}if(ay){ar.event.subType=ay}az=w(ax);ar.target.isParentLink=!!az;if(az){if(az.href){ar.target.currState=ar.target.currState||{};ar.target.currState.href=ar.target.currState.href||az.href}if(az.value){ar.target.currState=ar.target.currState||{};ar.target.currState.value=ar.target.currState.value||az.value}if(az.innerText||az.textContent){ar.target.currState=ar.target.currState||{};ar.target.currState.innerText=ao.trim(ar.target.currState.innerText||az.innerText||az.textContent)}}if(ao.isUndefOrNull(ar.target.currState)){delete ar.target.currState}if(ao.isUndefOrNull(ar.target.name)){delete ar.target.name}if(ar.event.type!=="click"||s(au)){at=L(ar.event.type,au);if(at){ar.dcid=at}}return ar}function G(ap){an.post(ap)}function K(au){var ar=0,ap,av=au.length,ax,aw,at,ay={mouseout:true,mouseover:true},aq=[];for(ar=0;ar<av;ar+=1){ax=au[ar];if(!ax){continue}if(ay[ax.event.type]){aq.push(ax)}else{for(ap=ar+1;ap<av&&au[ap];ap+=1){if(!ay[au[ap].event.type]){break}}if(ap<av){aw=au[ap];if(aw&&ax.target.id===aw.target.id&&ax.event.type!==aw.event.type){if(ax.event.type==="click"){at=ax;ax=aw;aw=at}if(aw.event.type==="click"){ax.target.position=aw.target.position;ar+=1}else{if(aw.event.type==="blur"){ax.target.dwell=aw.target.dwell;ax.target.visitedCount=aw.target.visitedCount;ax.focusInOffset=aw.focusInOffset;ax.target.position=aw.target.position;ar+=1}}au[ap]=null;au[ar]=ax}}aq.push(au[ar])}}for(ax=aq.shift();ax;ax=aq.shift()){an.post(ax)}au.splice(0,au.length)}if(typeof window.onerror!=="function"){window.onerror=function(at,ar,ap){var aq=null;if(typeof at!=="string"){return}ap=ap||-1;aq={type:6,exception:{description:at,url:ar,line:ap}};l+=1;an.post(aq)}}function o(aq,ap){u=ap;u.inFocus=true;if(typeof ac[aq]==="undefined"){ac[aq]={}}ac[aq].focus=u.dwellStart=Number(new Date());ac[aq].focusInOffset=S?u.dwellStart-Number(S):-1;ac[aq].prevState=ao.getValue(ap,"target.state");ac[aq].visitedCount=ac[aq].visitedCount+1||1}function Z(ap,aq){e.push(ab({webEvent:ap,id:aq,currState:ao.getValue(ap,"target.state")}))}function d(av,aq){var ar=false,au,ap,at=0;if(typeof av==="undefined"||av===null||typeof aq==="undefined"||aq===null){return}u.inFocus=false;if(typeof ac[av]!=="undefined"&&ac[av].hasOwnProperty("focus")){ac[av].dwell=Number(new Date())-ac[av].focus}else{ac[av]={};ac[av].dwell=0}if(e.length===0){Z(aq,av)}if(e[e.length-1]){for(at=e.length-1;at>=0;at--){e[at].target.visitedCount=ac[av].visitedCount}}ap=e[e.length-1];if(ap){ap.target.dwell=ac[av].dwell;ap.focusInOffset=ac[av].focusInOffset;ap.target.visitedCount=ac[av].visitedCount;if(ap.event.type==="click"){if(!s(ap.target)){ap.target.currState=ao.getValue(aq,"target.state");ar=true}}else{if(ap.event.type==="focus"){ar=true}}if(ar){ap.event.type="blur";ap.event.tlEvent="focusout";au=L(ap.event.type,aq.target);if(au){ap.dcid=au}}}K(e)}function m(ar,aq){var ap=false;if(e.length>0&&e[e.length-1]&&e[e.length-1].target.id!==ar&&aq.type!=="scroll"&&aq.type!=="resize"&&aq.type!=="mouseout"&&aq.type!=="mouseover"&&(e[e.length-1].target.tlType!=="textBox"&&e[e.length-1].target.tlType!=="selectList")){d(e[e.length-1].target.id,e[e.length-1]);ap=true}return ap}function c(aq,ap){if(typeof ac[aq]!=="undefined"&&!ac[aq].hasOwnProperty("focus")){o(aq,ap)}Z(ap,aq);if(typeof ac[aq]!=="undefined"&&typeof ac[aq].prevState!=="undefined"){if(e[e.length-1].target.tlType==="textBox"||e[e.length-1].target.tlType==="selectList"){e[e.length-1].target.prevState=ac[aq].prevState}}}function H(ar){var aq=ar.target.position.x,aw=ar.target.position.y,at=ar.target.size.width,ap=ar.target.size.height,av=Math.abs(aq/at).toFixed(1),au=Math.abs(aw/ap).toFixed(1);av=av>1||av<0?0.5:av;au=au>1||au<0?0.5:au;return av+","+au}function b(au,ar){var aq,ap=true,at=0;if(ar.target.element.tagName==="SELECT"&&O&&O.target.id===au){O=null;return}if(!u.inFocus){o(au,ar)}at=e.length;if(at&&ao.getValue(e[at-1],"event.type")!=="change"){c(au,ar)}aq=H(ar);at=e.length;if(ar.position.x===0&&ar.position.y===0&&at&&ao.getValue(e[at-1],"target.tlType")==="radioButton"){ap=false}else{ar.target.position.relXY=aq}if(at&&ao.getValue(e[at-1],"target.id")===au){if(ap){e[at-1].target.position.relXY=aq}}else{Z(ar,au)}O=ar}function ae(aq){var ap=0;if(window.orientation){ap=window.orientation}else{if(aq!==undefined&&aq.orientation){ap=aq.orientation}}return ap}function a(aq){var ap=ae(aq),ar={type:4,event:{type:"orientationchange"},target:{prevState:{orientation:N,orientationMode:ao.getOrientationMode(N)},currState:{orientation:ap,orientationMode:ao.getOrientationMode(ap)}}};G(ar);N=ap}function am(aq){var ap=false;if(!aq){return ap}ap=(ai.scale===aq.scale&&Math.abs((new Date()).getTime()-ai.timestamp)<500);return ap}function j(ap){ai.scale=ap.scale;ai.rotation=ap.rotation;ai.timestamp=(new Date()).getTime()}function Q(){var ap,aq;ap=ah-F;if(isNaN(ap)){aq="INVALID"}else{if(ap<0){aq="CLOSE"}else{if(ap>0){aq="OPEN"}else{aq="NONE"}}}return aq}function g(ap){var at=document.documentElement,ar=document.body,av={type:1,clientState:{pageWidth:document.width||(!at?0:at.offsetWidth),pageHeight:Math.max((!document.height?0:document.height),(!at?0:at.offsetHeight),(!at?0:at.scrollHeight)),viewPortWidth:window.innerWidth||at.clientWidth,viewPortHeight:window.innerHeight||at.clientHeight,viewPortX:window.pageXOffset||(!at?(!ar?0:ar.scrollLeft):at.scrollLeft||0),viewPortY:window.pageYOffset||(!at?(!ar?0:ar.scrollTop):at.scrollTop||0),deviceOrientation:window.orientation||0,event:ao.getValue(ap,"type")}},aq=1,au=1;B=B||av;if(Math.abs(av.clientState.deviceOrientation)===90){if(z||x){aq=I-Y}else{aq=q<=320?I-Y:((I/r)-Y)}}else{if(z||x){aq=q+Y}else{aq=q<=320?q-Y:((q/r)-Y)}}au=(av.clientState.viewPortWidth===0?1:aq/av.clientState.viewPortWidth);av.clientState.deviceScale=(au-0.02).toFixed(3);av.clientState.viewTime=0;if(E&&aj){av.clientState.viewTime=aj.getTime()-E.getTime()}if(ap.type==="scroll"){av.clientState.viewPortXStart=B.clientState.viewPortX;av.clientState.viewPortYStart=B.clientState.viewPortY}return av}function p(){if(af){G(af);B=af;af=null;E=X||E;aj=null}}function V(ap){var aq=null;af=g(ap);if(ap.type==="scroll"||ap.type==="resize"){if(p.timeoutId){window.clearTimeout(p.timeoutId);p.timeoutId=0}p.timeoutId=window.setTimeout(p,ao.getValue(M,"scrollTimeout",2000))}else{if(ap.type==="touchstart"||ap.type==="load"){if(af){F=parseFloat(af.clientState.deviceScale)}}else{if(ap.type==="touchend"){if(af){ah=parseFloat(af.clientState.deviceScale);p()}}}}if(ap.type==="load"||ap.type==="unload"){if(ap.type==="unload"&&R){aq=ao.clone(af);aq.clientState.event="attention";aq.clientState.viewTime=(new Date()).getTime()-R}p();if(aq){af=aq;p()}}return af}function ak(aq){var ap=ao.getValue(aq,"nativeEvent.touches.length",0);if(ap===2){V(aq)}}function i(at){var ar,aq={},au=ao.getValue(at,"nativeEvent.rotation",0)||ao.getValue(at,"nativeEvent.touches[0].webkitRotationAngle",0),av=ao.getValue(at,"nativeEvent.scale",1),ap=null,aw={type:4,event:{type:"touchend"},target:{id:ao.getValue(at,"target.id"),idType:ao.getValue(at,"target.idType")}};ar=ao.getValue(at,"nativeEvent.changedTouches.length",0)+ao.getValue(at,"nativeEvent.touches.length",0);if(ar!==2){return}V(at);ap={rotation:au?au.toFixed(2):0,scale:ah?ah.toFixed(2):1};ap.pinch=Q();aq.scale=F?F.toFixed(2):1;aw.target.prevState=aq;aw.target.currState=ap;G(aw)}function f(aA,at){var ax=["type","target.id"],ar=null,au,aw,av=true,ay=10,aq=0,az=0,ap=0;if(!aA||!at||typeof aA!=="object"||typeof at!=="object"){av=false}for(au=0,aw=ax.length;av&&au<aw;au+=1){ar=ax[au];if(ao.getValue(aA,ar)!==ao.getValue(at,ar)){av=false;break}}if(av){az=ao.getValue(aA,"timestamp");ap=ao.getValue(at,"timestamp");if(!(isNaN(az)&&isNaN(ap))){aq=Math.abs(ao.getValue(aA,"timestamp")-ao.getValue(at,"timestamp"));if(isNaN(aq)||aq>ay){av=false}}}return av}function P(){var ap=window.location.hash;if(ap===D){return}if(D){TLT.logScreenviewUnload(D)}if(ap){TLT.logScreenviewLoad(ap)}D=ap}function t(ap){var aq={type:4,event:{type:ap.type},target:{id:ao.getValue(ap,"target.id"),idType:ao.getValue(ap,"target.idType")}};G(aq)}return{init:function(){e=[]},destroy:function(){d(J);e=[]},onevent:function(ap){var ar=null,aq=null;if(typeof ap!=="object"||!ap.type){return}if(f(ap,U)){U=ap;return}U=ap;ar=ao.getValue(ap,"target.id");if(Object.prototype.toString.call(ac[ar])!=="[object Object]"){ac[ar]={}}m(ar,ap);ag=new Date();switch(ap.type){case"hashchange":P();break;case"focus":aq=o(ar,ap);break;case"blur":aq=d(ar,ap);break;case"click":aq=b(ar,ap);break;case"change":aq=c(ar,ap);break;case"orientationchange":aq=a(ap);break;case"touchstart":ak(ap);break;case"touchend":aq=i(ap);break;case"load":E=new Date();V(ap);TLT.logScreenviewLoad("root");break;case"screenview_load":S=new Date();aq=L("load",null,ap.name);break;case"screenview_unload":aq=L("unload",null,ap.name);break;case"resize":case"scroll":if(!aj){aj=new Date()}X=new Date();V(ap);break;case"unload":if(e!==null){K(e)}aj=new Date();V(ap);TLT.logScreenviewUnload("root");break;default:t(ap);break}J=ar;return aq},onmessage:function(){}}});TLT.addModule("saas",function(a){var c=function(){if(typeof TLT.getCoreConfig().modules.saas!=="undefined"){var d;for(d in TLT.getCoreConfig().modules.saas){if(TLT.getCoreConfig().modules.saas.hasOwnProperty(d)&&typeof d==="string"&&typeof TLT.getCoreConfig().modules.saas[d]==="string"){this[d]=TLT.getCoreConfig().modules.saas[d];document.cookie=d+"="+this[d]}}this.get=function(e){if(typeof e!=="string"||typeof this==="undefined"){return"SaaS Data undefined or key is not a string"}if(typeof this[e]==="undefined"){return"Key does not exist within saasData"}return this[e]};this.set=function(e,f){if(typeof e!=="string"||typeof f!=="string"||typeof this==="undefined"||e==="get"||e==="set"||e==="toSaasString"||e==="clear"||e==="remove"){return false}this[e]=f;document.cookie=e+"="+f;return true};this.clear=function(){var e;for(e in this){if(this.hasOwnProperty(e)&&e!=="get"&&e!=="set"&&e!=="toSaasString"&&e!=="clear"&&e!=="remove"){document.cookie=e+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";delete this[e]}}return};this.remove=function(e){if(this.hasOwnProperty(e)&&e!=="get"&&e!=="set"&&e!=="toSaasString"&&e!=="clear"&&e!=="remove"){document.cookie=e+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";delete this[e]}return};this.toSaasString=function(){var f="",e;for(e in this){if(this.hasOwnProperty(e)&&typeof this.get(e)==="string"){f+=e+"="+this.get(e)+";"}}return f}}},b=new c();return{init:function(){TLT.saasData=b},destroy:function(){},onevent:function(d){}}});</script>
<script type="text/tljs" id="UIC-SDK-FILE-jQuery-prod">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags jQuery,NDEBUG
 */

/**
 * @fileOverview Defines the core of the system, namely the TLT object.
 * @exports TLT
 */
/*global window*/
/*jshint loopfunc:true*/
/**
 * TLT (short for Tealeaf Technology) is the top-level object for the system. All
 * objects and functions live under TLT to prevent polluting the global
 * scope. This object also manages the modules and services on the page,
 * controlling their lifecycle, manages inter-module communication.
 * @namespace
 */
// Sanity check
if (window.TLT) {
    throw "Attempting to recreate TLT. Library may be included more than once on the page.";
}
var TLT = (function () {

    "use strict";

    /* Create and add a screenview message to the default queue. Also
     * notifies any listeners of the screenview load/unload event.
     * @param {Enum} type "LOAD" or "UNLOAD" indicating the type
     * of screenview event.
     * @param {string} name User friendly name of the screenview.
     * @param {string} [referrerName] Name of the previous screenview that
     * is being replaced.
     * @param {object} [root] DOMNode which represents the root or
     * parent of this screenview. Usually this is a div container.
     * @returns {void}
     */
    function logScreenview(type, name, referrerName, root) {
        var dcid = null,
            screenviewMsg = null,
            queue = TLT.getService("queue"),
            replay = TLT.getModule("replay"),
            webEvent = null,
            winLocation = window.location,
            host = winLocation.origin || null,
            url = winLocation.pathname;

        // Sanity checks
        if (!name || typeof name !== "string") {
            return;
        }
        if (!referrerName || typeof referrerName !== "string") {
            referrerName = "";
        }

        if (!host) {
            host = (winLocation.protocol || "") + "//" + (winLocation.host || "");
        }

        // This is needed for Native hybrid replay to get file path of webview assets used.
        if (host.indexOf("file://") > -1) {
            url = url.replace(/(.*?)(?=\/[^.\/]*\.app)/g, '').replace('.app//', '.app/');
        }

        screenviewMsg = {
            type: 2,
            screenview: {
                type: type,
                name: name,
                url: url,
                host: host,
                referrer: referrerName
            }
        };

        // XXX: Fix this hack. At least send a fully populated WebEvent object.
        // Ideally, want to use the publishEvent to route this to the correct modules.
        if (type === "LOAD") {
            webEvent = {
                type: "screenview_load",
                name: name
            };
        } else if (type === "UNLOAD") {
            webEvent = {
                type: "screenview_unload",
                name: name
            };
        }

        if (webEvent && replay) {
            dcid = replay.onevent(webEvent);
        }

        // If DOM Capture was triggered for this add it to the screenview message.
        if (dcid) {
            screenviewMsg.dcid = dcid;
        }

        if (type === "LOAD" || type === "UNLOAD") {
            queue.post("", screenviewMsg, "DEFAULT");
        }
    }


    var tltStartTime = (new Date()).getTime(),

        /**
         * A collection of module information. The keys in this object are the
         * module names and the values are an object consisting of three pieces
         * of information: the creator function, the instance, and context object
         * for that module.
         * @private
         */
        modules = {},

        /**
         * A collection of service information. The keys in this object are the
         * service names and the values are an object consisting of two pieces
         * of information: the creator function and the service object.
         * @private
         */
        services = {},

        /**
         * Indicates if the core has been initialized or not.
         * @private
         */
        initialized = false,
        state = null,

        /**
         * Checks whether given frame is blacklisted (in the config) or not.
         * @function
         * @private
         * @param {DOMElement} iframe an element to examine
         * @return {boolean} true if given iframe is blacklisted, false otherwise
         */
        isFrameBlacklisted = (function () {
            var blacklistedFrames,
                checkedFrames = [];

            function prepareBlacklistedFrames(scope) {
                var browserService = core.getService("browser"),
                    blacklist = core.getCoreConfig().framesBlacklist,
                    foundFrames,
                    i;
                blacklistedFrames = blacklistedFrames || [];
                scope = scope || null;
                if (typeof blacklist !== "undefined" && blacklist.length > 0) {
                    for (i = 0; i < blacklist.length; i += 1) {
                        foundFrames = browserService.queryAll(blacklist[i], scope);
                        if (foundFrames && foundFrames.length > 0) {
                            blacklistedFrames = blacklistedFrames.concat(foundFrames);
                        }
                    }
                    checkedFrames = checkedFrames.concat(browserService.queryAll('iframe', scope));
                }
            }

            function isFrameBlacklisted(iframe) {
                if (core.utils.indexOf(checkedFrames, iframe) < 0) {
                    prepareBlacklistedFrames(iframe.ownerDocument);
                }
                return core.utils.indexOf(blacklistedFrames, iframe) > -1;
            }

            isFrameBlacklisted.clearCache = function () {
                blacklistedFrames = null;
            };

            return isFrameBlacklisted;
        }()),

        /**
         * Last clicked element, needed for IE and 'beforeunload'
         * @private
         */
        lastClickedElement = null,

        /**
         * List of service passthroughs. These are methods that are called
         * from TLT and simply pass through to the given service without
         * changing the arguments. Doing this dynamically keeps the code
         * smaller and easier to update.
         * @private
         */
        servicePassthroughs = {

            "config": [

                /**
                 * Returns the global configuration object (the one passed to init()).
                 * @name getConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The global configuration object.
                 */
                "getConfig",

                /**
                 * Updates the global configuration object (the one passed to init()).
                 * @name updateConfig
                 * @memberOf TLT
                 * @function
                 * @returns {void}
                 */
                "updateConfig",

                /**
                 * Returns the core configuration object.
                 * @name getCoreConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The core configuration object.
                 */
                "getCoreConfig",

                /**
                 * Updates the core configuration object.
                 * @name updateCoreConfig
                 * @memberOf TLT
                 * @function
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateCoreConfig",

                /**
                 * Returns the configuration object for a module.
                 * @name getModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getModuleConfig",

                /**
                 * Updates a configuration object for a module.
                 * @name updateModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateModuleConfig",

                /**
                 * Returns a configuration object for a service.
                 * @name getServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getServiceConfig",

                /**
                 * Updates a configuration object for a service.
                 * @name updateServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateServiceConfig"

            ],

            "queue": [
                /**
                 * Send event information to the module's default queue.
                 * This doesn't necessarily force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name post
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName The name of the module saving the event.
                 * @param  {Object} queueEvent The event information to be saved to the queue.
                 * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "post",
                /**
                 * Enable/disable the automatic flushing of all queues.
                 * Either periodically by a timer or whenever the queue threshold is reached.
                 * @name setAutoFlush
                 * @memberOf TLT
                 * @function
                 * @param {Boolean} flag Set this to false to disable flushing
                 *                 or set it to true to enable automatic flushing (default)
                 * @returns {void}
                 */
                "setAutoFlush",
                /**
                 * Forces all queues to send their data to the server.
                 * @name flushAll
                 * @memberOf TLT
                 * @function
                 */
                "flushAll"

            ],

            "browserBase": [
                /**
                 * Calculates the xpath of the given DOM Node.
                 * @name getXPathFromNode
                 * @memberOf TLT
                 * @function
                 * @param {DOMElement} node The DOM node who's xpath is to be calculated.
                 * @returns {String} The calculated xpath.
                 */
                "getXPathFromNode",

                /**
                 * Let the UIC library process a DOM event, which was prevented
                 * from bubbling by the application.
                 * @name processDOMEvent
                 * @memberOf TLT
                 * @function
                 * @param {Object} event The browsers event object which was prevented.
                 */
                "processDOMEvent"
            ]
        },

        /**
         * Provides methods for handling load/unload events to make sure that this
         * kind of events will be handled independently to browser caching mechanism
         * @namespace
         * @private
         */
        loadUnloadHandler = (function () {
            var status = {};

            return {

                /**
                 * Normalizes the events specified in the configuration in the following ways:
                 * - For each load/unload module event adds corresponding pageshow/pagehide event.
                 * - Adds beforeunload
                 * - Adds propertychange if W3C service is being used for correct operation on legacy IE.
                 * @param {String} moduleName Name of the module
                 * @param {Array} moduleEvents An array of module event configs
                 * @param {object} [localTop] Local window element
                 * @param {object} [documentScope] document element
                 */
                normalizeModuleEvents: function (moduleName, moduleEvents, localTop, documentScope) {
                    var load = false,
                        unload = false,
                        browserService = core.getService("browser");

                    localTop = localTop || core._getLocalTop();
                    documentScope = documentScope || localTop.document;

                    status[moduleName] = {
                        loadFired: false,
                        pageHideFired: false
                    };

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        switch (eventConfig.name) {
                        case "load":
                            load = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pageshow"
                            }));
                            break;

                        case "unload":
                            unload = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pagehide"
                            }));
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "beforeunload"
                            }));
                            break;

                        // IE6, IE7 and IE8 - catching 'onpropertychange' event to
                        // simulate correct 'change' events on radio and checkbox.
                        // required for W3C only as jQuery normalizes it.
                        case "change":
                            if (core.utils.isLegacyIE && core.getFlavor() === "w3c") {
                                moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                    name: "propertychange"
                                }));
                            }
                            break;
                        }
                    });
                    if (!load && !unload) {
                        delete status[moduleName];
                        return;
                    }
                    status[moduleName].silentLoad = !load;
                    status[moduleName].silentUnload = !unload;
                    if (!load) {
                        moduleEvents.push({name: "load", target: localTop});
                    }
                    if (!unload) {
                        moduleEvents.push({name: "unload", target: localTop});
                    }
                },

                /**
                 * Checks if event can be published for the module(s) or not.
                 * The negative case can take place for load/unload events only, to avoid
                 * redundancy in handler execution. If as example load event was handled
                 * properly, the pageshow event will be ignored.
                 * @param {string} moduleName Name of the module
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                canPublish: function (moduleName, event) {
                    var mod;
                    if (status.hasOwnProperty(moduleName) === false) {
                        return true;
                    }
                    mod = status[moduleName];
                    switch (event.type) {
                    case "load":
                        mod.pageHideFired = false;
                        mod.loadFired = true;
                        return !mod.silentLoad;
                    case "pageshow":
                        mod.pageHideFired = false;
                        event.type = "load";
                        return !mod.loadFired && !mod.silentLoad;
                    case "pagehide":
                        event.type = "unload";
                        mod.loadFired = false;
                        mod.pageHideFired = true;
                        return !mod.silentUnload;
                    case "unload":
                    case "beforeunload":
                        event.type = "unload";
                        mod.loadFired = false;
                        return !mod.pageHideFired && !mod.silentUnload;
                    }
                    return true;
                },

                /**
                 * Checks if event indicates the core context is unloading.
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                isUnload: function (event) {
                    return typeof event === "object" ?
                            (event.type === "unload" || event.type === "beforeunload" || event.type === "pagehide") :
                            false;
                }
            };

        }()),

        /**
         * Keeps track of the events being handled.
         * @private
         */
        events = {},

        /**
         * Keeps track of callback functions registered by the iOS and Android native libraries.
         * These are used for communication with the native library.
         */
        bridgeCallbacks = {},

        /**
         * init implementation (defined later)
         * @private
         */
        _init = function () {},
        _callback = null,

        /**
         * Flag to track if TLT.init API can been called.
         * @private
         */
        okToCallInit = true,

        // Tracks the inactivity timeout in publishEvent
        inactivityTimerId = null,
        // Placeholder for the inactivity timeout handler, defined after core.
        inactivityTimeoutHandler = function () {},

        // main interface for the core
        core = /**@lends TLT*/ {


            /**
             * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
             */
            getStartTime: function () {
                return tltStartTime;
            },

            //---------------------------------------------------------------------
            // Core Lifecycle
            //---------------------------------------------------------------------

            /**
             * Initializes the system. The configuration information is passed to the
             * config service to management it. All modules are started (unless their
             * configuration information indicates they should be disabled), and web events
             * are hooked up.
             * @param {Object} config The global configuration object.
             * @param {function} [callback] function executed after initialization and destroy
                    the callback function takes one parameter which describes UIC state;
                    its value can be set to "initialized" or "destroyed"
             * @returns {void}
             */
            init: function (config, callback) {
                var timeoutCallback;
                _callback = callback;
                if (!okToCallInit) {
                    throw "init must only be called once!";
                }
                okToCallInit = false;
                timeoutCallback = function (event) {
                    event = event || window.event || {};
                    if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
                        if (document.removeEventListener) {
                            document.removeEventListener("DOMContentLoaded", timeoutCallback, false);
                            window.removeEventListener("load", timeoutCallback, false);
                        } else {
                            document.detachEvent("onreadystatechange", timeoutCallback);
                            window.detachEvent("onload", timeoutCallback);
                        }
                        _init(config, callback);
                    }
                };

                // case when DOM already loaded (lazy-loaded UIC)
                if (document.readyState === "complete") {
                    // Lets the current browser cycle to complete before calling init
                    setTimeout(timeoutCallback);
                } else if (document.addEventListener) {
                    document.addEventListener("DOMContentLoaded", timeoutCallback, false);
                    // A fallback in case DOMContentLoaded is not supported
                    window.addEventListener("load", timeoutCallback, false);
                } else {
                    document.attachEvent("onreadystatechange", timeoutCallback);
                    // A fallback in case onreadystatechange is not supported
                    window.attachEvent("onload", timeoutCallback);
                }
            },

            /**
             * Indicates if the system has been initialized.
             * @returns {Boolean} True if init() has been called, false if not.
             */
            isInitialized: function () {
                return initialized;
            },

            getState: function () {
                return state;
            },

            /**
             * Shuts down the system. All modules are stopped and all web events
             * are unsubscribed.
             * @returns {void}
             */
            // destroy: function (skipEvents, callback) {
            destroy: function (skipEvents) {

                var token = "",
                    eventName = "",
                    target = null,
                    serviceName = null,
                    service = null,
                    browser = null,
                    delegateTarget = false;

                if (okToCallInit) { //nothing to do
                    return false;
                }

                this.stopAll();

                if (!skipEvents) {
                    browser = this.getService("browser");
                    // Unregister events
                    for (token in events) {
                        if (events.hasOwnProperty(token) && browser !== null) {
                            eventName = token.split("|")[0];
                            target = events[token].target;
                            delegateTarget = events[token].delegateTarget || undefined;
                            browser.unsubscribe(eventName, target, this._publishEvent, delegateTarget);
                        }
                    }
                }

                // call destroy on services that have it
                for (serviceName in services) {
                    if (services.hasOwnProperty(serviceName)) {
                        service = services[serviceName].instance;

                        if (service && typeof service.destroy === "function") {
                            service.destroy();
                        }

                        services[serviceName].instance = null;
                    }
                }

                isFrameBlacklisted.clearCache();
                events = {};
                initialized = false;

                // Reset to allow re-initialization.
                okToCallInit = true;

                state = "destroyed";

                if (typeof _callback === "function") {
                    // Protect against unexpected exceptions since _callback is 3rd party code.
                    try {
                        _callback("destroyed");
                    } catch (e) {
                        // Do nothing!
                    }
                }
            },

            /**
             * Iterates over each module and starts or stops it according to
             * configuration information.
             * @returns {void}
             * @private
             */
            _updateModules: function (scope) {

                var config = this.getCoreConfig(),
                    browser = this.getService("browser"),
                    moduleConfig = null,
                    moduleName = null;

                if (config && browser && config.modules) {
                    try {
                        for (moduleName in config.modules) {
                            if (config.modules.hasOwnProperty(moduleName)) {
                                moduleConfig = config.modules[moduleName];

                                if (modules.hasOwnProperty(moduleName)) {
                                    if (moduleConfig.enabled === false) {
                                        this.stop(moduleName);
                                        continue;
                                    }

                                    this.start(moduleName);

                                    // If the module has specified events in the configuration
                                    // register event handlers for them.
                                    if (moduleConfig.events) {
                                        this._registerModuleEvents(moduleName, moduleConfig.events, scope);
                                    }
                                } else {    // it needs to be loaded
                                    if (browser.loadScript) {
                                        browser.loadScript(config.moduleBase + moduleName + ".js");
                                        // no callback needed because the module will start automatically
                                    }
                                }
                            }
                        }
                        this._registerModuleEvents.clearCache();
                    } catch (e) {
                        core.destroy();
                        return false;
                    }
                } else {
                    return false;
                }
                return true;
            },

            /**
             * Registers event handlers for all modules in a specific scope.
             * E.g. if the application changed the DOM via ajax and want to let
             * us rebind event handlers in this scope.
             * @param  {Object} scope A DOM element as a scope.
             */
            rebind: function (scope) {
                core._updateModules(scope);
            },

            /* Public API which returns the Tealeaf session data that has been
             * configured to be shared with 3rd party scripts.
             * @returns {object} JSON object containing the session data as
             * name-value pairs. If no data is available then returns null.
             */
            getSessionData: function () {

                if (!core.isInitialized()) {
                    return;
                }

                var rv = null,
                    sessionData = null,
                    scName,
                    scValue,
                    config = core.getCoreConfig();

                if (!config || !config.sessionDataEnabled) {
                    return null;
                }

                sessionData = config.sessionData || {};

                // Add any session ID data
                scName = sessionData.sessionQueryName;
                if (scName) {
                    scValue = core.utils.getQueryStringValue(scName, sessionData.sessionQueryDelim);
                } else {
                    // Either the cookie name is configured or the default is assumed.
                    scName = sessionData.sessionCookieName || "TLTSID";
                    scValue = core.utils.getCookieValue(scName);
                }

                if (scName && scValue) {
                    rv = rv || {};
                    rv.tltSCN = scName;
                    rv.tltSCV = scValue;
                    rv.tltSCVNeedsHashing = !!sessionData.sessionValueNeedsHashing;
                }

                return rv;
            },

            /* Public API to create and add a custom event message to the default
             * queue.
             * @param {string} name Name of the custom event.
             * @param {object} customObj Custom object which will be serialized
             * to JSON and included with the custom message.
             * @returns {void}
             */
            logCustomEvent: function (name, customMsgObj) {

                if (!core.isInitialized()) {
                    return;
                }

                var customMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!name || typeof name !== "string") {
                    name = "CUSTOM";
                }
                customMsgObj = customMsgObj || {};

                customMsg = {
                    type: 5,
                    customEvent: {
                        name: name,
                        data: customMsgObj
                    }
                };
                queue.post("", customMsg, "DEFAULT");
            },

            /* Public API to create and add an exception event message to the
             * default queue.
             * @param {string} msg Description of the error or exception.
             * @param {string} [url] URL related to the error or exception.
             * @param {integer} [line] Line number associated with the error or exception.
             * @returns {void}
             */
            logExceptionEvent: function (msg, url, line) {

                if (!core.isInitialized()) {
                    return;
                }

                var exceptionMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!msg || typeof msg !== "string") {
                    return;
                }
                url = url || "";
                line = line || "";

                exceptionMsg = {
                    type: 6,
                    exception: {
                        description: msg,
                        url: url,
                        line: line
                    }
                };

                queue.post("", exceptionMsg, "DEFAULT");
            },

            /* Public API to create and add a screenview LOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * being loaded. Note: The same name must be used when the screenview
             * UNLOAD API is called.
             * @param {string} [referrerName] Name of the previous screenview that
             * is being replaced.
             * @param {object} [root] DOMNode which represents the root or
             * parent of this screenview. Usually this is a div container.
             * @returns {void}
             */
            logScreenviewLoad: function (name, referrerName, root) {

                if (!core.isInitialized()) {
                    return;
                }

                logScreenview("LOAD", name, referrerName, root);
            },

            /* Public API to create and add a screenview UNLOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * unloaded. Note: This should be the same name used in the screenview
             * LOAD API.
             * @returns {void}
             */
            logScreenviewUnload: function (name) {

                if (!core.isInitialized()) {
                    return;
                }

                logScreenview("UNLOAD", name);
            },

            /* Public API to log a DOM Capture message to the default queue.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            logDOMCapture: function (root, config) {
                var dcid = null,
                    domCaptureData,
                    domCaptureService,
                    msg,
                    queue;

                if (!this.isInitialized()) {
                    return dcid;
                }

                // DOM Capture is not supported on IE 8 and below
                if (core.utils.isLegacyIE) {
                    return dcid;
                }

                domCaptureService = this.getService("domCapture");
                if (domCaptureService) {
                    root = root || window.document;
                    config = config || {};
                    domCaptureData = domCaptureService.captureDOM(root, config);
                    if (domCaptureData) {
                        // Add the unique id for this DOM Capture message
                        dcid = config.dcid || ("dcid-" + this.utils.getSerialNumber() + "." + (new Date()).getTime());
                        domCaptureData.dcid = dcid;
                        // Create the message
                        msg = {
                            "type": 12,
                            "domCapture": domCaptureData
                        };
                        // POST it to the queue
                        queue = this.getService("queue");
                        queue.post("", msg, "DEFAULT");
                    } else {
                        dcid = null;
                    }
                }
                return dcid;
            },

            /* Function invoked by modules to log a DOM Capture message to the default queue.
             * @param {String} moduleName Name of the module which invoked this function.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            performDOMCapture: function (moduleName, root, config) {
                return this.logDOMCapture(root, config);
            },

            /**
             * Helper function for registerBridgeCallbacks
             * It checks if the call back type is valid and enabled.
             * @function
             * @private
             * @param {String}
             * @returns {boolean} Whether callback type is enabled.
             */
            _bridgeCallback: function (cbType) {
                var callBackType = bridgeCallbacks[cbType];

                if (callBackType && callBackType.enabled) {
                    return callBackType;
                }
                return null;
            },

            /**
             * Public API to add a screenshot capture. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            logScreenCapture: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("screenCapture");
                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to enable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            enableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("enableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to disable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            disableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("disableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start a new Tealeaf session. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            startNewTLFSession: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("startNewTLFSession");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start get current Tealeaf session Id. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {String} Current session Id
             */
            currentSessionId: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var sessionId,
                    bridgeCallback = core._bridgeCallback("currentSessionId");

                if (bridgeCallback !== null) {
                    sessionId = bridgeCallback.cbFunction();
                }
                return sessionId;
            },

            /**
             * Public API to get default value of a configurable item in
             * TLFConfigurableItems.properties file.  This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            defaultValueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    return;
                }
                var value,
                    bridgeCallback = core._bridgeCallback("defaultValueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to get the value of a configurable item either from TLFConfigurableItems.properties file
             * or in memory data structure. This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            valueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    return;
                }
                var value,
                    bridgeCallback = core._bridgeCallback("valueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to set the value of a configurable item in TLFConfigurableItems.properties file.
             * This updates only in the memory value. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            setConfigurableItem: function (configItem, value) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("setConfigurableItem");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(configItem, value);
                }
                return result;
            },

            /**
             * Public API to add additional http header.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} key This is the key of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            addAdditionalHttpHeader: function (key, value) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("addAdditionalHttpHeader");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(key, value);
                }
                return result;
            },

            /**
             * Public API to log custom event.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} eventName A custom event name.
             * @param {String} jsonData JSON data string.
             * @param {int} logLevel Tealeaf library logging level for the event.
             * @returns {boolean} Wether item was set.
             */
            logCustomEventBridge: function (eventName, jsonData, logLevel) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("logCustomEventBridge");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(eventName, jsonData, logLevel);
                }
                return result;
            },

            /**
             * Public API to allow registration of callback functions
             * These callback types are supported currently:
             * 1. screenCapture: Registering this type enables ability to
             *    take screenshots from script.
             * 2. messageRedirect: Registering this type will allow the
             *    callback function to process (and consume) the message
             *    instead of being handled by the default queue.
             * 3. addRequestHeaders: Registering this type will allow the
             *    callback function to return an array of HTTP request headers
             *    that will be set by the UIC in it's requests to the target.
             * @param {Array} callbacks Array of callback objects. Each object
             *                is of the format: {
             *                    {boolean}  enabled
             *                    {string}   cbType
             *                    {function} cbFunction
             *                }
             *                If the callbacks array is empty then any previously
             *                registered callbacks would be removed.
             * @returns {boolean} true if callbacks were registered. false otherwise.
             */
            registerBridgeCallbacks: function (callbacks) {
                var i = 0,
                    len = 0,
                    cb = null;

                // Sanity check
                if (!callbacks) {
                    return false;
                }
                if (callbacks.length === 0) {
                    // Reset any previously registered callbacks.
                    bridgeCallbacks = {};
                    return false;
                }
                try {
                    for (i = 0, len = callbacks.length; i < len; i += 1) {
                        cb = callbacks[i];
                        if (typeof cb === "object" && cb.cbType && cb.cbFunction) {
                            bridgeCallbacks[cb.cbType] = {
                                enabled: cb.enabled,
                                cbFunction: cb.cbFunction
                            };
                        }
                    }
                } catch (e) {
                    return false;
                }
                return true;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the queue to be redirected if a messageRedirect callback
             * has been registered. (see registerBridgeCallbacks)
             * @param {array} queue The queue array containing the individual
             *                message objects.
             * @returns {array} The array that should replace the previously
             *                  passed queue.
             */
            redirectQueue: function (queue) {
                var i,
                    len,
                    cb,
                    retval,
                    sS;

                // Sanity check
                if (!queue || !queue.length) {
                    return queue;
                }

                cb = bridgeCallbacks.messageRedirect;
                if (cb && cb.enabled) {
                    sS = core.getService("serializer");
                    for (i = 0, len = queue.length; i < len; i += 1) {
                        retval = cb.cbFunction(sS.serialize(queue[i]), queue[i]);
                        if (retval && typeof retval === "object") {
                            queue[i] = retval;
                        } else {
                            queue.splice(i, 1);
                            i -= 1;
                            len = queue.length;
                        }
                    }
                }
                return queue;
            },

            _hasSameOrigin: function (iframe) {
                try {
                    return iframe.document.location.host === document.location.host && iframe.document.location.protocol === document.location.protocol;
                } catch (e) {
                    // to be ignored. Error when iframe from different domain
                    //#ifdef DEBUG
                    //TODO add debug log
                    //#endif
                }
                return false;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the addRequestHeaders callback (if registered) to be invoked.
             * (see registerBridgeCallbacks)
             * @returns {array} The array of request headers to be set. Each
             *                  object is of the format:
             *                  {
             *                      name: "header name",
             *                      value: "header value",
             *                      recurring: true
             *                  }
             */
            provideRequestHeaders: function () {
                var headers = null,
                    addHeadersCB = bridgeCallbacks.addRequestHeaders;

                if (addHeadersCB && addHeadersCB.enabled) {
                    headers = addHeadersCB.cbFunction();
                }

                return headers;
            },

            /**
             * Utility function used by core._updateModules.
             * It registers event listners according to module configuration.
             * @name core._registerModuleEvents
             * @function
             * @param {string} moduleName name of the module
             * @param {Array} moduleEvents an array of all module-specific events (from UIC configuration)
             * @param {object} scope DOM element where event will be registered; points either to a main window
             *                 object or to IFrame's content window
             */
            _registerModuleEvents: (function () {

                /**
                 * An instance of core.utils.WeakMap us as a cache for mapping DOM elements with their IDs.
                 * Introduced to reduce number of expensive browserBase.ElementData.prototype.examineID calls.
                 * Object initialization in _registerModuleEvents function
                 * @private
                 * @type {object}
                 */
                var idCache,
                    /**
                     * Helper function that returns the localTop or documentScope object if the
                     * specified prop is "window" or "document" respectively.
                     * @private
                     * @function
                     * @param {string|object} prop
                     * @param {object} localTop
                     * @param {object} documentScope
                     * @returns {string|object} localTop if prop value is "window",
                     *                          documentScope if prop value is "document" else
                     *                          returns the prop value itself
                     */
                    normalizeToObject = function (prop, localTop, documentScope) {
                        if (prop === "window") {
                            return localTop;
                        }
                        if (prop === "document") {
                            return documentScope;
                        }
                        return prop;
                    };

                /**
                 * Helper function for core._registerModuleEvents
                 * It does actual event listeners registration, while the main function managesthe scopes.
                 * @function
                 * @private
                 */
                function _registerModuleEventsOnScope(moduleName, moduleEvents, scope) {
                    var browserBase = core.getService("browserBase"),
                        browser = core.getService("browser"),
                        documentScope = core.utils.getDocument(scope),
                        localTop = core._getLocalTop(),
                        isFrame = core.utils.isIFrameDescendant(scope),
                        frameId,
                        e,
                        i;

                    scope = scope || documentScope;
                    loadUnloadHandler.normalizeModuleEvents(moduleName, moduleEvents, localTop, documentScope);

                    if (isFrame) {
                        frameId = browserBase.ElementData.prototype.examineID(scope).id;
                        // remove one closing ']'
                        if (typeof frameId === "string") {
                            frameId = frameId.slice(0, frameId.length - 1);
                            for (e in events) {
                                if (events.hasOwnProperty(e)) {
                                    for (i = 0; i < events[e].length; i += 1) {
                                        if (moduleName === events[e][i]) {
                                            if (e.indexOf(frameId) !== -1) {
                                                delete events[e];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        var target = normalizeToObject(eventConfig.target, localTop, documentScope) || documentScope,
                            delegateTarget = normalizeToObject(eventConfig.delegateTarget, localTop, documentScope),
                            token = "";

                        if (eventConfig.recurseFrames !== true && isFrame) {
                            return;
                        }

                        // If the target is a string it is a CSS query selector, specified in the config.
                        if (typeof target === "string") {
                            if (eventConfig.delegateTarget && core.getFlavor() === "jQuery") {
                                token = core._buildToken4delegateTarget(eventConfig.name, target, eventConfig.delegateTarget);

                                if (!events.hasOwnProperty(token)) {
                                    events[token] = [moduleName];
                                    events[token].target = target;
                                    events[token].delegateTarget = delegateTarget;
                                    browser.subscribe(eventConfig.name, target, core._publishEvent, delegateTarget, token);
                                } else {
                                    events[token].push(moduleName);
                                }
                            } else {
                                core.utils.forEach(browser.queryAll(target, scope), function (element) {
                                    var idData = idCache.get(element);
                                    if (!idData) {
                                        idData = browserBase.ElementData.prototype.examineID(element);
                                        idCache.set(element, idData);
                                    }
                                    token = eventConfig.name + "|" + idData.id + idData.type;
                                    // If the token already exists, do nothing
                                    if (core.utils.indexOf(events[token], moduleName) !== -1) {
                                        return;
                                    }
                                    events[token] = events[token] || [];
                                    events[token].push(moduleName);
                                    // Save a reference to the tokens target to be able to unregister it later.
                                    events[token].target = element;
                                    browser.subscribe(eventConfig.name, element, core._publishEvent);
                                });
                            }
                        // Else: The target, specified in the config, is an object or empty
                        // (defaults to document), generate a token for events which bubble up
                        // (to the window or document object).
                        } else {
                            token = core._buildToken4bubbleTarget(eventConfig.name, target, typeof eventConfig.target === "undefined");
                            if (!events.hasOwnProperty(token)) {
                                events[token] = [moduleName];
                                browser.subscribe(eventConfig.name, target, core._publishEvent);
                            } else {
                                /* XXX: Only add if module entry doesn't exist. */
                                if (core.utils.indexOf(events[token], moduleName) === -1) {
                                    events[token].push(moduleName);
                                }
                            }
                        }

                        if (token !== "") {
                            if (typeof target !== "string") {
                                events[token].target = target;
                            }
                        }
                    });
                }

                /**
                 * Helper function for core._registerModuleEvents. Checks load status of iframes.
                 * @function
                 * @private
                 * @returns {boolean} true when given frame is completely loaded; false otherwise
                 */
                function _isFrameLoaded(hIFrame) {
                    var iFrameWindow = core.utils.getIFrameWindow(hIFrame);
                    return (iFrameWindow !== null) &&
                            core._hasSameOrigin(iFrameWindow) &&
                            (iFrameWindow.document !== null) &&
                            iFrameWindow.document.readyState === "complete";
                }

                // actual implementation of core._registerModuleEvents
                function registerModuleEvents(moduleName, moduleEvents, scope) {
                    scope = scope || core._getLocalTop().document;
                    idCache = idCache || new core.utils.WeakMap();

                    _registerModuleEventsOnScope(moduleName, moduleEvents, scope);
                    if (moduleName !== "performance") {
                        var hIFrame = null,
                            hIFrameWindow = null,
                            browserService = core.getService("browser"),
                            cIFrames = browserService.queryAll("iframe, frame", scope),
                            i,
                            iLength;

                        for (i = 0, iLength = cIFrames.length; i < iLength; i += 1) {
                            hIFrame = cIFrames[i];
                            if (isFrameBlacklisted(hIFrame)) {
                                continue;
                            }
                            if (_isFrameLoaded(hIFrame)) {
                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                            }

                            (function (moduleName, moduleEvents, hIFrame) {
                                var hIFrameWindow = null,
                                    _iframeContext = {
                                        moduleName: moduleName,
                                        moduleEvents: moduleEvents,
                                        hIFrame: hIFrame,

                                        _registerModuleEventsDelayed: function () {
                                            var hIFrameWindow = null;

                                            if (!isFrameBlacklisted(hIFrame)) {
                                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                                if (core._hasSameOrigin(hIFrameWindow)) {
                                                    core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                                                }
                                            }
                                        }
                                    };

                                core.utils.addEventListener(hIFrame, "load", function () {
                                    _iframeContext._registerModuleEventsDelayed();
                                });

                                if (core.utils.isLegacyIE && _isFrameLoaded(hIFrame)) {
                                    hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                    core.utils.addEventListener(hIFrameWindow.document, "readystatechange", function () {
                                        _iframeContext._registerModuleEventsDelayed();
                                    });
                                }

                            }(moduleName, moduleEvents, hIFrame));
                        }
                    }
                }

                registerModuleEvents.clearCache = function () {
                    if (idCache) {
                        idCache.clear();
                        idCache = null;
                    }
                };

                return registerModuleEvents;
            }()), // end of _registerModuleEvents factory


            /**
             * Build the token for an event using the currentTarget of the event
             * (only if the current browser supports currenTarget) Otherwise uses
             * the event.target
             * @param  {Object} event The WebEvent
             * @return {String}       Returns the token as a string, consist of:
             *         eventType | target id target idtype
             */
            _buildToken4currentTarget: function (event) {
                var target = event.nativeEvent ? event.nativeEvent.currentTarget : null,
                    idData = target ? this.getService("browserBase").ElementData.prototype.examineID(target) :
                            {
                                id: event.target.id,
                                type: event.target.idType
                            };
                return event.type + "|" + idData.id + idData.type;
            },

            /**
             * Build the token for delegate targets
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | target | delegateTarget
             */
            _buildToken4delegateTarget: function (eventType, target, delegateTarget) {
                return eventType + "|" + target + "|" + delegateTarget;
            },

            /**
             * Build the token for bubble targets (either window or document)
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | null-2 | window or document
             */
            _buildToken4bubbleTarget: function (eventType, target, checkIframe, delegateTarget) {
                var localTop = core._getLocalTop(),
                    localWindow,
                    browserService = core.getService("browser"),
                    _getIframeElement = function (documentScope) {
                        var retVal = null;

                        if (core._hasSameOrigin(localWindow.parent)) {
                            core.utils.forEach(browserService.queryAll("iframe, frame", localWindow.parent.document), function (iframe) {
                                var iFrameWindow = null;

                                if (!isFrameBlacklisted(iframe)) {
                                    iFrameWindow = core.utils.getIFrameWindow(iframe);
                                    if (core._hasSameOrigin(iFrameWindow) && iFrameWindow.document === documentScope) {
                                        retVal = iframe;
                                    }
                                }
                            });
                        }
                        return retVal;
                    },
                    documentScope = core.utils.getDocument(target),
                    browserBase = this.getService("browserBase"),
                    iframeElement = null,
                    tmpTarget,
                    retVal = eventType,
                    idData;

                if (documentScope) {
                    localWindow = documentScope.defaultView || documentScope.parentWindow;
                }

                if (target === window || target === window.window) {
                    retVal += "|null-2|window";
                } else {
                    if (checkIframe && localWindow && core._hasSameOrigin(localWindow.parent) && typeof documentScope !== "undefined" && localTop.document !== documentScope) {
                        iframeElement = _getIframeElement(documentScope);
                        if (iframeElement) {
                            tmpTarget = browserBase.ElementData.prototype.examineID(iframeElement);
                            retVal += "|" + tmpTarget.xPath + "-2";
                        }
                    } else if (delegateTarget && delegateTarget !== document && core.getFlavor() === "jQuery") {
                        // NOTE: elegateTarget !== document  --- because simple jQuery.on has delegateTarget set to document
                        // for event defined without target e.g. { name: "click", recurseFrame: true }
                        retVal += "|null-2|" + core.utils.getTagName(target) + "|" + core.utils.getTagName(delegateTarget);
                    } else {
                        retVal += "|null-2|document";
                    }
                }

                return retVal;
            },

            /**
             * Event handler for when configuration gets updated.
             * @returns {void}
             * @private
             */
            _reinitConfig: function () {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.
                core._updateModules();
            },

            /**
             * Iterates over each module delivers the event object if the module
             * is interested in that event.
             * @param {Event} event An event object published by the browser service.
             * @returns {void}
             * @private
             */
            _publishEvent: function (event) {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.

                var moduleName = null,
                    module = null,
                    // generate the explicit token for the element which received the event
                    // if event is delegated it will have event.data set to the token
                    token = (event.delegateTarget && event.data) ? event.data : core._buildToken4currentTarget(event),
                    modules = null,
                    i,
                    len,
                    target,
                    modEvent = null,
                    canIgnore = false,
                    canPublish = false,
                    coreConfig = core.getCoreConfig(),
                    browserService = core.getService("browser"),
                    delegateTarget = event.delegateTarget || null;

                // Reset the inactivity timer
                if (inactivityTimerId) {
                    clearTimeout(inactivityTimerId);
                }
                // Set inactivity timeout with default of 10 minutes.
                inactivityTimerId = setTimeout(inactivityTimeoutHandler, core.utils.getValue(coreConfig, "inactivityTimeout", 600000));

                // ignore native browser 'load' events
                if ((event.type === "load" || event.type === "pageshow") && !event.nativeEvent.customLoad) {
                    return;
                }

                // IE only: ignore 'beforeunload' fired by link placed in blacklist of excluded links
                if (core.utils.isIE) {
                    if (event.type === "click") {
                        lastClickedElement = event.target.element;
                    }
                    if (event.type === "beforeunload") {
                        canIgnore = false;
                        core.utils.forEach(coreConfig.ieExcludedLinks, function (selector) {
                            var i,
                                len,
                                el = browserService.queryAll(selector);

                            for (i = 0, len = el ? el.length : 0; i < len; i += 1) {
                                if (typeof el[i] !== undefined && el[i] === lastClickedElement) {
                                    // Last clicked element was in the blacklist. Set the ignore flag.
                                    canIgnore = true;
                                    return;
                                }
                            }
                        });

                        if (canIgnore) {
                            // The beforeunload can be ignored.
                            return;
                        }
                    }
                }

                // if an unload event is triggered update the core's internal state to "unloading"
                if (loadUnloadHandler.isUnload(event)) {
                    state = "unloading";
                }

                // ignore native browser 'change' events on IE<9/W3C for radio buttons and checkboxes
                if (event.type === "change" && core.utils.isLegacyIE && core.getFlavor() === "w3c" &&
                        (event.target.element.type === "checkbox" || event.target.element.type === "radio")) {
                    return;
                }

                // use 'propertychange' event in IE<9 to simulate 'change' event on radio and checkbox
                if (event.type === "propertychange") {
                    if (event.nativeEvent.propertyName === "checked" && (event.target.element.type === "checkbox" || (event.target.element.type === "radio" && event.target.element.checked))) {
                        event.type = "change";
                        event.target.type = "INPUT";
                    } else {
                        return;
                    }
                }

                // No module has registered the event for the currentTarget,
                // build token for bubble target (document or window)
                if (!events.hasOwnProperty(token)) {
                    if (event.hasOwnProperty("nativeEvent")) {
                        target = event.nativeEvent.currentTarget || event.nativeEvent.target;
                    }
                    token = core._buildToken4bubbleTarget(event.type, target, true, delegateTarget);
                }

                if (events.hasOwnProperty(token)) {
                    modules = events[token];
                    for (i = 0, len = modules.length; i < len; i += 1) {
                        moduleName = modules[i];
                        module = core.getModule(moduleName);
                        modEvent = core.utils.mixin({}, event);
                        if (module && core.isStarted(moduleName) && typeof module.onevent === "function") {
                            canPublish = loadUnloadHandler.canPublish(moduleName, modEvent);
                            if (canPublish) {
                                module.onevent(modEvent);
                            }
                        }
                    }
                }

                if (modEvent && modEvent.type === "unload" && canPublish) {
                    core.destroy();
                }

            },

            _getLocalTop: function () {
                // Return window.window instead of window due to an IE quirk where (window == top) is true but (window === top) is false
                // In such cases, (window.window == top) is true and so is (window.window === top)  Hence window.window is more reliable
                // to compare to see if the library is included in the top window.
                return window.window;
            },

            //---------------------------------------------------------------------
            // Module Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a module creator with TLT.
             * @param {String} moduleName The name of the module that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the module.
             * @returns {void}
             */
            addModule: function (moduleName, creator) {


                modules[moduleName] = {
                    creator: creator,
                    instance: null,
                    context: null,
                    messages: []
                };

                // If the core is initialized, then this module has been dynamically loaded. Start it.
                if (this.isInitialized()) {
                    this.start(moduleName);
                }
            },

            /**
             * Returns the module instance of the given module.
             * @param {String} moduleName The name of the module to retrieve.
             * @returns {Object} The module instance if it exists, null otherwise.
             */
            getModule: function (moduleName) {
                if (modules[moduleName] && modules[moduleName].instance) {
                    return modules[moduleName].instance;
                }
                return null;
            },

            /**
             * Unregisters a module and stops and destroys its instance.
             * @param {String} moduleName The name of the module to remove.
             * @returns {void}
             */
            removeModule: function (moduleName) {

                this.stop(moduleName);
                delete modules[moduleName];
            },

            /**
             * Determines if a module is started by looking for the instance.
             * @param {String} moduleName The name of the module to check.
             * @returns {void}
             */
            isStarted: function (moduleName) {
                return modules.hasOwnProperty(moduleName) && modules[moduleName].instance !== null;
            },

            /**
             * Creates a new module instance and calls it's init() method.
             * @param {String} moduleName The name of the module to start.
             * @returns {void}
             */
            start: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;


                // Only continue if the module data exists and there's not already an instance
                if (moduleData && moduleData.instance === null) {

                    // create the context and instance
                    moduleData.context = new TLT.ModuleContext(moduleName, this);
                    instance = moduleData.instance = moduleData.creator(moduleData.context);

                    // allow module to initialize itself
                    if (typeof instance.init === "function") {
                        instance.init();
                    }

                }
            },

            /**
             * Starts all registered modules, creating an instance and calling their
             * init() methods.
             * @returns {void}
             */
            startAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.start(moduleName);
                    }
                }
            },

            /**
             * Stops a module, calls it's destroy() method, and deletes the instance.
             * @param {String} moduleName The name of the module to stop.
             * @returns {void}
             */
            stop: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                // Only continue if the module instance exists
                if (moduleData && moduleData.instance !== null) {

                    instance = moduleData.instance;

                    // allow module to clean up after itself
                    if (typeof instance.destroy === "function") {
                        instance.destroy();
                    }

                    moduleData.instance = moduleData.context = null;

                }
            },

            /**
             * Stops all registered modules, calling their destroy() methods,
             * and removing their instances.
             * @returns {void}
             */
            stopAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.stop(moduleName);
                    }
                }
            },

            //---------------------------------------------------------------------
            // Service Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a service creator with TLT.
             * @param {String} serviceName The name of the service that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the service.
             * @returns {void}
             */
            addService: function (serviceName, creator) {


                services[serviceName] = {
                    creator: creator,
                    instance: null
                };
            },

            /**
             * Retrieves a service instance, creating it if one doesn't already exist.
             * @param {String} serviceName The name of the service to retrieve.
             * @returns {Object} The service object as returned from the service
             *      creator or null if the service doesn't exist.
             */
            getService: function (serviceName) {
                if (services.hasOwnProperty(serviceName)) {
                    if (!services[serviceName].instance) {
                        // If you want to have a separate ServiceContext, pass it here instead of "this"
                        try {
                            services[serviceName].instance = services[serviceName].creator(this);
                            if (typeof services[serviceName].instance.init === "function") {
                                services[serviceName].instance.init();
                            }
                        } catch (e) {
                            // shut the library down if jQuery or sizzle is not found / not supported
                            return null;
                        }
                        if (typeof services[serviceName].instance.getServiceName !== "function") {
                            services[serviceName].instance.getServiceName = function () {
                                return serviceName;
                            };
                        }
                    }
                    return services[serviceName].instance;
                }
                return null;
            },

            /**
             * Unregisters a service and destroys its instance.
             * @param {String} serviceName The name of the service to remove.
             * @returns {void}
             */
            removeService: function (serviceName) {
                delete services[serviceName];
            },

            //---------------------------------------------------------------------
            // Intermodule Communication
            //---------------------------------------------------------------------

            /**
             * Broadcasts a message throughout the system to all modules who are
             * interested.
             * @param {Object} message An object containing at least a type property
             *      indicating the message type.
             * @returns {void}
             */
            broadcast: function (message) {
                var i = 0,
                    len = 0,
                    prop = null,
                    module = null;

                if (message && typeof message === "object") {


                    for (prop in modules) {
                        if (modules.hasOwnProperty(prop)) {
                            module = modules[prop];

                            if (core.utils.indexOf(module.messages, message.type) > -1) {
                                if (typeof module.instance.onmessage === "function") {
                                    module.instance.onmessage(message);
                                }
                            }
                        }
                    }
                }
            },

            /**
             * Instructs a module to listen for a particular type of message.
             * @param {String} moduleName The module that's interested in the message.
             * @param {String} messageType The type of message to listen for.
             * @returns {void}
             */
            listen: function (moduleName, messageType) {
                var module = null;

                if (this.isStarted(moduleName)) {
                    module = modules[moduleName];

                    if (core.utils.indexOf(module.messages, messageType) === -1) {
                        module.messages.push(messageType);
                    }
                }
            },
            /**
             * Stops UIC and throws an error.
             * @function
             * @throws {UICError}
             */
            fail: function (message, failcode, skipEvents) {
                message = "UIC FAILED. " + message;
                try {
                    core.destroy(!!skipEvents);
                } finally {
                    core.utils.clog(message);
                    throw new core.UICError(message, failcode);
                }
            },

            /**
             * @constructor
             */
            UICError: (function () {
                function UICError(message, errorCode) {
                    this.message = message;
                    this.code = errorCode;
                }
                UICError.prototype = new Error();
                UICError.prototype.name = "UICError";
                UICError.prototype.constructor = UICError;
                return UICError;
            }()),


            /**
             * Return the name of UIC flavor ("w3c" or "jQuery")
             * @function
             */
            getFlavor: function () {
                // TODO: Use the existing browserService method here
                return "jQuery";
            }
        };

    /**
     * Inactivity timeout handler function. When the timer expires,
     * log an exception message indicating the timeout and shutdown.
     * @private
     */
    inactivityTimeoutHandler = function () {
        core.logExceptionEvent("Inactivity timeout.");
        core.destroy();
    }

    /**
     * Actual init function called from TLT.init when the DOM is ready.
     * @private
     * @see TLT.init
     */
    _init = function (config, callback) {
        var configService,
            event,
            webEvent,
            baseBrowser,
            browserService;

        if (initialized) {
            core.utils.clog("TLT.init() called more than once. Ignoring.");
            return;
        }

        // Do not initialize if replay is enabled.
        if (TLT && TLT.replay) {
            return;
        }

        configService = core.getService("config");
        configService.updateConfig(config);

        if (!core._updateModules()) {
            if (state !== "destroyed") {
                core.destroy();
            }
            return;
        }

        if (configService.subscribe) {
            configService.subscribe("configupdated", core._reinitConfig);
        }

        initialized = true;
        state = "loaded";

        //generate fake load event to send for modules
        event = {
            type: 'load',
            target: window.window,
            srcElement: window.window,
            currentTarget: window.window,
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            timeStamp: +new Date(),
            customLoad: true
        };

        baseBrowser = core.getService("browserBase");
        webEvent = new baseBrowser.WebEvent(event);
        core._publishEvent(webEvent);

        if (typeof _callback === "function") {
            // Protect against unexpected exceptions since _callback is 3rd party code.
            try {
                _callback("initialized");
            } catch (e) {
                // Do nothing!
            }
        }
    };

    // Add methods that passthrough to services
    (function () {

        var name = null,
            i,
            len;

        for (name in servicePassthroughs) {
            if (servicePassthroughs.hasOwnProperty(name)) {
                for (i = 0, len = servicePassthroughs[name].length; i < len; i += 1) {
                    (function (serviceName, methodName) {
                        core[methodName] = function () {
                            var service = this.getService(serviceName);
                            if (service) {
                                return service[methodName].apply(service, arguments);
                            }
                        };
                    }(name, servicePassthroughs[name][i]));

                }
            }
        }

    }());

    return core;
}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines utility functions available to all modules via context object or as TLT.utils
 * @exports TLT.utils
 */

/*global TLT, window*/
/*jshint loopfunc:true*/

(function () {

    "use strict";

    var ua = window.navigator.userAgent.toLowerCase(),

        _isIE = (ua.indexOf("msie") !== -1),

        _isLegacyIE = (function () {
            // W3 Navigation timing spec. supported from IE 9 onwards.
            var isNavTimingSupported = !!window.performance;
            return (_isIE && (!isNavTimingSupported || document.documentMode < 9));
        }()),

        _isAndroid = (ua.indexOf("android") !== -1),

        _isiOS = /(ipad|iphone|ipod)/.test(ua),

        tltUniqueIndex = 1,

        utils = {
            /**
             * Indicates if browser is IE.
             */
            isIE: _isIE,

            /**
             * Indicates if browser is IE<9 or IE 9+ running in
             * compatibility mode.
             */
            isLegacyIE: _isLegacyIE,

            /**
             * Indicates if the browser is based on an Android platform device.
             */
            isAndroid: _isAndroid,

            /**
             * Indicates if the browser is based on an iOS platform device.
             */
            isiOS: _isiOS,

            /**
             * Checks whether given parameter is null or undefined
             * @param {*} obj Any value
             * @returns {boolean} True if obj is null or undefined; false otherwise
             */
            isUndefOrNull: function (obj) {
                return typeof obj === "undefined" || obj === null;
            },

            /**
             * Returns a unique serial number
             * @returns {int} A number that can be used as a unique identifier.
             */
            getSerialNumber: function () {
                var id;

                id = tltUniqueIndex;
                tltUniqueIndex += 1;

                return id;
            },

            /**
             * Used to test and get value from an object.
             * @private
             * @function
             * @name core.utils.getValue
             * @param {object} parentObj An object you want to get a value from.
             * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
             * @param {object|String|Number} [defaultValue] The default value to be returned if the property is not found.
             * @return {object} If object is found, if not then default value will be returned. If the default value is
             * not defined then null will be returned.
             */
            getValue: function (parentObj, propertyAsStr, defaultValue) {
                var i,
                    len,
                    properties;

                defaultValue = defaultValue || null;

                // Sanity check
                if (!parentObj || typeof parentObj !== "object" || typeof propertyAsStr !== "string") {
                    return defaultValue;
                }

                properties = propertyAsStr.split(".");
                for (i = 0, len = properties.length; i < len; i += 1) {
                    if (this.isUndefOrNull(parentObj) || typeof parentObj[properties[i]] === "undefined") {
                        return defaultValue;
                    }
                    parentObj = parentObj[properties[i]];
                }
                return parentObj;
            },

            /**
             * Helper function to find an item in an array.
             * @param {Array} array The array to search.
             * @param {String} item The item to search for.
             * @returns {int} The index of the item if found, -1 if not.
             */
            indexOf: function (array, item) {
                var i,
                    len;

                if (array && array instanceof Array) {
                    for (i = 0, len = array.length; i < len; i += 1) {
                        if (array[i] === item) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            /**
             * Invokes callback for each element of an array.
             * @param {Array} array The array (or any indexable object) to walk through
             * @param {function} callback Callback function
             * @param {object} [context] context object; if not provided global object will be considered
             */
            forEach: function (array, callback, context) {
                var i,
                    len;

                // Sanity checks
                if (!array || !array.length || !callback || !callback.call) {
                    return;
                }

                for (i = 0, len = array.length; i < len; i += 1) {
                    callback.call(context, array[i], i, array);
                }
            },

            /**
             * Returns true if callback returns true at least once. Callback is
             * called for each array element unless it reaches end of array or
             * returns true.
             * @param {object} array An Array or any indexable object to walk through
             * @param {function} callback A callback function
             * @returns {boolean} True if callback returned true at least once; false otherwise
             */
            some: function (array, callback) {
                var i,
                    len,
                    val = false;

                for (i = 0, len = array.length; i < len; i += 1) {
                    val = callback(array[i], i, array);
                    if (val) {
                        return val;
                    }
                }
                return val;
            },

            /**
             * Converts an arguments object into an array. This is used to augment
             * the arguments passed to the TLT methods used by the Module Context.
             * @param {Arguments} items An array-like collection.
             * @return {Array} An array containing the same items as the collection.
             */
            convertToArray: function (items) {
                var i = 0,
                    len = items.length,
                    result = [];

                while (i < len) {
                    result.push(items[i]);
                    i += 1;
                }

                return result;
            },

            mixin: function (dst) {
                var prop,
                    src,
                    srcId,
                    len;

                for (srcId = 1, len = arguments.length; srcId < len; srcId += 1) {
                    src = arguments[srcId];
                    for (prop in src) {
                        if (Object.prototype.hasOwnProperty.call(src, prop)) {
                            dst[prop] = src[prop];
                        }
                    }
                }
                return dst;
            },

            extend: function (deep, target, src) {
                var prop = "";

                for (prop in src) {
                    if (Object.prototype.hasOwnProperty.call(src, prop)) {
                        if (deep && Object.prototype.toString.call(src[prop]) === "[object Object]") {
                            if (typeof target[prop] === "undefined") {
                                target[prop] = {};
                            }
                            utils.extend(deep, target[prop], src[prop]);
                        } else {
                            target[prop] = src[prop];
                        }
                    }
                }
                return target;
            },

            /**
             * Makes copy of an object.
             * @function
             * @name core.utils.clone
             * @param {object} obj A object that will be cloned.
             * @return {object} Object cloned.
             */
            clone: function (obj) {
                var copy,
                    attr;

                if (null === obj || "object" !== typeof obj) {
                    return obj;
                }

                if (obj instanceof Object) {
                    copy = (Object.prototype.toString.call(obj) === "[object Array]") ? [] : {};
                    for (attr in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, attr)) {
                            copy[attr] = utils.clone(obj[attr]);
                        }
                    }
                    return copy;
                }
            },

            /**
             *
             */
            createObject: (function () {
                var fn = null,
                    F = null;
                if (typeof Object.create === "function") {
                    fn = Object.create;
                } else {
                    F = function () {};
                    fn = function (o) {
                        if (typeof o !== "object" && typeof o !== "function") {
                            throw new TypeError("Object prototype need to be an object!");
                        }
                        F.prototype = o;
                        return new F();
                    };
                }
                return fn;
            }()),

            /**
             * Method access the object element based on a string. By default it searches starting from window object.
             * @function
             * @example core.utils.access("document.getElementById");
             * @example core.utils.access("address.city", person);
             * @param {string} path Path to object element. Currently on dot separators are supported (no [] notation support)
             * @param {object} [rootObj=window] Root object where there search starts. window by default
             * @return {*} Object element or undefined if the path is not valid
             */
            access: function (path, rootObj) {
                var obj = rootObj || window,
                    arr,
                    i,
                    len;

                if (typeof path !== "string" || (typeof obj !== "object" && obj !== null)) {
                    return;
                }
                arr = path.split(".");
                for (i = 0, len = arr.length; i < len; i += 1) {
                    if (i === 0 && arr[i] === "window") {
                        continue;
                    }
                    if (!Object.prototype.hasOwnProperty.call(obj, arr[i])) {
                        return;
                    }
                    obj = obj[arr[i]];
                    if (i < (len - 1) && !(obj instanceof Object)) {
                        return;
                    }
                }
                return obj;
            },

            /**
             * Checks if a given character is numeric.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the given character is a number.
             */
            isNumeric: function (character) {
                return !isNaN(character + 1 - 1);
            },

            /**
             * Checks if a given character is uppercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is uppercase.
             *                        Otherwise false.
             */
            isUpperCase: function (character) {
                return character === character.toUpperCase() &&
                        character !== character.toLowerCase();
            },

            /**
             * Checks if a given character is lowercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is lowercase.
             *                        Otherwise false.
             */
            isLowerCase: function (character) {
                return character === character.toLowerCase() &&
                        character !== character.toUpperCase();
            },

            getDocument: function (node) {
                if (node.nodeType !== 9) {
                    return (!utils.isUndefOrNull(node.ownerDocument)) ? (node.ownerDocument) : (node.document);
                }
                return node;
            },

            getWindow: function (node) {
                if (node.self !== node) {
                    var ownerDocument = utils.getDocument(node);
                    return (!utils.isUndefOrNull(ownerDocument.defaultView)) ? (ownerDocument.defaultView) : (ownerDocument.parentWindow);
                }
                return node;
            },

            /**
             * Given a HTML frame element, returns the window object of the frame. Tries the contentWindow property
             * first. If contentWindow is not accessible, tries the contentDocument.parentWindow property instead.
             * @param {Object} iFrameElement The HTML frame element object.
             * @return {Object} Returns the window object of the frame element or null.
             */
            getIFrameWindow: function (iFrameElement) {
                var contentWindow = null;

                if (!iFrameElement) {
                    return contentWindow;
                }

                try {
                    contentWindow = iFrameElement.contentWindow ||
                        (iFrameElement.contentDocument ? iFrameElement.contentDocument.parentWindow : null);
                } catch (e) {
                    // Do nothing.
                }

                return contentWindow;
            },

            getTagName: function (node) {
                if (node === document) {
                    return "document";
                }
                if (node === window || node === window.window) {
                    return "window";
                }
                if (typeof node === "string") {
                    return node.toLowerCase();
                }
                if (typeof node === "object" && !utils.isUndefOrNull(node) && typeof node.tagName === "string") {
                    return node.tagName.toLowerCase();
                }
                return "";
            },

            /**
             * Returns true if given node is element from a frame
             * @private
             * @param {Element} node DOM element
             * @return {boolean} true if input element is element from a frame; false otherwise
             */
            isIFrameDescendant: function (node) {
                /*jshint eqeqeq:false, eqnull: false */
                /* The != operator below is on purpose due to legacy IE issues, where:
                   window === top returns false, but window == top returns true */
                return utils.getWindow(node) != TLT._getLocalTop();
            },

            /**
             * Takes the orientation in degrees and returns the orientation mode as a
             * text string. 0, 180 and 360 correspond to portrait mode while 90, -90
             * and 270 correspond to landscape.
             * @function
             * @name core.utils.getOrientationMode
             * @param {number} orientation A normalized orientation value such as
             *          0, -90, 90, 180, 270, 360.
             * @return {string} "PORTRAIT" or "LANDSCAPE" for known orientation values.
             * "UNKNOWN" for unrecognized values. "INVALID" in case of error.
             */
            getOrientationMode: function (orientation) {
                var mode = "INVALID";

                if (typeof orientation !== "number") {
                    return mode;
                }

                switch (orientation) {
                case 0:
                case 180:
                case 360:
                    mode = "PORTRAIT";
                    break;
                case 90:
                case -90:
                case 270:
                    mode = "LANDSCAPE";
                    break;
                default:
                    mode = "UNKNOWN";
                    break;
                }

                return mode;
            },

            clog: (function (window) {
                return function () {
                    // Do nothing!
                };
            }(window)),

            /**
             * Trims any whitespace and returns the trimmed string.
             * @function
             * @name core.utils.trim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            trim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+|\s+$/g, "");
            },

            /**
             * Trims any whitespace at the beginning of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.ltrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            ltrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+/, "");
            },

            /**
             * Trims any whitespace at the end of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.rtrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            rtrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/\s+$/, "");
            },

            /**
             * Finds and returns the named cookie's value.
             * @function
             * @name core.utils.getCookieValue
             * @param {string} cookieName The name of the cookie.
             * @param {string} [cookieString] Optional cookie string in which to search for cookieName.
             * If none is specified, then document.cookie is used by default.
             * @return {string} The cookie value if a match is found or null.
             */
            getCookieValue: function (cookieName, cookieString) {
                var i,
                    len,
                    cookie,
                    cookies,
                    cookieValue = null,
                    cookieNameLen;

                try {
                    cookieString = cookieString || document.cookie;

                    // Sanity check.
                    if (!cookieName || !cookieName.toString) {
                        return null;
                    }

                    // Append an '=' to the cookie name
                    cookieName += "=";
                    cookieNameLen = cookieName.length;

                    // Get the individual cookies into an array and look for a match
                    cookies = cookieString.split(';');
                    for (i = 0, len = cookies.length; i < len; i += 1) {
                        cookie = cookies[i];
                        cookie = utils.ltrim(cookie);

                        // Check if cookieName matches the current cookie prefix.
                        if (cookie.indexOf(cookieName) === 0) {
                            // Match found! Get the value (i.e. RHS of "=" sign)
                            cookieValue = cookie.substring(cookieNameLen, cookie.length);
                            break;
                        }
                    }
                } catch (e) {
                    cookieValue = null;
                }

                return cookieValue;
            },

            /**
             * Finds and returns the query parameter's value.
             * @function
             * @name core.utils.getQueryStringValue
             * @param {string} paramName The name of the query parameter.
             * @param {string} [queryDelim] The query string delimiter. Either ";" or "&"
             * @param {string} [queryString] Optional query string in which to search for the query parameter.
             * If none is specified, then document.location.search is used by default.
             * @return {string} The query parameter value if a match is found or null.
             */
            getQueryStringValue: function (paramName, queryDelim, queryString) {
                var i,
                    j,
                    queryStringLen,
                    paramValue = null,
                    valueStartIndex;

                try {
                    queryString = queryString || window.location.search;
                    queryStringLen = queryString.length;

                    // Sanity check.
                    if (!paramName || !paramName.toString || !queryStringLen) {
                        return null;
                    }

                    // Default delimiter is &
                    queryDelim = queryDelim || "&";
                    // Normalize for easy searching by replacing initial '?' with the delimiter
                    queryString = queryDelim + queryString.substring(1);
                    // Modify the parameter name to prefix the delimiter and append an '='
                    paramName = queryDelim + paramName + "=";

                    i = queryString.indexOf(paramName);
                    if (i !== -1) {
                        valueStartIndex = i + paramName.length;
                        // Match found! Get the value (i.e. RHS of "=" sign upto the delim or end of string)
                        j = queryString.indexOf(queryDelim, valueStartIndex);
                        if (j === -1) {
                            j = queryStringLen;
                        }
                        paramValue = decodeURIComponent(queryString.substring(valueStartIndex, j));
                    }
                } catch (e) {
                    // Do nothing!
                }

                return paramValue;
            },

            /**
             * Quick wrapper for addEventL:istener/attachEvent. Mainly to be used for core, before UIC is fully
             * initialized
             * @function
             * @name core.util.addEventListener
             */
            addEventListener: (function () {
                if (window.addEventListener) {
                    return function (element, eventName, listener) {
                        element.addEventListener(eventName, listener, false);
                    };
                }
                return function (element, eventName, listener) {
                    element.attachEvent("on" + eventName, listener);
                };
            }()),

            /**
             * Returns the index of the rule that is matched by the target object.
             * @function
             * @name core.utils.matchTarget
             * @param {Array} rules An array of match rules containing objects such as
             * {id, idType} or { { regex }, idType } or a string representing "CSS Selectors"
             * @param {Object} target  The normalized target object of the message.
             * @return {int} Returns the index of the matching rule. If none of the rules match then returns -1.
             */
            matchTarget: function (rules, target) {
                var i,
                    j,
                    matchIndex = -1,
                    qr,
                    qrLen,
                    qrTarget,
                    regex,
                    len,
                    rule;

                // Sanity check
                if (!rules || !target) {
                    return matchIndex;
                }

                if (!this.browserService || !this.browserBaseService) {
                    this.browserService = TLT.getService("browser");
                    this.browserBaseService = TLT.getService("browserBase");
                }

                for (i = 0, len = rules.length; i < len && matchIndex === -1; i += 1) {
                    rule = rules[i];

                    // Check if rule is a selector string.
                    if (typeof rule === "string") {
                        qr = this.browserService.queryAll(rule);
                        for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                            if (qr[j]) {
                                qrTarget = this.browserBaseService.ElementData.prototype.examineID(qr[j]);
                                if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                                    matchIndex = i;
                                    break;
                                }
                            }
                        }
                    } else if (rule.id && rule.idType && target.idType.toString() === rule.idType.toString()) {
                        // Note: idType provided by wizard is a string so convert both to strings before comparing.

                        // An id in the rules list could be a direct match, in which case it will be a string OR
                        // it could be a regular expression in which case it would be an object like this:
                        // {regex: ".+private$", flags: "i"}
                        switch (typeof rule.id) {
                        case "string":
                            if (rule.id === target.id) {
                                matchIndex = i;
                            }
                            break;
                        case "object":
                            regex = new RegExp(rule.id.regex, rule.id.flags);
                            if (regex.test(target.id)) {
                                matchIndex = i;
                            }
                            break;
                        }
                    }
                }
                return matchIndex;
            },

            /**
             * Basic WeakMap implementation - a map which can be indexed with objects.
             * In comparison to the original API 'delete' method has been replaced with 'remove'
             * due to compatibility with legacy IE
             * @constructor
             * @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/WeakMap
             */
            WeakMap: (function () {
                function index(data, key) {
                    var i,
                        len;
                    data = data || [];
                    for (i = 0, len = data.length; i < len; i += 1) {
                        if (data[i][0] === key) {
                            return i;
                        }
                    }
                    return -1;
                }
                return function () {
                    var data = [];
                    this.set = function (key, val) {
                        var idx = index(data, key);
                        data[idx > -1 ? idx : data.length] = [key, val];
                    };
                    this.get = function (key) {
                        var arr = data[index(data, key)];
                        return (arr ? arr[1] : undefined);
                    };
                    this.clear = function () {
                        data = [];
                    };
                    this.has = function (key) {
                        return (index(data, key) >= 0);
                    };
                    this.remove = function (key) {
                        var idx = index(data, key);
                        if (idx >= 0) {
                            data.splice(idx, 1);
                        }
                    };
                    this["delete"] = this.remove;
                };
            }())
        };


    if (typeof TLT === "undefined" || !TLT) {
        window.TLT = {};
    }

    TLT.utils = utils;

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines a simple event target interface that can be inherited
 *      from by other parts of the system.
 * @exports TLT.EventTarget
 */
/*global TLT*/

(function () {

    "use strict";

    /**
     * Abstract type that implements basic event handling capabilities.
     * Other types may inherit from this in order to provide custom
     * events.
     * @constructor
     */
    TLT.EventTarget = function () {

        /**
         * Holds all registered event handlers. Each property represents
         * a specific event, each property value is an array containing
         * the event handlers for that event.
         * @type Object
         */
        this._handlers = {};

    };

    TLT.EventTarget.prototype = {

        /**
         * Restores the constructor to the correct value.
         * @private
         */
        constructor: TLT.EventTarget,

        /**
         * Publishes an event with the given name, which causes all
         * event handlers for that event to be called.
         * @param {String} name The name of the event to publish.
         * @param {Variant} [data] The data to provide for the event.
         * @returns {void}
         */
        publish: function (name, data) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name],
                event = {
                    type: name,
                    data: data
                };

            if (typeof handlers !== "undefined") {
                for (len = handlers.length; i < len; i += 1) {
                    handlers[i](event);
                }
            }

        },

        /**
         * Registers an event handler for the given event.
         * @param {String} name The name of the event to subscribe to.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
        subscribe: function (name, handler) {

            if (!this._handlers.hasOwnProperty(name)) {
                this._handlers[name] = [];
            }


            this._handlers[name].push(handler);
        },

        /**
         * Unregisters an event handler for the given event.
         * @param {String} name The name of the event to unsubscribe from.
         * @param {Function} handler The event handler to remove.
         * @returns {void}
         */
        unsubscribe: function (name, handler) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name];

            if (handlers) {
                for (len = handlers.length; i < len; i += 1) {
                    if (handlers[i] === handler) {
                        handlers.splice(i, 1);
                        return;
                    }
                }
            }
        }

    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines ModuleContext, which is used by all modules.
 * @exports TLT.ModuleContext
 */

/*global TLT*/
/*jshint loopfunc:true*/

/**
 * A layer that abstracts core functionality for each modules. Modules interact
 * with a ModuleContext object to ensure that they're not doing anything
 * they're not allowed to do.
 * @class
 * @param {String} moduleName The name of the module that will use this context.
 * @param {TLT} core The core object. This must be passed in to enable easier
 *        testing.
 */
TLT.ModuleContext = (function () {

    "use strict";

    /**
     * Methods to be exposed from the Core to ModuleContext. ModuleContext
     * simply passes through these methods to the Core. By listing the
     * methods here, the ModuleContext object can be dynamically created
     * to keep the code as small as possible. You can easily add new methods
     * to ModuleContext by adding them to this array. Just make sure the
     * method also exists on TLT and that the first argument for the method
     * on TLT is always the module name.
     *
     * If the method name on ModuleContext is different than on TLT, you can
     * specify that via "contextMethodName:coreMethodName", where contextMethodName
     * is the name of the method on ModuleContext and coreMethodName is
     * the name of the method on TLT.
     *
     * Because the methods aren't actually defined in the traditional sense,
     * the documentation comments are included within the array for proper
     * context.
     * @private
     * @type String[]
     */
    var methodsToExpose = [

        /**
         * Broadcasts a message to the entire system.
         * @name broadcast
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to send.
         * @param {Variant} data The data to send along with the message.
         * @returns {void}
         */
        "broadcast",

        /**
         * Returns the configuration object for the module.
         * @name getConfig
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {Object} The configuration object for the module.
         */
        "getConfig:getModuleConfig",

        /**
         * Tells the system that the module wants to know when a particular
         * message occurs.
         * @name listen
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to listen for.
         * @returns {void}
         */
        "listen",


        /**
         * Posts an event to the module's queue.
         * @name post
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {Object} event The event to put into the queue.
         * @param {String} [queueId] The ID of the queue to add the event to.
         * @returns {void}
         */
        "post",

        /**
         * Calculates the xpath of the given DOM Node.
         * @name getXPathFromNode
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {DOMElement} node The DOM node who's xpath is to be calculated.
         * @returns {String} The calculated xpath.
         */
        "getXPathFromNode",

        /* Log a DOM Capture message to the default queue.
         * @name performDOMCapture
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} moduleName Name of the module which invoked this function.
         * @param {DOMElement} [root] Parent element from which to start the capture.
         * @param {Object} [config] DOM Capture configuration options.
         * @returns {String} The unique string representing the DOM Capture id.
         * null if DOM Capture failed.
         */
        "performDOMCapture",

        /**
         * @name getStartTime
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
         */
        "getStartTime"
    ];

    /**
     * Creates a new ModuleContext object. This function ends up at TLT.ModuleContext.
     * @private
     * @param {String} moduleName The name of the module that will use this context.
     * @param {TLT} core The core object. This must be passed in to enable easier
     *        testing.
     */
    return function (moduleName, core) {

        // If you want to add methods that aren't directly mapped from TLT, do it here
        var context = {},
            i = 0,
            len = methodsToExpose.length,
            parts = null,
            coreMethod = null,
            contextMethod = null;

        // Copy over all methods onto the context object
        for (i = 0; i < len; i += 1) {

            // Check to see if the method names are the same or not
            parts = methodsToExpose[i].split(":");
            if (parts.length > 1) {
                contextMethod = parts[0];
                coreMethod = parts[1];
            } else {
                contextMethod = parts[0];
                coreMethod = parts[0];
            }

            context[contextMethod] = (function (coreMethod) {

                return function () {

                    // Gather arguments and put moduleName as the first one
                    var args = core.utils.convertToArray(arguments);
                    args.unshift(moduleName);


                    // Pass through to the Core
                    return core[coreMethod].apply(core, args);
                };

            }(coreMethod));
        }

        context.utils = core.utils;

        return context;
    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The ConfigService is responsible for managing global configuration settings.
 * This may include receiving dynamic configuration updates from the server at regular intervals.
 * The ConfigService fires a configupdated event when it receives updated configuration information.
 * @exports configService
 */

/*global TLT:true */

/**
 * @name configService
 * @namespace
 */
TLT.addService("config", function (core) {
    "use strict";

    /**
     * Merges a new configuration object/diff into the existing configuration by doing a deep copy.
     * @name configService-mergeConfig
     * @function
     * @private
     * @param  {Object} oldConf Existing configuration object.
     * @param  {Object} newConf New configuration object.
     */
    function mergeConfig(oldConf, newConf) {
        core.utils.extend(true, oldConf, newConf);
        configService.publish("configupdated", configService.getConfig());
    }



    /**
     * Holds the config for core and all services and modules.
     * @private
     * @name configService-config
     * @type {Object}
     */
    var config = {
            core: {},
            modules: {},
            services: {}
        },
        configService = core.utils.extend(false, core.utils.createObject(new TLT.EventTarget()), {
            /**
             * Returns the global configuration object.
             * @return {Object} The global configuration object.
             */
            getConfig: function () {
                return config;
            },
            /**
             * Assigns the global configuration for the system.
             * This is first called when Core.init() is called and also may be called later if new
             * configuration settings are returned from the server. After initial configuration is set,
             * all further calls are assumed to be diffs of settings that should be changed rather than
             * an entirely new configuration object.
             * @param  {Object} newConf The global configuration object.
             */
            updateConfig: function (newConf) {
                mergeConfig(config, newConf);
            },
            /**
             * Returns the configuration object for the core.
             * @return {Object} The core configuration object.
             */
            getCoreConfig: function () {
                return config.core;
            },
            /**
             * Assigns the configuration for the core. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {Object} newConf     A partial or complete core configuration object.
             */
            updateCoreConfig: function (newConf) {
                mergeConfig(config.core, newConf);
            },
            /**
             * Returns the configuration object for a given service.
             * @param {String} serviceName The name of the service to retrieve configuration information for.
             * @return {Object|null} The service configuration object or null if the named service doesn't exist.
             */
            getServiceConfig: function (serviceName) {
                // XXX - Return empty object {} instead of null and correct all places where this is being called.
                return config.services[serviceName] || null;
            },
            /**
             * Assigns the configuration for the named service. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} serviceName The name of the service to update configuration information for.
             * @param  {Object} newConf     A partial or complete service configuration object.
             */
            updateServiceConfig: function (serviceName, newConf) {
                if (typeof config.services[serviceName] === "undefined") {
                    config.services[serviceName] = {};
                }
                mergeConfig(config.services[serviceName], newConf);
            },
            /**
             * Returns the configuration object for a given module.
             * @param {String} moduleName The name of the module to retrieve configuration information for.
             * @return {Object|null} The module configuration object or null if the named module doesn't exist.
             */
            getModuleConfig: function (moduleName) {
                return config.modules[moduleName] || null;
            },
            /**
             * Assigns the configuration for the named module. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} moduleName The name of the module to update configuration information for.
             * @param  {Object} newConf     A partial or complete module configuration object.
             */
            updateModuleConfig: function (moduleName, newConf) {
                if (typeof config.modules[moduleName] === "undefined") {
                    config.modules[moduleName] = {};
                }
                mergeConfig(config.modules[moduleName], newConf);
            },
            destroy: function () {
                config = {
                    core: {},
                    modules: {},
                    services: {}
                };
            }
        });

    return configService;

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The QueueService manages all queues in the system.
 * @exports queueService
 */

/*global TLT:true */

/**
 * @name queueService
 * @namespace
 */
TLT.addService("queue", function (core) {
    "use strict";

    /**
     * queueMananger
     * @private
     * @static
     * @name queueService-queueManager
     * @namespace
     */
    var CONFIG       = null,    // queue configuration
        // TODO: replace these with long form names i.e. aS -> ajaxService
        aS           = core.getService("ajax"),          // ajaxService
        bS           = core.getService("browser"),       // browserService
        eS           = core.getService("encoder"),       // encoderService
        sS           = core.getService("serializer"),    // serializerService
        cS           = core.getService("config"),        // configService
        mS           = core.getService("message"),       // messageService
        defaultQueue = null,    // config object for default queue
        queueTimers  = {},      // timer id for the queueTick
        autoFlushing = true,    // Bool, indicates whether to flush queues when
                                // threshold is reached or let the application control flushing.
        isInitialized = false,
        queueManager = (function () {
            var queues = {};

            /**
             * Checks if the specified queue exists.
             * @function
             * @name queueService-queueManager.exists
             * @param  {String} queueId The id of the queue to check for existence.
             * @return {Boolean}         Returns true if the queue exists, otherwise false.
             */
            function queueExists(queueId) {
                return typeof queues[queueId] !== "undefined";
            }

            /**
             * Adds a queue to the system.
             * @function
             * @name queueService-queueManager.add
             * @param {String} queueId The id of the queue to add.
             * @param {Object} opts    Some additional configuration options for this queue.
             * @param {String} opts.url  The endpoint URL to which the queue should be flushed.
             * @param {Number} opts.threshold The maximal amount of messages to store
             * in the queue before it gets flushed.
             * @param {String} opts.serialzer The serializer which should be used to serialize
             * the data in the queue when sending it to the server.
             * @return {Object} Returns the newly created queue.
             */
            function addQueue(queueId, opts) {
                if (!queueExists(queueId)) {
                    /* TODO: Add prototype functions to access queue members */
                    queues[queueId] = {
                        data: [],
                        queueId: queueId,
                        url: opts.url,
                        threshold: opts.threshold,
                        serializer: opts.serializer,
                        encoder: opts.encoder,
                        crossDomainEnabled: !!opts.crossDomainEnabled,
                        crossDomainIFrame: opts.crossDomainIFrame
                    };
                }
                return queues[queueId];
            }

            /**
             * Removes a queue from the system.
             * @function
             * @name queueService-queueManager.remove
             * @param  {String} queueId The id of the queue which should be deleted.
             */
            function removeQueue(queueId) {
                if (queueExists(queueId)) {
                    delete queues[queueId];
                }
            }

            /**
             * Returns the queue object associated with the given queueId.
             * @function
             * @name queueService-queueManager.get
             * @param  {String} queueId The id of the queue to return.
             * @return {Object}         Returns the queue object for the given id.
             */
            function getQueue(queueId) {
                if (queueExists(queueId)) {
                    return queues[queueId];
                }
                return null;
            }

            /**
             * Clears all items in the queue specified by the queue id.
             * @function
             * @name queueService-queueManager.clear
             * @param  {String} queueId The id of the queue which should be cleared.
             */
            function clearQueue(queueId) {
                var queue = getQueue(queueId);
                if (queue !== null) {
                    queue.data = [];
                }
            }

            /**
             * Returns the queue data and clears the queue.
             * @function
             * @name queueService-queueManager.flush
             * @param  {String} queueId The id of the queue to be flushed.
             * @return {Array}         Returns all items which were stored in the queue.
             */
            function flushQueue(queueId) {
                var data = null;
                if (queueExists(queueId)) {
                    data = getQueue(queueId).data;
                    clearQueue(queueId);
                }
                return data;
            }

            /**
             * Adds an item to a specific queue.
             * @function
             * @name queueService-queueManager.push
             * @param  {String} queueId The id of the queue to which the item should be added.
             * @param  {Object} data    The message object which should be stored in the queue.
             * @return {Number}         Returns the current length of the queue.
             */
            function pushToQueue(queueId, data) {
                var queue = null,
                    jsonStr = null,
                    bridgeAndroid = window.tlBridge,
                    bridgeiOS = window.iOSJSONShuttle;

                // Send to Native Android Bridge
                if ((typeof bridgeAndroid !== "undefined") &&
                        (typeof bridgeAndroid.addMessage === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeAndroid.addMessage(jsonStr);
                // Send to Native iOS Bridge
                } else if ((typeof bridgeiOS !== "undefined") &&
                        (typeof bridgeiOS === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeiOS(jsonStr);
                // Send to normal library queue
                } else {
                    if (queueExists(queueId)) {
                        queue = getQueue(queueId);
                        queue.data.push(data);
                        /* Redirect the queue so any registered callback function
                         * can optionally modify it.
                         */
                        queue.data = core.redirectQueue(queue.data);
                        return queue.data.length;
                    }
                }
                return 0;
            }

            /**
             * @scope queueManager
             */
            return {
                exists: queueExists,
                add: addQueue,
                remove: removeQueue,
                get: getQueue,
                clear: clearQueue,
                flush: flushQueue,
                push: pushToQueue
            };

        }());


    /**
     * Handles the xhr response of the server call.
     * @function
     * @private
     * @name queueService-handleXhrCallback
     */
    function handleXhrCallback() {
        // TODO
    }

    /**
    * Get the path relative to the host.
    * @addon
    */
    function getUrlPath() {
        return window.location.pathname;
    }

    /**
     * Adds a HTTP header (name,value) pair to the specified queue.
     * @function
     * @private
     * @name queueService-addHeaderToQueue
     * @param  {String} queueId The id of the queue which should be flushed.
     * @param  {String} headerName The name of the header to be added.
     * @param  {String} headerValue The value of the header to be added.
     * @param  {Boolean} [recurring] Flag specifying if header should be sent
     *                   once (false) or always (true). Default behavior is to
     *                   send the header once.
     */
    function addHeaderToQueue(queueId, headerName, headerValue, recurring) {
        var queue = queueManager.get(queueId),
            header = {
                name: headerName,
                value: headerValue
            },
            qHeadersList = null;

        // Sanity check
        if (typeof headerName !== "string" || typeof headerValue !== "string") {
            return;
        }

        if (!queue.headers) {
            // TODO: Add prototype functions to help add/copy/remove headers
            queue.headers = {
                once: [],
                always: []
            };
        }

        qHeadersList = !!recurring ? queue.headers.always : queue.headers.once;
        qHeadersList.push(header);
    }

    /**
     * Copies HTTP headers {name,value} from the specified queue to an
     * object.
     * @function
     * @private
     * @name queueService-copyHeaders
     * @param  {String} queueId The id of the queue whose headers are copied.
     * @param  {Object} [headerObj] The object to which headers are added. If no
     * object is specified then a new one is created.
     * @return {Object} The object containing the copied headers.
     */
    function copyHeaders(queueId, headerObj) {
        var i = 0,
            len = 0,
            queue = queueManager.get(queueId),
            qHeaders = queue.headers,
            headersList = null;

        headerObj = headerObj || {};

        function copy(l, o) {
            var i = 0,
                len = 0,
                header = null;

            for (i = 0, len = l.length; i < len; i += 1) {
                header = l[i];
                o[header.name] = header.value;
            }
        }

        if (qHeaders) {
            headersList = [qHeaders.always, qHeaders.once];

            for (i = 0, len = headersList.length; i < len; i += 1) {
                copy(headersList[i], headerObj);
            }
        }

        return headerObj;
    }

    /**
     * Clear HTTP headers {name,value} from the specified queue. Only headers
     * that are to be sent once are cleared.
     * @function
     * @private
     * @name queueService-clearHeaders
     * @param  {String} queueId The id of the queue whose headers are cleared.
     */
    function clearHeaders(queueId) {
        var queue = null,
            qHeaders = null;

        if (!queueManager.exists(queueId)) {
            throw new Error("Queue: " + queueId + " does not exist!");
        }

        queue = queueManager.get(queueId);
        qHeaders = queue ? queue.headers : null;
        if (qHeaders) {
            // Only reset headers that are sent once.
            qHeaders.once = [];
        }
    }

    /**
     * Invoke the core function to get any HTTP request headers from
     * external scripts and add these headers to the default queue.
     * @function
     * @private
     * @returns The number of external headers added to the queue.
     */
    function getExternalRequestHeaders() {
        var i = 0,
            len,
            header,
            headers = core.provideRequestHeaders();

        if (headers && headers.length) {
            for (i = 0, len = headers.length; i < len; i += 1) {
                header = headers[i];
                addHeaderToQueue("DEFAULT", header.name, header.value, header.recurring);
            }
        }
        return i;
    }

    /**
     * Clears a specific queue and sends its serialized content to the server.
     * @function
     * @private
     * @name queueService-flushQueue
     * @param  {String} queueId The id of the queue to be flushed.
     */
    function flushQueue(queueId, sync) {
        var data = queueManager.flush(queueId),
            count = data !== null ? data.length : 0,
            queue = queueManager.get(queueId),
            httpHeaders = {
                "Content-Type": "application/json",
                "X-Tealeaf": "device (UIC) Lib/4.0.0.1607",
                "X-TealeafType": "GUI",  // For our past sins
                "X-TeaLeaf-Page-Url": getUrlPath()
            },
            serializer = queue.serializer || "json",
            contentEncoder = queue.encoder,
            requestData,
            retObj,
            xdomainFrameWindow = null;

        if (!count) {
            return;
        }

        // Wrap the messages with the header
        data = mS.wrapMessages(data);

        // Serialize the data
        if (serializer) {
            data = sS.serialize(data, serializer);
        }

        // Encode if specified
        if (contentEncoder) {
            retObj = eS.encode(data, contentEncoder);
            if (retObj && retObj.data && !retObj.error) {
                data = retObj.data;
                httpHeaders["Content-Encoding"] = retObj.encoding;
            }
        }

        getExternalRequestHeaders();
        copyHeaders(queueId, httpHeaders);

        if (queue.crossDomainEnabled) {
            xdomainFrameWindow = core.utils.getIFrameWindow(queue.crossDomainIFrame);
            if (!xdomainFrameWindow) {
                return;
            }
            requestData = {
                request: {
                    url: queue.url,
                    async: !sync,
                    headers: httpHeaders,
                    data: data
                }
            };

            if (!core.utils.isIE && typeof window.postMessage === "function") {
                xdomainFrameWindow.postMessage(requestData, queue.crossDomainIFrame.src);
            } else {
                try {
                    xdomainFrameWindow.sendMessage(requestData);
                } catch (e) {
                    return;
                }
            }
        } else {
            aS.sendRequest({
                oncomplete: handleXhrCallback,
                url: queue.url,
                async: !sync,
                headers: httpHeaders,
                data: data
            });
        }
        clearHeaders(queueId);
    }

    /**
     * Iterates over all queues and sends their contents to the servers.
     * @function
     * @private
     * @name queueServive-flushAll
     */
    function flushAll(sync) {
        var conf = null,
            queues = CONFIG.queues,
            i = 0;
        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            flushQueue(conf.qid, sync);
        }
        return true;
    }


    /**
     * Adds a message event to the specified queue.
     * If the queue threshold is reached the queue gets flushed.
     * @function
     * @private
     * @name queueService-addToQueue
     * @param {String} queueId The id of the queue which should be flushed.
     * @param {Object} data    The message event which should be stored in the queue.
     */
    function addToQueue(queueId, data) {
        var length = queueManager.push(queueId, mS.createMessage(data));
        if (length >= queueManager.get(queueId).threshold &&
                autoFlushing && core.getState() !== "unloading") {
            flushQueue(queueId);
        }
    }

    /**
     * Returns the queue id for the queue which is responsible for the given module.
     * @function
     * @private
     * @name queueService-getQueueId
     * @param  {String} moduleName The name of the module for which the id should get looked up.
     * @return {String}            Returns the queue id for the corresponding queue or the default queue id.
     */
    function getQueueId(moduleName) {
        var conf = null,
            queues = CONFIG.queues,
            module = "",
            i = 0,
            j = 0;

        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            if (conf && conf.modules) {
                for (j = 0; j < conf.modules.length; j += 1) {
                    module = conf.modules[j];
                    if (module === moduleName) {
                        return conf.qid;
                    }
                }
            }
        }
        return defaultQueue.qid;
    }


    function setTimer(qid, interval) {
        queueTimers[qid] = window.setTimeout(function tick() {
            flushQueue(qid);
            queueTimers[qid] = window.setTimeout(tick, interval);
        }, interval);
    }


    function clearTimers() {
        var key = 0;

        for (key in queueTimers) {
            if (queueTimers.hasOwnProperty(key)) {
                window.clearTimeout(queueTimers[key]);
                delete queueTimers[key];
            }
        }

        queueTimers = {};
    }


    /**
     * Handles the configupdated event from the configService and reinitialize all queues.
     * @function
     * @private
     * @name queueService-handleConfigUpdated
     * @param  {Object} newConf The new configuration object diff.
     */
    function handleConfigUpdated(newConf) {
        // TODO: merge config
    }



    /**
     * Sets up all the needed queues and event handlers and start the queueTick.
     * @function
     * @private
     * @param  {Object} config The queueService configuration object.
     */
    function initQueueService(config) {
        CONFIG = config;

        core.utils.forEach(CONFIG.queues, function (conf, i) {
            var crossDomainIFrame = null;
            if (conf.qid === "DEFAULT") {
                defaultQueue = conf;
            }
            if (conf.crossDomainEnabled) {
                crossDomainIFrame = bS.query(conf.crossDomainFrameSelector);
                if (!crossDomainIFrame) {
                    core.fail("Cross domain iframe not found");
                }
            }

            queueManager.add(conf.qid, {
                url: conf.endpoint,
                threshold: conf.maxEvents,
                serializer: conf.serializer,
                encoder: conf.encoder,
                timerInterval: conf.timerInterval || 0,
                crossDomainEnabled: conf.crossDomainEnabled || false,
                crossDomainIFrame: crossDomainIFrame
            });

            if (typeof conf.timerInterval !== "undefined" && conf.timerInterval > 0) {
                setTimer(conf.qid, conf.timerInterval);
            }
        });

        cS.subscribe("configupdated", handleConfigUpdated);

        isInitialized = true;
    }

    function destroy() {
        if (autoFlushing) {
            flushAll(!CONFIG.asyncReqOnUnload);
        }
        cS.unsubscribe("configupdated", handleConfigUpdated);

        clearTimers();

        CONFIG = null;
        defaultQueue = null;
        isInitialized = false;
    }

    /**
     * @scope queueService
     */
    return {
        init: function () {
            if (!isInitialized) {
                initQueueService(cS.getServiceConfig("queue") || {});
            } else {
            }
        },

        /**
         * Get's called when the core shut's down.
         * Clean up everything.
         */
        destroy: function () {
            destroy();
        },

        // TODO: Need to expose for selenium functional tests
        _getQueue: function (qid) { return queueManager.get(qid).data; },


        /**
         * Enables/disables automatic flushing of queues so that the application
         * could decide on their own when to flush by calling flushAll.
         * @param {Boolean} flag Could be either true or false to enable or disable
         *                  auto flushing respectively.
         */
        setAutoFlush: function (flag) {
            if (flag === true) {
                autoFlushing = true;
            } else {
                autoFlushing = false;
            }
        },

        /**
         * Forces a particular queue to be flushed, sending its information to the server.
         * @param  {String} queueId The ID of the queue to be flushed.
         */
        flush: function (queueId) {
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            flushQueue(queueId);
        },

        /**
         * Forces all queues to be flushed, sending all queue information to the server.
         */
        flushAll: function (sync) {
            return flushAll(!!sync);
        },

        /**
         * Send event information to the module's default queue.
         * This doesn't necessarily force the event data to be sent to the server,
         * as this behavior is defined by the queue itself.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {Object} queueEvent The event information to be saved to the queue.
         * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
         */
        post: function (moduleName, queueEvent, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addToQueue(queueId, queueEvent);
        }
    };

});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document, ActiveXObject */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browserBase", function (core) {
    "use strict";

    var nonClickableTags = {
            OPTGROUP: true,
            OPTION: true,
            NOBR: true
        },
        queryDom = {},
        configService = core.getService("config"),
        serializerService = null,
        config,
        blacklist,
        customid,
        getXPathFromNode,
        isInitialized = false;

    function updateConfig() {
        configService = core.getService("config");
        serializerService = core.getService("serializer");
        config = core.getService("config").getServiceConfig("browser") || {};
        blacklist = config.hasOwnProperty("blacklist") ? config.blacklist : [];
        customid = config.hasOwnProperty("customid") ? config.customid : [];
    }

    function initBrowserBase() {
        updateConfig();
        configService.subscribe("configupdated", updateConfig);
        serializerService = core.getService("serializer");

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    function checkId(node) {
        var i,
            len,
            re;

        if (!node || !node.id || typeof node.id !== "string") {
            return false;
        }

        for (i = 0, len = blacklist.length; i < len; i += 1) {
            if (typeof blacklist[i] === "string") {
                if (node.id === blacklist[i]) {
                    return false;
                }
            } else if (typeof blacklist[i] === "object") {
                re = new RegExp(blacklist[i].regex, blacklist[i].flags);
                if (re.test(node.id)) {
                    return false;
                }
            }
        }
        return true;
    }

    function getEventType(event, target) {
        var returnObj = {
                type: null,
                // Event subtype is not used in the UIC
                subType: null
            },
            type;

        // Sanity check
        if (!event) {
            return returnObj;
        }

        // Normalize event type for jQuery events focusin, focusout
        type = event.type;
        switch (type) {
        case "focusin":
            type = "focus";
            break;
        case "focusout":
            type = "blur";
            break;
        default:
            break;
        }
        returnObj.type = type;

        return returnObj;
    }

    /**
     * Examines the type and subType of the target.
     * @function
     * @name browserService-getElementType
     * @param  {Object} element The normalized target element.
     * @return {Object} Returns an object which contains the type and subType of the target element.
     */
    function getElementType(element) {
        var returnObj = {
                type: null,
                subType: null
            };

        // Sanity check
        if (!element) {
            return returnObj;
        }

        returnObj.type = element.tagName;
        returnObj.subType = element.type || null;

        return returnObj;
    }

    /**
     * Returns an element by it's id and idType where id could be either an HTML id,
     *     attribute ID or XPath selector.
     * @param  {String} selector The selector. Either a single HTML ID or an attribute ID
     *                  example: "myid=customid" or a tealeaf XPath string.
     * @param  {Number} type     A number, indicating the type of the query
     *                           as in the object 'idTypes' below.
     *                           -1 for HTML ID, -2 for XPath and -3 for attribute ID.
     * @return {Object}          Returns the node, if found. Otherwise null.
     */
    function getNodeFromID(selector, type, scope) {
        var idTypes = {
                HTML_ID: "-1",
                XPATH_ID: "-2",
                ATTRIBUTE_ID: "-3"
            },
            doc,
            node = null,
            parts;

        // Sanity check
        if (!selector || !type) {
            return node;
        }

        doc = scope || window.document;
        type = type.toString();
        if (type === idTypes.HTML_ID) {
            if (doc.getElementById) {
                node = doc.getElementById(selector);
            } else if (doc.querySelector) {
                node = doc.querySelector("#" + selector);
            }
        } else if (type === idTypes.ATTRIBUTE_ID) {
            parts = selector.split("=");
            if (doc.querySelector) {
                node = doc.querySelector("[" + parts[0] + "=\"" + parts[1] + "\"]");
            }
        } else if (type === idTypes.XPATH_ID) {
            node = queryDom.xpath(selector, doc);
        }
        return node;
    }

    /**
     * Generates an XPath for a given node
     * @function
     */
    getXPathFromNode = (function () {

        var specialChildNodes = {
                "NOBR": true,
                "P": true
            };

        /**
         * Returns Xpath string for a node
         * @private
         * @param {Element} node DOM element
         * @return {string} xpath string
         */
        function getXPathArrayFromNode(node) {
            var i,
                j,
                idValid = false,
                tmp_child = null,
                parent_window = null,
                parent_node = null,
                xpath = [],
                loop = true,
                localTop = core._getLocalTop();

            while (loop) {
                loop = false;

                if (!core.utils.isUndefOrNull(node)) {
                    if (!core.utils.isUndefOrNull(node.tagName)) {
                        // Hack fix to handle tags that are not normally visual elements
                        if (specialChildNodes.hasOwnProperty(node.tagName)) {
                            node = node.parentNode;
                        }
                    }
                    for (idValid = checkId(node);
                            node !== document && !idValid;
                            idValid = checkId(node)) {
                        parent_node = node.parentNode;
                        if (!parent_node) {
                            parent_window = core.utils.getWindow(node);
                            parent_node = (parent_window !== localTop) ? parent_window.frameElement : document;
                        }

                        tmp_child = parent_node.firstChild;
                        if (typeof tmp_child === "undefined") {
                            return xpath;
                        }

                        for (j = 0; tmp_child; tmp_child = tmp_child.nextSibling) {
                            if (tmp_child.nodeType === 1 && tmp_child.tagName === node.tagName) {
                                if (tmp_child === node) {
                                    xpath[xpath.length] = [node.tagName, j];
                                    break;
                                }
                                j += 1;
                            }
                        }
                        node = parent_node;
                    }

                    if (idValid) {
                        xpath[xpath.length] = [node.id];
                        if (core.utils.isIFrameDescendant(node)) {
                            loop = true;
                            node = core.utils.getWindow(node).frameElement;
                        }
                    }
                }
            }

            return xpath;
        }

        // actual getXPathFromNode function
        return function (node) {
            var xpath = getXPathArrayFromNode(node),
                parts = [],
                i = xpath.length;

            if (i < 1) {
                return "null";
            }
            while (i) {
                i -= 1;
                if (xpath[i].length > 1) {
                    parts[parts.length] = '["' + xpath[i][0] + '",' + xpath[i][1] + "]";
                } else {
                    parts[parts.length] = '[' + serializerService.serialize(xpath[i][0], "json") + ']';
                }
            }
            return ("[" + parts.join(",") + "]");
        };
    }());

    /**
     * Returns the scroll position (left, top) of the document
     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX
     * @private
     * @param {DOMObject} doc The document object.
     * @return {Object} An object specifying the document's scroll offset position {left, top}
     */
    function getDocScrollPosition(doc) {
        var scrollPos = {
                left: -1,
                top: -1
            },
            docElement;

        doc = doc || document;
        // Get the scrollLeft, scrollTop from documentElement or body.parentNode or body in that order.
        docElement = doc.documentElement || doc.body.parentNode || doc.body;

        // If window.pageXOffset exists, use it. Otherwise fallback to getting the scrollLeft position.
        scrollPos.left = (typeof window.pageXOffset === "number") ? window.pageXOffset : docElement.scrollLeft;
        scrollPos.top = (typeof window.pageYOffset === "number") ? window.pageYOffset : docElement.scrollTop;

        return scrollPos;
    }

    /**
     * Returns true if an event is a jQuery event wrpper object.
     * @private
     * @param {UIEvent} event Browser event to examine
     * @return {boolean} true if given event is jQuery event
     */
    function isJQueryEvent(event) {
        return event && typeof event.originalEvent !== "undefined" &&
            typeof event.isDefaultPrevented !== "undefined"  &&
            !event.isSimulated;
    }


    /**
     * Looks for event details. Usually it returns an event itself, but for touch events
     * function returns an element from one of the touch arrays.
     * @private
     * @param {UIEvent} event Browser event. If skipped function will look for window.event
     * @return {UIEvent} latest touch details for touch event or original event object
     *          for all other cases
     */
    function getEventDetails(event) {
        if (!event) {
            return null;
        }
        if (event.type && event.type.indexOf("touch") === 0) {
            if (isJQueryEvent(event)) {
                event = event.originalEvent;
            }
            if (event.type === "touchstart") {
                event = event.touches[event.touches.length - 1];
            } else if (event.type === "touchend") {
                event = event.changedTouches[0];
            }
        }
        return event;
    }


    /**
     * Normalizes the event object for InternetExplorer older than 9.
     * @return {HttpEvent} normalized event object
     */
    function normalizeEvent(event) {
        var e = event || window.event,
            doc = document.documentElement,
            body = document.body,
            found = false,
            foundElement = null,
            i = 0;

        // skip jQuery event wrapper
        if (isJQueryEvent(e)) {
            e = e.originalEvent;
        }

        // IE case
        if (typeof event === 'undefined' || typeof e.target === 'undefined') {
            e.target = e.srcElement || window.window;
            e.timeStamp = Number(new Date());
            if (e.pageX === null || typeof e.pageX === "undefined") {
                e.pageX = e.clientX + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
                    ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
                e.pageY = e.clientY + ((doc && doc.scrollTop)  || (body && body.scrollTop)  || 0) -
                    ((doc && doc.clientTop)  || (body && body.clientTop)  || 0);
            }
            e.preventDefault = function () {
                this.returnValue = false;
            };
            e.stopPropagation = function () {
                this.cancelBubble = true;
            };
        }

        // Chrome case getting blur for inner elements sending click
        if (window.chrome && e.path !== undefined && e.type === "click") {
            if (e.path.length === undefined) {
                return e;
            }

            for (i = 0; i < e.path.length; i++) {
                if (e.path[i].tagName === "BUTTON") {
                    found = true;
                    foundElement = e.path[i];
                    i = e.path.length;
                }
            }
            if (found) {
                return {
                    originalEvent: e,
                    target: foundElement,
                    srcElement: foundElement,
                    type: e.type,
                    pageX: document.body.scrollLeft + foundElement.getBoundingClientRect().left,
                    pageY: document.body.scrollTop + foundElement.getBoundingClientRect().top
                };
            }
        }

        return e;
    }

    /**
     * Normalizes target element. In case of touch event the target is considered to be an
     * element for whch the last action took place
     * @private
     * @param {UIEvent} event browser event
     * @return {Element} DOM element
     */
    function normalizeTarget(event) {
        var itemSource = null;

        if (!event) {
            return null;
        }

        if (event.srcElement) {
            // IE
            itemSource = event.srcElement;
        } else {
            // W3C
            itemSource = event.target;
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.explicitOriginalTarget;
            }
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.originalTarget;
            }
        }

        if (!itemSource && event.type.indexOf("touch") === 0) {
            itemSource = getEventDetails(event).target;
        }

        while (itemSource && nonClickableTags[itemSource.tagName]) {
            itemSource = itemSource.parentNode;
        }

        // IE when srcElement pointing to window
        if (!itemSource && event.srcElement === null) {
            itemSource = window.window;
        }

        return itemSource;
    }


    /**
     * Returns event position independently to the event type.
     * In case of touch event the position of last action will be returned.
     * @private
     * @param {UIEvent} event Browser event
     * @return {Object} object containing x and y properties
     */
    function getEventPosition(event) {
        var posX = 0,
            posY = 0,
            doc = document.documentElement,
            body = document.body;

        event = getEventDetails(event);

        if (event) {
            if (event.pageX || event.pageY) {
                posX = event.pageX;
                posY = event.pageY;
            } else if (event.clientX || event.clientY) {
                posX = event.clientX + (doc ? doc.scrollLeft : (body ? body.scrollLeft : 0)) -
                                       (doc ? doc.clientLeft : (body ? body.clientLeft : 0));
                posY = event.clientY + (doc ? doc.scrollTop : (body ? body.scrollTop : 0)) -
                                       (doc ? doc.clientTop : (body ? body.clientTop : 0));
            }
        }

        return {
            x: posX,
            y: posY
        };
    }

    /**
     * Find one or more elements using a XPath selector.
     * @function
     * @name browserService-queryDom.xpath
     * @param  {String} query The XPath query to search for.
     * @param  {Object} [scope="document"] The DOM subtree to run the query in.
     * @return {Object}       Returns the DOM element matching the XPath.
     */
    queryDom.xpath = function (query, scope) {
        var xpath = null,
            elem,
            pathElem = null,
            i,
            j,
            k,
            len,
            jlen;

        // Sanity check
        if (!query) {
            return null;
        }

        xpath = serializerService.parse(query);
        scope = scope || document;
        elem = scope;

        if (!xpath) {
            return null;
        }

        for (i = 0, len = xpath.length; i < len && elem; i += 1) {
            pathElem = xpath[i];
            if (pathElem.length === 1) {
                if (scope.getElementById) {
                    elem = scope.getElementById(pathElem[0]);
                } else if (scope.querySelector) {
                    elem = scope.querySelector("#" + pathElem[0]);
                } else {
                    elem = null;
                }
            } else {
                for (j = 0, k = -1, jlen = elem.childNodes.length; j < jlen; j += 1) {
                    if (elem.childNodes[j].nodeType === 1 && elem.childNodes[j].tagName.toUpperCase() === pathElem[0]) {
                        k += 1;
                        if (k === pathElem[1]) {
                            elem = elem.childNodes[j];
                            break;
                        }
                    }
                }
                if (k === -1) {
                    return null;
                }
            }
        }

        return (elem === scope || !elem) ? null : elem;
    };


    /**
     * The Point interface represents a point on the page to
     *     x- and y-coordinates.
     * @constructor
     * @private
     * @name browserService-Point
     * @param {Integer} x The x-coordinate of the point.
     * @param {Integer} y The y-coordinate of the point.
     */
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }


    /**
     * The Size  interface represents the width and height of an element
     *     on the page.
     * @constructor
     * @private
     * @name browserService-Size
     * @param {Integer} width  Width of the element that received the event.
     * @param {Integer} height Height of the element that received the event.
     */
    function Size(width, height) {
        this.width = width || 0;
        this.height = height || 0;
    }


    /**
     * The ElementData interface represents a normalized browser event object.
     * @constructor
     * @private
     * @name browserService-ElementData
     * @param {Object} event  The browser event.
     * @param {Object} target The HTML element which received the event.
     */
    function ElementData(event, target) {
        var id,
            elementType,
            pos;

        target = normalizeTarget(event);
        id = this.examineID(target);
        elementType = getElementType(target);
        pos = this.examinePosition(event, target);

        this.element = target;
        this.id = id.id;
        this.idType = id.type;
        this.type = elementType.type;
        this.subType = elementType.subType;
        this.state = this.examineState(target);
        this.position = new Point(pos.x, pos.y);
        this.size = new Size(pos.width, pos.height);
        this.xPath = id.xPath;
        this.name = id.name;
    }

    /**#@+
     * @constant
     * @enum {Number}
     * @fieldOf browserService-ElementData
     */
    ElementData.HTML_ID = -1;
    ElementData.XPATH_ID = -2;
    ElementData.ATTRIBUTE_ID = -3;
    /**#@-*/

    /**
     * Examines how to specify the target element
     *     (either by css selectors or xpath)
     *     and returns an object with the properties id and type.
     * @function
     * @name browserService-ElementData.examineID
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object with the properties id and type.
     *      id contains either a css or xpath selector.
     *      type contains a reference to either ElementData.HTML_ID,
     *      ElementData.XPATH_ID or ElementData.ATTRIBUTE_ID
     * @todo determine the element css/xpath/attribute selector.
     */
    ElementData.prototype.examineID = function (target) {
        var id,
            type,
            xPath,
            attribute_id,
            name,
            i = customid.length,
            attrib;

        try {
            xPath = getXPathFromNode(target);
        } catch (e) { }
        name = target.name;

        try {
            if (!core.utils.isIFrameDescendant(target)) {

                if (checkId(target)) {
                    id = target.id;
                    type = ElementData.HTML_ID;
                } else if (customid.length && target.attributes) {
                    while (i) {
                        i -= 1;
                        attrib = target.attributes[customid[i]];
                        if (typeof attrib !== "undefined") {
                            id = customid[i] + "=" + (attrib.value || attrib);
                            type = ElementData.ATTRIBUTE_ID;
                        }
                    }
                }
            }
        } catch (e2) { }

        if (!id) {
            id = xPath;
            type = ElementData.XPATH_ID;
        }

        return {
            id: id,
            type: type,
            xPath: xPath,
            name: name
        };
    };


    /**
     * Examines the current state of the HTML element if it's an input/ui element.
     * @function
     * @name browserService-ElementData.examineState
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object which contains all properties
     *     to describe the state.
     * @todo determine the current state.
     */
    ElementData.prototype.examineState = function (target) {
        var tagnames = {
                "a": ["innerText", "href"],
                "input": {
                    "range": ["maxValue:max", "value"],
                    "checkbox": ["value", "checked"],
                    "radio": ["value", "checked"],
                    "image": ["src"]
                },
                "select": ["value"],
                "button": ["value", "innerText"],
                "textarea": ["value"]
            },
            tagName = typeof target.tagName !== "undefined" ? target.tagName.toLowerCase() : "",
            properties = tagnames[tagName] || null,
            selectedOption = null,
            values = null,
            i = 0,
            len = 0,
            alias = null,
            key = "";

        if (properties !== null) {
            // For input elements, another level of indirection is required
            if (Object.prototype.toString.call(properties) === "[object Object]") {
                // default state for input elements is represented by the "value" property
                properties = properties[target.type] || ["value"];
            }
            values = {};
            for (key in properties) {
                if (properties.hasOwnProperty(key)) {
                    if (properties[key].indexOf(":") !== -1) {
                        alias = properties[key].split(":");
                        values[alias[0]] = target[alias[1]];
                    } else if (properties[key] === "innerText") {
                        values[properties[key]] = core.utils.trim(target.innerText || target.textContent);
                    } else {
                        values[properties[key]] = target[properties[key]];
                    }
                }
            }
        }

        // Special processing for select lists
        if (tagName === "select" && target.options && !isNaN(target.selectedIndex)) {
            values.index = target.selectedIndex;
            if (values.index >= 0 && values.index < target.options.length) {
                selectedOption = target.options[target.selectedIndex];
                /* Select list value is derived from the selected option's properties
                 * in the following order:
                 * 1. value
                 * 2. label
                 * 3. text
                 * 4. innerText
                 */
                values.value = selectedOption.getAttribute("value") || selectedOption.getAttribute("label") || selectedOption.text || selectedOption.innerText;
                values.text = selectedOption.text || selectedOption.innerText;
            }
        }

        return values;
    };


    /**
     * Gets the current zoom value of the browser with 1 being equivalent to 100%.
     * @function
     * @name getZoomValue
     * @return {int}        Returns zoom value of the browser.
     */
    function getZoomValue() {
        var factor = 1,
            rect,
            physicalW,
            logicalW;

        if (document.body.getBoundingClientRect) {
            // rect is only in physical pixel size in IE before version 8
            // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
            // on IE 9
            try {
                rect = document.body.getBoundingClientRect();
            } catch (e) {
                core.utils.clog("getBoundingClientRect failed.", e);
                return factor;
            }
            physicalW = rect.right - rect.left;
            logicalW = document.body.offsetWidth;

            // the zoom level is always an integer percent value
            factor = Math.round((physicalW / logicalW) * 100) / 100;
        }
        return factor;
    }

    /**
     * Gets BoundingClientRect value from a HTML element.
     * @function
     * @name getBoundingClientRectNormalized
     * @param  {Object} element The HTML element.
     * @return {Object} An object with x, y, width, and height.
     */
    function getBoundingClientRectNormalized(element) {
        var rect,
            rectangle,
            zoom,
            scrollPos;

        if (!element || !element.getBoundingClientRect) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
        // on IE 9
        try {
            rect = element.getBoundingClientRect();
            scrollPos = getDocScrollPosition(document);
        } catch (e) {
            core.utils.clog("getBoundingClientRect failed.", e);
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        rectangle = {
            // Normalize viewport-relative left & top with scroll values to get left-x & top-y relative to the document
            x: rect.left + scrollPos.left,
            y: rect.top + scrollPos.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
        if (core.utils.isIE) {
            // IE ONLY: the bounding rectangle include the top and left borders of the client area
            rectangle.x -= document.documentElement.clientLeft;
            rectangle.y -= document.documentElement.clientTop;

            zoom = getZoomValue();
            if (zoom !== 1) {  // IE 7 at non-default zoom level
                rectangle.x = Math.round(rectangle.x / zoom);
                rectangle.y = Math.round(rectangle.y / zoom);
                rectangle.width = Math.round(rectangle.width / zoom);
                rectangle.height = Math.round(rectangle.height / zoom);
            }
        }
        return rectangle;
    }

    /**
     * Examines the position of the event relative to the HTML element which
     * received the event on the page. The top left corner of the element is 0,0
     * and bottom right corner of the element is equal to it's width, height.
     * @function
     * @name browserService-ElementData.examinePosition
     * @param  {Object} target The HTML element which received the event.
     * @return {Point}        Returns a Point object.
     */
    ElementData.prototype.examinePosition = function (event, target) {
        var posOnDoc = getEventPosition(event),
            elPos = getBoundingClientRectNormalized(target);

        elPos.x = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.x - elPos.x)) : elPos.width / 2;
        elPos.y = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.y - elPos.y)) : elPos.height / 2;

        return elPos;
    };


    /**
     * The WebEvent  interface represents a normalized browser event object.
     *     When an event occurs, the BrowserService wraps the native event
     *     object in a WebEvent.
     * @constructor
     * @private
     * @name browserService-WebEvent
     * @param {Object} event The native browser event.
     */
    function WebEvent(event) {
        var pos,
            eventType;

        this.data = event.data || null;
        this.delegateTarget = event.delegateTarget || null;

		//add the gesture event data to the webevent if it exists.
		if (event.gesture || (event.originalEvent && event.originalEvent.gesture)) {
			this.gesture = event.gesture || event.originalEvent.gesture;
		}

        event = normalizeEvent(event);
        pos = getEventPosition(event);
        this.custom = false;    // @TODO: how to determine if it's a custom event?
        this.nativeEvent = this.custom === true ? null : event;
        this.position = new Point(pos.x, pos.y);
        this.target = new ElementData(event, event.target);
        // Do not rely on browser provided event.timeStamp since FF sets
        // incorrect values. Refer to Mozilla Bug 238041
        this.timestamp = (new Date()).getTime();

        eventType = getEventType(event, this.target);
        this.type = eventType.type;
        this.subType = eventType.subType;
    }

    function processDOMEvent(event) {
        core._publishEvent(new WebEvent(event));
    }


    return {
        init: function () {
            if (!isInitialized) {
                initBrowserBase();
            } else {
            }
        },
        destroy: function () {
            destroy();
        },
        WebEvent: WebEvent,
        ElementData: ElementData,
        processDOMEvent: processDOMEvent,

        getXPathFromNode: function (moduleName, node) {
            return getXPathFromNode(node);
        },
        getNodeFromID: getNodeFromID,
        queryDom: queryDom
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT:true, XPathResult:true, document: true */
/*global console: false */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browser", function (core) {
    "use strict";

    var jQuery,
        queryDom,
        handlerMappings,
        errorCodes = {
            JQUERY_NOT_SUPPORTED: "JQUERYNOTSUPPORTED",
            JQUERY_NOT_FOUND: "JQUERYNOTFOUND"
        },
        configService = core.getService("config"),
        base = core.getService('browserBase'),
        browser  = configService.getServiceConfig("browser") || {},
        // from w3c
        addEventListener = null,
        removeEventListener = null,
        isInitialized = false;


    /**
     * Returns a new function which will be used in the subscribe method and
     *     which calls the handler function with the normalized WebEvent.
     * @private
     * @function
     * @name browserService-wrapWebEvent
     * @param  {Function} handler The handler which was passed to the
     *     browserService's subscribe method.
     * @return {Function}         Returns a new function which, when called,
     *     passes a WebEvent to the handler.
     */
    function wrapWebEvent(handler) {
        return function (event) {
            var webEvent = new base.WebEvent(event);
            handler(webEvent);
        };
    }


    /**
     * Check wether a certain method exists on the jQuery object. If not an exception is thrown.
     * @function
     * @private
     * @name browserService-jQueryFnExists
     * @param  {Objcet} object   The jQuery object.
     * @param  {String} property The methodname te test for.
     */
    function jQueryFnExists(object, property) {
        if (typeof object[property] !== "function") {
            core.fail("jQuery Object does not support " + property, errorCodes.JQUERY_NOT_SUPPORTED);
        }
    }


    /**
     * Check for correct jQuery version and methods.
     * Throws an exception if jQuery is not supported by the library.
     * @function
     * @private
     * @name browserService-verifyJQuery
     */
    function verifyJQuery() {
        var wrapperFunctions = ["on", "off"],
            jQFunctions = ["ajax", "find", "getScript"],
            jQVersion = (typeof jQuery === "function" && typeof jQuery.fn === "object") ? jQuery.fn.jquery : 0,
			jQVersionMajor = jQVersion !== 0 ? parseInt(jQVersion.split(".")[0], 10) : 0,
			jQVersionMinor = jQVersion !== 0 ? parseInt(jQVersion.split(".")[1], 10) : 0,
            i,
            len = 0,
            dummyWrapper = null;
        if (typeof jQuery !== "function") {
            core.fail("jQuery not found.", errorCodes.JQUERY_NOT_FOUND);
        }

        for (i = 0, len = jQFunctions.length; i < len; i += 1) {
            jQueryFnExists(jQuery, jQFunctions[i]);
        }

        for (i = 0, len = wrapperFunctions.length, dummyWrapper = jQuery({}); i < len; i += 1) {
            jQueryFnExists(dummyWrapper, wrapperFunctions[i]);
        }

        if (!(jQVersionMajor >= 2 || (jQVersionMajor === 1 && jQVersionMinor >= 7))) {
            core.fail("jQuery Object has the wrong version (" + jQVersion + ")", errorCodes.JQUERY_NOT_SUPPORTED);
        }
    }


    /**
     * @private
     * @namespace
     * @name browserService-queryDom
     */
    queryDom = {
        /**
         * Helper function to transform a nodelist into an array.
         * @function
         * @name browserService-queryDom.list2Array
         * @param  {List} nodeList Pass in a DOM NodeList
         * @return {Array}          Returns an array.
         */
        list2Array: function (nodeList) {
            var len = nodeList.length,
                result = [],
                i;

            // Sanity check
            if (!nodeList) {
                return result;
            }

            if (typeof nodeList.length === "undefined") {
                return [nodeList];
            }

            for (i = 0; i < len; i += 1) {
                result[i] = nodeList[i];
            }
            return result;
        },

        /**
         * Finds one or more elements in the DOM using a CSS or XPath selector
         * and returns an array instead of a NodeList.
         * @function
         * @name browserService-queryDom.find
         * @param  {String} query Pass in a CSS or XPath selector query.
         * @param  {Object} [scope="document"]  The DOM subtree to run the query in.
         *      If not provided, document is used.
         * @param  {String} [type="css"]  The type of query. Either "css' (default)
         *      or 'xpath' to allow XPath queries.
         * @return {Array}       Returns an array of nodes that matches the particular query.
         */
        find: function (query, scope, type) {
            type = type || "css";
            return this.list2Array(this[type](query, scope));
        },

        /**
         * Find one or more elements using a CSS selector.
         * @function
         * @name browserService-queryDom.css
         * @param  {String} query The CSS selector query.
         * @param  {Object} [scope="document"] The DOM subtree to run the query in.
         * @return {Array}       Returns an array of nodes that matches the particular query.
         */
        css: function (query, scope) {
            scope = scope || document;
            return jQuery(scope).find(query).get();
        }
    };

    // store handler functions which got passed to subscribe/unsubscribe.
    handlerMappings = (function () {
        var data = new core.utils.WeakMap();

        return {
            add: function (originalHandler) {
                var handlers = data.get(originalHandler) || [wrapWebEvent(originalHandler), 0];

                handlers[1] += 1;
                data.set(originalHandler, handlers);
                return handlers[0];
            },

            find: function (originalHandler) {
                var handlers = data.get(originalHandler);
                return handlers ? handlers[0] : null;
            },

            remove: function (originalHandler) {
                var handlers = data.get(originalHandler);
                if (handlers) {
                    handlers[1] -= 1;
                    if (handlers[1] <= 0) {
                        data.remove(originalHandler);
                    }
                }
            }
        };
    }());

    /**
     * Initialization function
     * @function
     */
    function initBrowserServiceJQuery(config) {
        var useCapture = (browser.useCapture === true);

        queryDom.xpath = base.queryDom.xpath;

        // find jQuery object
        if (config.hasOwnProperty("jQueryObject")) {
            jQuery = core.utils.access(config.jQueryObject);
        } else {
            jQuery = window.jQuery;
        }

        // verify jQuery
        verifyJQuery();

        // register event functions
        if (useCapture && typeof document.addEventListener === 'function') {
            addEventListener = function (target, eventName, handler) {
                var _handler = function (e) { handler(jQuery.event.fix(e)); };
                target.addEventListener(eventName, _handler, useCapture);
            };
            removeEventListener = function (target, eventName, handler) {
                var _handler = function (e) { handler(jQuery.event.fix(e)); };
                target.removeEventListener(eventName, _handler, useCapture);
            };
        } else {
            addEventListener = function (target, eventName, handler) {
                jQuery(target).on(eventName, handler);
            };
            removeEventListener = function (target, eventName, handler) {
                jQuery(target).off(eventName, handler);
            };
        }

        isInitialized = true;
    }


    /**
     * @scope browserService
     */
    return {

        /**
         * Initializes the service
         */
        init: function () {
            if (!isInitialized) {
                initBrowserServiceJQuery(configService.getServiceConfig("browser") || {});
            } else {
            }
        },

        /**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

        /**
         * Returns service name
         */
        getServiceName: function () {
            return "jQuery";
        },

        /**
         * Find a single element in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object|null}       The first matching HTML element or null if not found.
         */
        query: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type)[0] || null;
			} catch (err) {
				return [];
			}
        },

        /**
         * Find all elements in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object[]|Array}       An array of HTML elements matching the query
         *     or and empty array if no elements are matching.
         */
        queryAll: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type);
			} catch (err) {
				return [];
			}
        },

        /**
         * Loads a JavaScript file onto the current page.
         * @param  {String} url The URL of the JavaScript file to load.
         */
        loadScript: function (url) {
            jQuery.getScript(url);
        },


        /**
         * Subscribes an event handler to be called when a particular event occurs.
         * @param  {String} eventName The name of the event to listen for.
         * @param  {Object} target    The object on which the event will fire.
         * @param  {Function} handler   The function to call when the event occurs.
         *     The browserServices passes a WebEvent object to this handler
         * @param  {Object} [delegateTarget] The delegated target on which the event will fire.
         * @param  {String} [data] The token data which will be returned as event.data when the event triggers.
         */
        subscribe: function (eventName, target, handler, delegateTarget, data) {
            var wrappedHandler = handlerMappings.add(handler);


            if (!delegateTarget) {
                addEventListener(target, eventName, wrappedHandler);
            } else {
                jQuery(delegateTarget).on(eventName, target, data, wrappedHandler);
            }
        },

        /**
         * Unsubscribes an event handler from a particular event.
         * @param  {String} eventName The name of the event for which the handler was subscribed.
         * @param  {Object} target    The object on which the event fires.
         * @param  {Function} handler   The function to remove as an event handler.
         * @param  {Object} delegateTarget The delegated target on which the event fires.
         */
        unsubscribe: function (eventName, target, handler, delegateTarget) {
            var wrappedHandler = handlerMappings.find(handler);
            if (wrappedHandler) {
                try {
                    if (!delegateTarget) {
                        removeEventListener(target, eventName, wrappedHandler);
                    } else {
                        jQuery(delegateTarget).off(eventName, target, wrappedHandler);
                    }
                } catch (e) {
                }
                handlerMappings.remove(handler);
            }
        },

        /**
         * Returns a reference to jQuery object used by the service
         * @return {Object} reference to jQuery used by the service
         */
        getJQuery: function () {
            return jQuery;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*global TLT:true, window: true */

/**
 * @name ajaxService
 * @namespace
 */
TLT.addService("ajax", function (core) {
    "use strict";

    var makeAjaxCall,
        configService = core.getService("config"),
        browser = core.getService('browser'),
        jQuery,
        isInitialized = false;

    /**
     * Builds an object of key => value pairs of HTTP headers from a string.
     * @param  {String} headers The string of HTTP headers separated by newlines
     *      (i.e.: "Content-Type: text/html\nLast-Modified: ..")
     * @return {Object}         Returns an object where every key is a header
     *     and every value it's correspondending value.
     */
    function extractResponseHeaders(headers) {
        headers = headers.split('\n');
        var headersObj = {},
            i = 0,
            len = headers.length,
            header = null;
        for (i = 0; i < len; i += 1) {
            header = headers[i].split(': ');
            headersObj[header[0]] = header[1];
        }
        return headersObj;
    }

    /**
     * This function returns a function which can be passed to the jQuery ajax call
     * as callback handler.
     * It will call the sendRequest callback with the correct ajaxResponse interface.
     * @private
     * @function
     * @name browserService-wrapAjaxResponse
     * @param  {Function} complete The original callback function which should be when
     *      the request finishes.
     * @return {Function}          A function which could be passed as a callback handler to
     *      the jquery ajax handler.
     */
    function wrapAjaxResponse(complete) {
        /**
         * Calls the ajax callback function and provides the ajaxResponse in the correct format.
         * This Function gets called by the jQuery ajax callback method.
         * @private
         * @function
         * @name browserService-wrapAjaxResponse-ajaxResponseHandler
         * @param  {Object} jqXhrError   In case of an error this object would become the jqXhr object
         *      otherwise it's the parsed data.
         * @param  {String} status       The status of the ajax call as textstring.
         * @param  {Object} jqXhrSuccess In case of a successfull ajax request this object would
         *      become the jqXhr object.
         */
        return function ajaxResponseHandler(jqXhrError, status, jqXhrSuccess) {
            var jqXhr = jqXhrError,
                success = false;
            if (status === "success") {
                jqXhr = jqXhrSuccess || jqXhrError;
                success = true;
            }
            complete({
                headers: extractResponseHeaders(jqXhr.getAllResponseHeaders()),
                responseText: jqXhr.responseText,
                statusCode: jqXhr.status,
                success: success
            });
        };
    }

    /**
     * @private
     * @function
     * @name browserService-makeAjaxCall
     * @see browserService.sendRequest
     */
    makeAjaxCall = {
        /**
         * @see browserService.sendRequest
         */
        init: function (message) {
            var version = parseFloat(jQuery.fn.jquery);

            if (version <= 1.7) {
                this.init = makeAjaxCall["jQuery<=1.7"];
            } else {
                this.init = makeAjaxCall["jQuery>=1.8"];
            }
            this.init(message);
        },

        /**
         * @see browserService.sendRequest
         */
        "jQuery<=1.7": function (message) {
            message.complete = wrapAjaxResponse(message.oncomplete);
            delete message.oncomplete;
            jQuery.ajax(message);
        },

        /**
         * @see browserService.sendRequest
         */
        "jQuery>=1.8": function (message) {
            var oncomplete = wrapAjaxResponse(message.oncomplete),
                jqXhr;
            delete message.oncomplete;
            jqXhr = jQuery.ajax(message.url, message);
            jqXhr.always(oncomplete);
		}
	};

	function initAjaxService(config) {
		// find jQuery object
		if (config.hasOwnProperty("jQueryObject")) {
			jQuery = core.utils.access(config.jQueryObject);
		} else {
			jQuery = window.jQuery;
		}

		isInitialized = true;
	}

	return {
		init: function () {
			if (!isInitialized) {
				initAjaxService(configService.getServiceConfig("browser") || {});
			} else {
			}
		},

		/**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

		/**
         * Makes an Ajax request to the server.
         * @param {Object} message An AjaxRequest object containing all the information
         *     neccessary for making the request.
         * @param {String} [message.contentType] Set to a string to override the default
         *     content type of the request.
         * @param {String} [message.data] A string containing data to POST to the server.
         * @param {Object} [message.headers] An object whose properties represent HTTP headers.
         * @param {Function} message.oncomplete A callback function to call when the
         *     request has completed.
         * @param {Number} [message.timeout] The number of milliseconds to wait
         *     for a response before closing the Ajax request.
         * @param {String} [message.type="POST"] Either 'GET' or 'POST',
         *     indicating the type of the request to make.
         * @param {String} message.url The URL to send the request to.
         *     This should contain any required query string parameters.
         */
        sendRequest: function (message) {
            message.type = message.type || "POST";
            message.processData = message.processData || false;
            makeAjaxCall.init(message);
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The DOM Capture Service provides the ability to capture a snapshot of
 * the DOM as a HTML snippet.
 * @exports domCaptureService
 */

/*global TLT:true, window: true, Node:true */
/*global console: false */

/**
 * @name domCaptureService
 * @namespace
 */
TLT.addService("domCapture", function (core) {
    "use strict";

    var configService = core.getService("config"),
        messageService,
        isInitialized = false,
        tltUniqueIDIndex = 1,
        dupNode = function () {},
        getDOMCapture = function () {},
        updateConfig = function () {};

    /**
     * Initialization of the service. Subscribe with config service for
     * the configupdated message.
     * @private
     * @function
     * @param {object} config
     */
    function initDOMCaptureService(config) {
        configService.subscribe("configupdated", updateConfig);
        messageService = core.getService("message");
        isInitialized = true;
    }

    /**
     * Destroy the service. Unsubscribe from the configupdated message.
     * @private
     * @function
     */
    function destroyDOMCaptureService() {
        configService.unsubscribe("configupdated", updateConfig);
        isInitialized = false;
    }

    /**
     * Returns a unique identifier string.
     * @private
     * @function
     * @returns {String} A string that can be used as a unique identifier.
     */
    function getUniqueID() {
        var id;

        id = "tlt-" + core.utils.getSerialNumber();

        return id;
    }

    /**
     * Remove child nodes matching the given tag name.
     * @private
     * @function
     * @param {DOMNode} node The root or parent DOM Node element
     * @param {String}  tagName The tag to be removed
     * @returns The node without any tags matching tagName
     */
    function removeTags(node, tagName) {
        var i,
            nodeList;

        // Sanity check
        if (!node || !node.getElementsByTagName || !tagName) {
            return;
        }

        nodeList = node.getElementsByTagName(tagName);
        if (nodeList && nodeList.length) {
            for (i = nodeList.length - 1; i >= 0; i -= 1) {
                nodeList[i].parentNode.removeChild(nodeList[i]);
            }
        }

        return node;
    }

    /**
     * Returns the DOCTYPE of the document as a formatted string.
     * @private
     * @function
     * @param {DOMNode} node A document node.
     * @returns {String} The formatted doctype or null.
     */
    function getDoctypeAsString(node) {
        var doctype,
            doctypeStr = null;

        // Sanity check
        if (!node || !node.doctype) {
            return null;
        }

        doctype = node.doctype;
        if (doctype) {
            doctypeStr = "<!DOCTYPE " + doctype.name +
                         (doctype.publicId ? ' PUBLIC "' + doctype.publicId + '"' : "") +
                         (!doctype.publicId && doctype.systemId ? ' SYSTEM' : "") +
                         (doctype.systemId ? ' "' + doctype.systemId + '"' : "") +
                         ">";
        }

        return doctypeStr;
    }

    /**
     * Fix child input nodes and set attributes such as value & checked.
     * @private
     * @function
     * @param {DOMNode} target The root or parent DOM Node element
     */
    function fixInputs(target) {
        var i,
            j,
            inputElement,
            inputList,
            len,
            radio,
            radioButtons,
            radioLen;

        // Sanity check
        if (!target) {
            return;
        }

        inputList = target.getElementsByTagName("input");
        if (inputList) {
            for (i = 0, len = inputList.length; i < len; i += 1) {
                inputElement = inputList[i];
                switch (inputElement.type) {
                case "checkbox":
                case "radio":
                    if (inputElement.checked) {
                        inputElement.setAttribute("checked", "checked");
                    } else {
                        inputElement.removeAttribute("checked");
                    }
                    break;
                default:
                    inputElement.setAttribute("value", inputElement.value);
                    break;
                }
            }
        }
    }

    /**
     * Fix the child select lists by setting the selected attribute on the option elements of
     * the lists in the target node.
     * @private
     * @function
     * @param {DOMNode} source The root or parent DOM Node element
     * @param {DOMNode} target The target DOM Node element that is a copy of the source
     */
    function fixSelectLists(source, target) {
        var sourceElem,
            sourceList,
            targetElem,
            targetList,
            i,
            j,
            len;

        // Sanity check
        if (!source || !source.getElementsByTagName || !target || !target.getElementsByTagName) {
            return;
        }

        sourceList = source.getElementsByTagName("select");
        targetList = target.getElementsByTagName("select");

        // TODO: ASSERT source and target nodes have same order of select elements

        if (sourceList) {
            for (i = 0, len = sourceList.length; i < len; i += 1) {
                sourceElem = sourceList[i];
                targetElem = targetList[i];
                for (j = 0; j < sourceElem.options.length; j += 1) {
                    if (j === sourceElem.selectedIndex || sourceElem.options[j].selected) {
                        targetElem.options[j].setAttribute("selected", "selected");
                    } else {
                        targetElem.options[j].removeAttribute("selected");
                    }
                }
            }
        }
    }

    /**
     * Return the outer HTML of the document or element.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element
     * @returns {String} The HTML text of the document or element. If the node is not
     * a document or element type then return null.
     */
    function getHTMLText(node) {
        var nodeType,
            htmlText = null;

        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
                // DOCUMENT_NODE
                htmlText = node.documentElement.outerHTML;
                break;
            case 1:
                // ELEMENT_NODE
                htmlText = node.outerHTML;
                break;
            default:
                htmlText = null;
                break;
            }
        }
        return htmlText;
    }

    /**
     * Checks if the DOM node is allowed for capture. Only document and element
     * node types are allowed for capture.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element to be checked
     * @returns {Boolean} Returns true if the node is document or element type.
     */
    function isNodeValidForCapture(node) {
        var nodeType,
            valid = false;
        // Only DOCUMENT (9) & ELEMENT (1) nodes are valid for capturing
        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
            case 1:
                valid = true;
                break;
            default:
                valid = false;
                break;
            }
        }
        return valid;
    }

    /**
     * Capture the frames from the source and add the unique token to the frame element
     * in the target.
     * @private
     * @function
     * @param {DOMNode} source The source element
     * @param {DOMNode} target The target element duplicated from the source.
     * @param {Object}  options The capture options object
     * @returns {Object} Returns the captured frames & canvas elements as per the enabled options.
     */
    function getIframes(source, target, options) {
        var i, j,
            len,
            frameTag,
            frameTags = [ "iframe", "frame" ],
            sourceIframe,
            iframeWindow,
            iframeDoc,
            iframeCapture,
            iframeID,
            returnObject = {
                frames: [],
                canvas: []
            },
            sourceIframeList,
            targetIframeList;

        for (j = 0; j < frameTags.length; j += 1) {
            frameTag = frameTags[j];
            // Get the frames in the original DOM
            sourceIframeList = source.getElementsByTagName(frameTag);

            // Get the cloned frames - the content is not copied here - these will be
            // used to add an attribute to specify which item in the frames collection
            // contains the content for this frame
            targetIframeList = target.getElementsByTagName(frameTag);

            if (sourceIframeList) {
                for (i = 0, len = sourceIframeList.length; i < len; i += 1) {
                    try {
                        sourceIframe = sourceIframeList[i];
                        iframeWindow = core.utils.getIFrameWindow(sourceIframe);
                        if (iframeWindow && iframeWindow.document) {
                            iframeDoc = iframeWindow.document;

                            iframeCapture = getDOMCapture(iframeDoc, iframeDoc, options);
                            iframeID = getUniqueID();
                            // Set the tltid for this frame in the target DOM
                            targetIframeList[i].setAttribute("tltid", iframeID);

                            // Merge this frame's captured DOM into the return object
                            returnObject.frames.push({
                                root: iframeCapture.root,
                                charset: iframeDoc.characterSet || iframeDoc.charset,
                                tltid: iframeID
                            });
                            returnObject.frames = returnObject.frames.concat(iframeCapture.frames);
                            returnObject.canvas = returnObject.canvas.concat(iframeCapture.canvas);
                        }
                    } catch (e) {
                        // Do nothing!
                    }
                }
            }
        }
        return returnObject;
    }

    /**
     * Calculate the total length of the HTML in the captured object.
     * @private
     * @function
     * @param {Object} captureObj The DOM capture object containing the serialized HTML.
     * @returns {Number} Returns the total length of the serialized object.
     */
    function getCapturedLength(captureObj) {
        var i,
            len,
            totalLength = 0;

        if (!captureObj || !captureObj.root) {
            return totalLength;
        }

        totalLength = captureObj.root.length;
        for (i = 0, len = captureObj.frames.length; i < len; i += 1) {
            if (captureObj.frames[i].root) {
                totalLength += captureObj.frames[i].root.length;
            }
        }

        return totalLength;
    }

    /**
     * Clone the provided document or element node.
     * @private
     * @function
     * @param {DOMNode} node The element to be duplicated.
     * @returns {DOMNode} Returns the duplicated node.
     */
    dupNode = function (node) {
        var dup = null;

        if (isNodeValidForCapture(node)) {
            dup = node.cloneNode(true);
            if (!dup && node.documentElement) {
                // Fix for Android and Safari bug which returns null when cloneNode is called on the document element.
                dup = node.documentElement.cloneNode(true);
            }
        }

        return dup;
    };

    /**
     * Capture the DOM starting at the root element as per the provided configuration options.
     * @private
     * @function
     * @param {DOMNode} doc The document element.
     * @param {DOMNode} root The root element that needs to be captured.
     * @param {Object}  options The capture options object.
     * @returns {Object} Returns the object containing the captured and serialized DOM.
     */
    getDOMCapture = function (doc, root, options) {
        var new_doc = null,
            canvasCaptureList,
            frameCaptureObj,
            captureObj = {};

        // Sanity check
        if (!doc || !root) {
            return captureObj;
        }

        new_doc = dupNode(root, doc);

        // Remove script tags
        if (options.removeScripts) {
            removeTags(new_doc, "script");
        }

        // Set "selected" attribute on select list elements
        fixSelectLists(root, new_doc);

        // Set attributes on input elements.
        fixInputs(new_doc);

        // Apply privacy
        new_doc = messageService.applyPrivacyToDocument(new_doc);

        if (options.captureCanvas) {
            // TODO: Get the canvas elements
            canvasCaptureList = null;
        }

        if (options.captureFrames) {
            // Get the iframes
            frameCaptureObj = getIframes(root, new_doc, options);
        }

        // Add all the captured data to the capture object
        if (frameCaptureObj) {
            captureObj = core.utils.mixin(captureObj, frameCaptureObj);
        }
        if (canvasCaptureList) {
            if (!captureObj.canvas) {
                captureObj.canvas = [];
            }
            captureObj.canvas = captureObj.canvas.concat(canvasCaptureList);
        }
        captureObj.root = (getDoctypeAsString(root) || "") + getHTMLText(new_doc);
        captureObj.charset = doc.characterSet || doc.charset;

        return captureObj;
    };

    /**
     * Callback function which receives notification from config service when
     * the configuration is updated.
     * @private
     * @function
     */
    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
    };

    /**
     * @scope domCaptureService
     */
    return {
        /**
         * Callback function invoked by the core to initialize the DOM Capture service.
         * @private
         * @function
         */
        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
            } else {
            }
        },

        /**
         * Callback function invoked by the core to destroy the DOM Capture service.
         * @private
         * @function
         */
        destroy: function () {
            destroyDOMCaptureService();
        },

        /**
         * API function exposed by the DOM Capture service. Accepts the root element and
         * DOM capture options object.
         * @param  {DOMNode} root The root element for the DOM capture.
         * @param  {Object}  options The configuration options for performing the DOM capture.
         * @return {Object} An object containing the captured DOM.
         */
        captureDOM: function (root, options) {
            var captureObj = null,
                totalLength = 0;

            // Sanity check - DOM Capture is not supported on IE 8 and below
            if (!isInitialized || core.utils.isLegacyIE) {
                return captureObj;
            }

            if (!options || typeof options !== "object") {
                options = {};
            }
            root = root || window.document;

            captureObj = getDOMCapture(window.document, root, options);

            // Check if the capture meets the length threshold (if any)
            if (options.maxLength) {
                totalLength = getCapturedLength(captureObj);
                if (totalLength > options.maxLength) {
                    captureObj = {
                        errorCode: 101,
                        error: "Captured length (" + totalLength + ") exceeded limit (" + options.maxLength + ")."
                    };
                }
            }

            return captureObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The EncoderService provides the ability to extend the library with various data encodings.
 * @exports encoderService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name encoderService
 * @namespace
 */
TLT.addService("encoder", function (core) {
    "use strict";

    var encoderServiceConfig = {},
        configService = null,
        handleConfigUpdated = null,
        isInitialized = false;

    /**
     * Returns the encoder object for the specified encoder type.
     * @private
     * @function
     * @param {String} type The type of encoder object. e.g. "gzip"
     * @returns {Object} The encoder object or null if not found.
     */
    function getEncoder(type) {
        var encoder = null;

        // Sanity check
        if (!type) {
            return encoder;
        }
        encoder = encoderServiceConfig[type];
        if (encoder && typeof encoder.encode === "string") {
            encoder.encode = core.utils.access(encoder.encode);
        }

        return encoder;
    }

    /**
     * Initializes the encoder service.
     * @private
     * @function
     * @param {Object} config The configuration object for this service
     */
    function initEncoderService(config) {
        encoderServiceConfig = config;

        configService.subscribe("configupdated", handleConfigUpdated);
        isInitialized = true;
    }

    /**
     * Destroys the encoder service.
     * @private
     * @function
     */
    function destroy() {
        configService.unsubscribe("configupdated", handleConfigUpdated);

        isInitialized = false;
    }

    /**
     * Callback handler for the configupdated event. Refreshes the service configuration to the latest.
     * @private
     * @function
     */
    handleConfigUpdated = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initEncoderService(configService.getServiceConfig("encoder") || {});
    };

    /**
     * @scope serializerService
     */
    return {

        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initEncoderService(configService.getServiceConfig("encoder") || {});
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Encodes data using specified encoder.
         * @param  {String} data The data to encode.
         * @param  {String} type The name of the encoder to use.
         * @return {Object} An object containing the encoded data or error message.
         */
        encode: function (data, type) {
            var encoder,
                result,
                returnObj = {
                    data: null,
                    encoding: null,
                    error: null
                };

            // Sanity check
            if ((typeof data !== "string" && !data) || !type) {
                returnObj.error = "Invalid " + (!data ? "data" : "type") + " parameter.";
                return returnObj;
            }

            // Get the specified encoder
            encoder = getEncoder(type);
            if (!encoder) {
                returnObj.error = "Specified encoder (" + type + ") not found.";
                return returnObj;
            }

            // Sanity check
            if (typeof encoder.encode !== "function") {
                returnObj.error = "Configured encoder (" + type + ") encode method is not a function.";
                return returnObj;
            }

            // Invoke the encode method of the encoder and return the result.
            result = encoder.encode(data);
            if (!result || core.utils.getValue(result, "buffer", null) === null) {
                returnObj.error = "Encoder (" + type + ") returned an invalid result.";
                return returnObj;
            }

            returnObj.data = result.buffer;
            returnObj.encoding = encoder.defaultEncoding;

            return returnObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The MessageService creates messages in the correct format to be transmitted to the server.
 * @exports messageService
 */

/*global TLT:true */

/**
 * @name messageService
 * @namespace
 */
TLT.addService("message", function (core) {
    "use strict";

    var screenviewOffsetTime = null,
        count             = 0,
        messageCount      = 0,
        sessionStart      = new Date(),
        tlStartLoad       = new Date(),
        browserBaseService = core.getService("browserBase"),
        browserService    = core.getService("browser"),
        configService     = core.getService("config"),
        config            = configService.getServiceConfig("message") || {},
        windowHref        = window.location.href,
        windowId          = "TODO",
        pageId            = "ID" + tlStartLoad.getHours() + "H" +
                            tlStartLoad.getMinutes() + "M" +
                            tlStartLoad.getSeconds() + "S" +
                            tlStartLoad.getMilliseconds() + "R" +
                            Math.random(),
        privacy           = config.hasOwnProperty("privacy") ? config.privacy : [],
        privacyMasks      = {},
        maskingCharacters = {
            lower: "x",
            upper: "X",
            numeric: "9",
            symbol: "@"
        },

        //TODO move these to a global section due to they might be used elsewhere
        isApple = navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPod") > -1 || navigator.userAgent.indexOf("iPad") > -1,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Android") > -1,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = window.screen ? window.screen.width : 0,
        deviceOriginalHeight = window.screen ? window.screen.height : 0,
        deviceOrientation = window.orientation || 0,
        deviceWidth = isApple || isAndroidChrome ? deviceOriginalWidth : deviceOriginalWidth <= 320 ? deviceOriginalWidth : deviceOriginalWidth / devicePixelRatio,
        deviceHeight = isApple || isAndroidChrome ? deviceOriginalHeight : deviceOriginalWidth <= 320 ? deviceOriginalHeight : deviceOriginalHeight / devicePixelRatio,
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        startWidth = window.innerWidth || document.documentElement.clientWidth,
        startHeight = window.innerHeight || document.documentElement.clientHeight,
        isInitialized = false;


    /**
     * Base structure for a message object.
     * @constructor
     * @private
     * @name messageService-Message
     * @param {Object} event The QueueEvent to transform into a message object.
     */
    function Message(event) {
        var key = '';

        /**
         * The message type.
         * @type {Number}
         * @see browserService-Message.TYPES
         */
        this.type          = event.type;
        /**
         * The offset from the beginning of the session.
         * @type {Number}
         */
        this.offset        = (new Date()).getTime() - sessionStart.getTime();
        /**
         * The offset from the most recent application context message.
         * @type {Number}
         */
        if ((event.type === 2) || (screenviewOffsetTime === null)) {
            screenviewOffsetTime = new Date();
        }
        this.screenviewOffset = (new Date()).getTime() - screenviewOffsetTime.getTime();

        /**
         * The count of the overall messages until now.
         * @type {Number}
         */
        this.count         = (messageCount += 1);

        /**
         * To indicate that user action came from the web.
         * @type {Boolean}
         */
        this.fromWeb       = true;

        // iterate over the properties in the queueEvent and add all the objects to the message.
        for (key in event) {
            if (event.hasOwnProperty(key)) {
                this[key] = event[key];
            }
        }
    }

    /**
     * Empty filter. Returns an empty string which would be used as value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns an empty string.
     */
    privacyMasks.PVC_MASK_EMPTY = function (value) {
        return "";
    };

    /**
     * Basic filter. Returns a predefined string for every value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a predefined mask/string.
     */
    privacyMasks.PVC_MASK_BASIC = function (value) {
        var retMask = "XXXXX";

        // Sanity check
        if (typeof value !== "string") {
            return "";
        }
        return (value.length ? retMask : "");
    };

    /**
     * Type filter. Returns predefined values for uppercase/lowercase
     *                         and numeric values.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a string/mask which uses predefined
     *                        characters to mask the value.
     */
    privacyMasks.PVC_MASK_TYPE = function (value) {
        var characters,
            i = 0,
            len = 0,
            retMask = "";

        // Sanity check
        if (typeof value !== "string") {
            return retMask;
        }

        characters = value.split("");

        for (i = 0, len = characters.length; i < len; i += 1) {
            if (core.utils.isNumeric(characters[i])) {
                retMask += maskingCharacters.numeric;
            } else if (core.utils.isUpperCase(characters[i])) {
                retMask += maskingCharacters.upper;
            } else if (core.utils.isLowerCase(characters[i])) {
                retMask += maskingCharacters.lower;
            } else {
                retMask += maskingCharacters.symbol;
            }
        }
        return retMask;
    };

    privacyMasks.PVC_MASK_EMPTY.maskType = 1; // reported value is empty string.
    privacyMasks.PVC_MASK_BASIC.maskType = 2; // reported value is fixed string "XXXXX".
    privacyMasks.PVC_MASK_TYPE.maskType = 3;  // reported value is a mask according to character type
                                              // as per configuration, e.g. "HelloWorld123" becomes "XxxxxXxxxx999".
    privacyMasks.PVC_MASK_CUSTOM = {
        maskType: 4 // reported value is return value of custom function provided by config.
    };

    /**
     * Checks which mask should be used to replace the value and applies
     * it to the string. If an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask The privacy object.
     * @param  {String} str  The string to be masked.
     */
    function maskStr(mask, str) {
        var filter = privacyMasks.PVC_MASK_BASIC;

        // Sanity check
        if (typeof str !== "string") {
            return str;
        }

        if (!mask) {
            // Default
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_EMPTY.maskType) {
            filter = privacyMasks.PVC_MASK_EMPTY;
        } else if (mask.maskType === privacyMasks.PVC_MASK_BASIC.maskType) {
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_TYPE.maskType) {
            filter = privacyMasks.PVC_MASK_TYPE;
        } else if (mask.maskType === privacyMasks.PVC_MASK_CUSTOM.maskType) {
            if (typeof mask.maskFunction === "string") {
                filter = core.utils.access(mask.maskFunction);
            } else {
                filter = mask.maskFunction;
            }
            if (typeof filter !== "function") {
                // Reset to default
                filter = privacyMasks.PVC_MASK_BASIC;
            }
        }
        return filter(str);
    }

    /**
     * Checks which mask should be used to replace the value and applies
     * it on the message object. By default, if an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask    The privacy object.
     * @param  {Object} message The entire message object.
     */
    function applyMask(mask, message) {
        // Sanity check
        if (!message || !message.target) {
            return;
        }

        if (typeof message.target.prevState !== "undefined" && message.target.prevState.hasOwnProperty("value")) {
            message.target.prevState.value = maskStr(mask, message.target.prevState.value);
        }
        if (typeof message.target.currState !== "undefined" && message.target.currState.hasOwnProperty("value")) {
            message.target.currState.value = maskStr(mask, message.target.currState.value);
        }
    }

    /**
     * Checks whether one of the privacy targets matches the target
     *                          of the current mesage.
     * TODO: There are several places in the library where the same type
     * of matching result is required based on id or selector. This should
     * be consolidated into a single helper function.
     * @param  {Array} targets An array of objects as defined in the
     *                         privacy configuration.
     * @param  {Object} target  The target object of the message.
     * @return {Boolean}         Returns true if one of the targets match.
     *                           Otherwise false.
     */
    function matchesTarget(targets, target) {
        var i,
            j,
            element,
            qr,
            qrLen,
            qrTarget,
            regex,
            len,
            tmpTarget;

        // Sanity check
        if (!targets || !target || !target.id) {
            return false;
        }

        for (i = 0, len = targets.length; i < len; i += 1) {
            tmpTarget = targets[i];

            // Check if target in config is a selector string.
            if (typeof tmpTarget === "string") {
                qr = browserService.queryAll(tmpTarget);
                for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                    if (qr[j]) {
                        qrTarget = browserBaseService.ElementData.prototype.examineID(qr[j]);
                        if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                            return true;
                        }
                    }
                }
            } else if (tmpTarget.id && tmpTarget.idType && target.idType.toString() === tmpTarget.idType.toString()) {
                // Note: idType provided by wizard is a string so convert both to strings before comparing.

                // An id in the configuration could be a direct match, in which case it will be a string OR
                // it could be a regular expression in which case it would be an object like this:
                // {regex: ".+private$", flags: "i"}
                switch (typeof tmpTarget.id) {
                case "string":
                    if (tmpTarget.id === target.id) {
                        return true;
                    }
                    break;
                case "object":
                    regex = new RegExp(tmpTarget.id.regex, tmpTarget.id.flags);
                    if (regex.test(target.id)) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    /**
     * Runs through all privacy configurations and checks if it matches
     * the current message object.
     * @param  {Object} message The message object.
     * @return {Object}         The message, either with replaced values
     *                          if a target of the privacy configuration
     *                          matched or the original message if the
     *                          configuration didn't match.
     */
    function privacyFilter(message) {
        var i,
            len,
            mask;

        if (!message || !message.hasOwnProperty("target")) {
            return message;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            if (matchesTarget(mask.targets, message.target)) {
                applyMask(mask, message);
                break;
            }
        }
        return message;
    }

    /**
     * Applies the privacy configuration to all the matching elements
     * of the specified document object.
     * @param  {DOMDocument} doc The document object to which the privacy rules
     *                      need to be applied.
     * @return {DOMDocument}     The document object to which the privacy rules
     *                      have been applied.
     */
    function applyPrivacyToDocument(doc) {
        var i, j, k,
            element,
            len,
            mask,
            qr,
            qrLen,
            target,
            targets,
            targetsLen;

        // Sanity check
        if (!doc) {
            return doc;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            targets = mask.targets;
            for (j = 0, targetsLen = targets.length; j < targetsLen; j += 1) {
                target = targets[j];
                if (typeof target === "string") {
                    // CSS selector
                    qr = browserService.queryAll(target, doc);
                    for (k = 0, qrLen = qr.length; k < qrLen; k += 1) {
                        element = qr[k];
                        if (element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                } else {
                    if (typeof target.id === "string") {
                        element = browserBaseService.getNodeFromID(target.id, target.idType, doc);
                        if (element && element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                    // TODO: Handle the case where the target.id is a regex.
                    /*
                     * 1. Save all the regex rules into 3 arrays depending on the idType
                     * {
                     *     htmlID: [ {regex, mask} ],
                     *     xpathID: [],
                     *     customID: []
                     * }
                     * 2. Outside this for loop, get all the input elements in the document
                     * 3. Get element id, idType
                     */
                }
            }
        }

        return doc;
    }

    /**
     * Gets called when the configserver fires configupdated event.
     */
    function updateConfig() {
        configService = core.getService("config");
        config = configService.getServiceConfig("message") || {};
        privacy = config.hasOwnProperty("privacy") ? config.privacy : [];
    }

    function initMessageService() {
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }


    /**
     * @scope messageService
     */
    return {

        init: function () {
            if (!isInitialized) {
                initMessageService();
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        applyPrivacyToDocument: applyPrivacyToDocument,

        /**
         * Accepts a simple queue event  and wraps it into a complete message that the server can understand.
         * @param  {Object} event The simple event information
         * @return {Object}       A complete message that is ready for transmission to the server.
         */
        createMessage: function (event) {
            if (typeof event.type === "undefined") {
                throw new TypeError("Invalid queueEvent given!");
            }
            return privacyFilter(new Message(event));
        },

        /**
         * Mock function to create a JSON structure around messages before sending to server.
         * @param  {Array} messages An array of messages
         * @return {Object}          Returns a JavaScript object which can be serialized to JSON
         *      and send to the server.
         *  @todo rewrite functionality
         */
        wrapMessages: function (messages) {
            var messagePackage = {
                messageVersion: "4.0.0.0",
                serialNumber: (count += 1),
                sessions: [{
                    id: pageId,
                    startTime: tlStartLoad.getTime(),
                    timezoneOffset: tlStartLoad.getTimezoneOffset(),
                    messages: messages,
                    clientEnvironment: {
                        webEnvironment: {
                            libVersion: "4.0.0.1607",
                            page: windowHref,
                            windowId: windowId,
                            screen: {
                                devicePixelRatio: devicePixelRatio,
                                deviceOriginalWidth: isApple || isAndroidChrome ? deviceOriginalWidth * devicePixelRatio : deviceOriginalWidth,
                                deviceOriginalHeight: isApple || isAndroidChrome ? deviceOriginalHeight * devicePixelRatio : deviceOriginalHeight,
                                deviceWidth: deviceWidth,
                                deviceHeight: deviceHeight,
                                deviceToolbarHeight: deviceToolbarHeight,
                                width: startWidth,
                                height: startHeight,
                                orientation: deviceOrientation
                            }
                        }
                    }
                }]
            },
                webEnvScreen = messagePackage.sessions[0].clientEnvironment.webEnvironment.screen;

            webEnvScreen.orientationMode = core.utils.getOrientationMode(webEnvScreen.orientation);
            /*
            if (true) { // Add usability to config settings
                //messagePackage.domainId = "<<TODO domainId>>"; This was used to send to correct posting url, no longer needed. Followup with Chris. Checked with Joe.
                //messagePackage.samplingRate = "<<TODO samplingRate>>"; This is no longer needed. We will not focus on sampling for this release of 8.6.
            }
            */
            return messagePackage;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SerializerService provides the ability to serialize
 * data into one or more string formats.
 * @exports serializerService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name serializerService
 * @namespace
 */
TLT.addService("serializer", function (core) {
    "use strict";

    /**
     * JSON serializer. If possible it uses JSON.stringify method, but
     * for older browsers it provides minimalistic implementaction of
     * custom serializer (limitations: does not detect circular
     * dependencies, does not serialize date objects and does not
     * validate names of object fields).
     * @private
     * @function
     * @name serializerService-serializeToJSON
     * @param {Any} obj - any value
     * @returns {string} serialized string
     */
    function serializeToJSON(obj) {
        var str,
            key,
            len = 0;
        if (typeof obj !== "object" || obj === null) {
            switch (typeof obj) {
            case "function":
            case "undefined":
                return "null";
            case "string":
                return '"' + obj.replace(/\"/g, '\\"') + '"';
            default:
                return String(obj);
            }
        } else if (Object.prototype.toString.call(obj) === "[object Array]") {
            str = "[";
            for (key = 0, len = obj.length; key < len; key += 1) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str += serializeToJSON(obj[key]) + ",";
                }
            }
        } else {
            str = "{";
            for (key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str = str.concat('"', key, '":', serializeToJSON(obj[key]), ",");
                    len += 1;
                }
            }
        }
        if (len > 0) {
            str = str.substring(0, str.length - 1);
        }
        str += String.fromCharCode(str.charCodeAt(0) + 2);
        return str;
    }


    /**
     * Serializer / Parser implementations
     * @type {Object}
     */
    var configService = core.getService("config"),
        serialize = {},
        parse = {},
        defaultSerializers = {
            json: (function () {
                if (typeof window.JSON !== "undefined") {
                    return {
                        serialize: window.JSON.stringify,
                        parse: window.JSON.parse
                    };
                }

                return {
                    serialize: serializeToJSON,
                    // TODO: find a better way than using eval
                    parse: function (data) {
                        return eval("(" + data + ")");
                    }
                };
            }())
        },
        updateConfig = null,
        isInitialized = false;

    function addObjectIfExist(paths, rootObj, propertyName) {
        var i,
            len,
            obj;

        paths = paths || [];
        for (i = 0, len = paths.length; i < len; i += 1) {
            obj = paths[i];
            if (typeof obj === "string") {
                obj = core.utils.access(obj);
            }
            if (typeof obj === "function") {
                rootObj[propertyName] = obj;
                break;
            }
        }
    }
	function checkParserAndSerializer() {
		var isParserAndSerializerInvalid;
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
			isParserAndSerializerInvalid = true;
        } else {
			if (typeof parse.json('{"foo": "bar"}') === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = parse.json('{"foo": "bar"}').foo !== "bar";
			}
			if (typeof parse.json("[1, 2]") === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1, 2]")[0] !== 1;
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1,2]")[1] !== 2;
			}
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json({"foo": "bar"}) !== '{"foo":"bar"}';
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json([1, 2]) !== "[1,2]";
		}
		return isParserAndSerializerInvalid;
	}
    function initSerializerService(config) {
        var format;
        for (format in config) {
            if (config.hasOwnProperty(format)) {
                addObjectIfExist(config[format].stringifiers, serialize, format);
                addObjectIfExist(config[format].parsers, parse, format);
            }
        }

        // use default JSON parser/serializer if possible
        if (!(config.json && config.json.hasOwnProperty("defaultToBuiltin")) || config.json.defaultToBuiltin === true) {
            serialize.json = serialize.json || defaultSerializers.json.serialize;
            parse.json = parse.json || defaultSerializers.json.parse;
        }

        //sanity check
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
            core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.");
        }
		if (checkParserAndSerializer()) {
			core.fail("JSON stringification and parsing are not working as expected");
		}
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }


    function destroy() {
        serialize = {};
        parse = {};

        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed. Verify initSerializerService is idempotent
        initSerializerService(configService.getServiceConfig("serializer") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        init: function () {
            if (!isInitialized) {
                initSerializerService(configService.getServiceConfig("serializer") || {});
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Parses a string into a JavaScript object.
         * @param  {String} data The string to parse.
         * @param  {String} [type="json"] The format of the data.
         * @return {Object}      An object representing the string data.
         */
        parse: function (data, type) {
            type = type || "json";
            return parse[type](data);
        },

        /**
         * Serializes object data into a string using the format specified.
         * @param  {Object} data The data to serialize.
         * @param  {String} [type="json"] The format to serialize the data into.
         * @return {String}      A string containing the serialization of the data.
         */
        serialize: function (data, type) {
            type = type || "json";
            return serialize[type](data);
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Overstat module implements the logic for collecting
 * data for cxOverstat. The current uses are for the Hover Event and
 * Hover To Click event.
 * @exports overstat
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name overstat
     * @namespace
     */
    TLT.addModule("overstat", function (context) {
        "use strict";

        var tlTypes = {
            "input:radio": "radioButton",
            "input:checkbox": "checkBox",
            "input:text": "textBox",
            "input:password": "textBox",
            "input:file": "fileInput",
            "input:button": "button",
            "input:submit": "submitButton",
            "input:reset": "resetButton",
            "input:image": "image",
            "input:color": "color",
            "input:date": "date",
            "input:datetime": "datetime",
            "input:datetime-local": "datetime-local",
            "input:number": "number",
            "input:email": "email",
            "input:tel": "tel",
            "input:search": "search",
            "input:url": "url",
            "input:time": "time",
            "input:week": "week",
            "input:month": "month",
            "textarea:": "textBox",
            "select:": "selectList",
            "button:": "button",
            "a:": "link"
        },

            eventMap = {},
            configDefaults = { "UPDATE_INTERVAL" : 250,
                                "HOVER_THRESHOLD_MIN" : 1000,
                                "HOVER_THRESHOLD_MAX" : 2 * 60 * 1000,
                                "GRIDCELL_MAX_X" : 10,
                                "GRIDCELL_MAX_Y" : 10,
                                "GRIDCELL_MIN_WIDTH" : 20,
                                "GRIDCELL_MIN_HEIGHT" : 20
                };

        /**
         * Used to test and get value from an object.
         * @private
         * @function
         * @name replay-getValue
         * @param {object} parentObj An object you want to get a value from.
         * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
         * @return {object} If object is found, if not then null will be returned.
         */
        function getValue(parentObj, propertyAsStr) {
            var i,
                properties;

            // Sanity check
            if (!parentObj || typeof parentObj !== "object") {
                return null;
            }

            properties = propertyAsStr.split(".");
            for (i = 0; i < properties.length; i += 1) {
                if ((typeof parentObj === "undefined") || (parentObj[properties[i]] === null)) {
                    return null;
                }
                parentObj = parentObj[properties[i]];
            }
            return parentObj;
        }

        function getConfigValue(key) {
            var overstatConfig = context.getConfig() || {},
                value = overstatConfig[key];
            return typeof value === "number" ? value : configDefaults[key];
        }

        function postUIEvent(hoverEvent, options) {
            var tagName = getValue(hoverEvent, "webEvent.target.element.tagName") || "",
                type = tagName.toLowerCase() === "input" ? getValue(hoverEvent, "webEvent.target.element.type") : "",
                tlType = tlTypes[tagName.toLowerCase() + ":" + type] || tagName,

                uiEvent = {
                    type: 9,
                    event: {
                        hoverDuration: hoverEvent.hoverDuration,
                        hoverToClick: getValue(options, "hoverToClick")
                    },
                    target: {
                        id: getValue(hoverEvent, "webEvent.target.id") || "",
                        idType: getValue(hoverEvent, "webEvent.target.idType") || "",
                        name: getValue(hoverEvent, "webEvent.target.name") || "",
                        tlType: tlType,
                        type: tagName,
                        subType: type,
                        position: {
                            width: getValue(hoverEvent, "webEvent.target.element.offsetWidth") || 0,
                            height: getValue(hoverEvent, "webEvent.target.element.offsetHeight") || 0,
                            relXY: hoverEvent.gridX + "," + hoverEvent.gridY
                        }
                    }
                };

                // if id is null or empty, what are we firing on? it can't be replayed anyway
            if ((typeof uiEvent.target.id) === undefined || uiEvent.target.id === "") {
                return;
            }

            context.post(uiEvent);
        }

        function stopNode(node) {
            if (node && node.element) { node = node.element; }
            return !node || node === document.body || node === document.html || node === document;
        }

        function getParent(node) {
            if (!node) { return null; }
            return node.element ? node.element.parentNode : node.parentNode;
        }

        function getOffsetParent(node) {
            if (!node) { return null; }
            var parent = node.element ? node.element.offsetParent : node.offsetParent;
            return parent || getParent(node);
        }

        /*
         * for when mouseout is called - if you have moved over a child element, mouseout is fired for the parent element
         * @private
         * @function
         * @name overstat-isChildOf
         * @return {boolean} Returns whether node is a child of root
         */
        function isChildOf(root, node) {
            if (!node || node === root) { return false; }
            node = getParent(node);

            while (!stopNode(node)) {
                if (node === root) { return true; }
                node = getParent(node);
            }

            return false;
        }

        function getNativeEvent(e) {
            if (e.nativeEvent) { e = e.nativeEvent; }
            return e;
        }

        function getNativeTarget(e) {
            return getNativeEvent(e).target;
        }

        function getNativeNode(node) {
            if (!node) { return null; }
            return node.element || node;
        }

        function getNodeType(node) {
            if (!node) { return -1; }
            if (node.element) { node = node.element; }
            return node.nodeType || -1;
        }

        function getNodeTagName(node) {
            if (!node) { return ""; }
            if (node.element) { node = node.element; }
            return node.tagName ? node.tagName.toUpperCase() : "";
        }

        function getNodeElement(node) {
            if (node && node.element) { node = node.element; }
            return node;
        }

        function stopEventPropagation(e) {
            if (!e) { return; }
            if (e.nativeEvent) { e = e.nativeEvent; }

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.cancelBubble) {
                e.cancelBubble();
            }
        }

        function ignoreNode(node) {
            var tagName = getNodeTagName(node);
            return getNodeType(node) !== 1 || tagName === "TR" || tagName === "TBODY" || tagName === "THEAD";
        }

        /**
         * Generates an XPath for a given node, stub method until the real one is available
         * @function
         */
        function getXPathFromNode(node) {
            if (!node) { return ""; }
            if (node.xPath) { return node.xPath; }
            node = getNativeNode(node);
            return context.getXPathFromNode(node);
        }

        /*
         * replacement for lang.hitch(), setTimeout loses all scope
         * @private
         * @function
         * @name overstat-callHoverEventMethod
         * @return {object} Returns the value of the called method
         */
        function callHoverEventMethod(key, methodName) {
            var hEvent = eventMap[key];
            if (hEvent && hEvent[methodName]) { return hEvent[methodName](); }
        }

        function HoverEvent(dm, gx, gy, webEvent) {
            this.xPath = dm !== null ? getXPathFromNode(dm) : "";
            this.domNode = dm;
            this.hoverDuration = 0;
            this.hoverUpdateTime = 0;
            this.gridX = Math.max(gx, 0);
            this.gridY = Math.max(gy, 0);
            this.parentKey = "";
            this.updateTimer = -1;
            this.disposed = false;
            this.childKeys = {};
            this.webEvent = webEvent;

            /*
             * @public
             * @function
             * @name overstat-HoverEvent.getKey
             * @return {string} Returns the string unique key of this event
             */
            this.getKey = function () {
                return this.xPath + ":" + this.gridX + "," + this.gridY;
            };

            /*
             * update hoverTime, set timer to update again
             * @public
             * @function
             * @name overstat-HoverEvent.update
             */
            this.update = function () {
                var curTime = new Date().getTime(),
                    key = this.getKey();

                if (this.hoverUpdateTime !== 0) {
                    this.hoverDuration += curTime - this.hoverUpdateTime;
                }

                this.hoverUpdateTime = curTime;

                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(function () { callHoverEventMethod(key, "update"); }, getConfigValue("UPDATE_INTERVAL"));
            };

            /*
             * leaveClone is true if you want to get rid of an event but leave a new one in it's place.
             * usually this will happen due to a click, where the hover ends, but you want a new hover to
             * begin in the same place
             * @public
             * @function
             * @name overstat-HoverEvent.dispose
             */
            this.dispose = function (leaveClone) {
                clearTimeout(this.updateTimer);
                delete eventMap[this.getKey()];
                this.disposed = true;

                if (leaveClone) {
                    var cloneEvt = this.clone();
                    eventMap[cloneEvt.getKey()] = cloneEvt;
                    cloneEvt.update();
                }
            };

            /*
             * clear update timer, add to hover events queue if threshold is reached, dispose in any case
             * @public
             * @function
             * @name overstat-HoverEvent.process
             * @return {boolean} Returns whether or not the event met the threshold requirements and was added to the queue
             */
            this.process = function (wasClicked) {
                clearTimeout(this.updateTimer);
                if (this.disposed) { return false; }

                var addedToQueue = false,
                    hEvent = this,
                    key = null;
                if (this.hoverDuration >= getConfigValue("HOVER_THRESHOLD_MIN")) {
                    this.hoverDuration = Math.min(this.hoverDuration, getConfigValue("HOVER_THRESHOLD_MAX"));
                    // add to ui event queue here
                    addedToQueue = true;
                    postUIEvent(this, { hoverToClick : !!wasClicked });

                    while (typeof hEvent !== "undefined") {
                        hEvent.dispose(wasClicked);
                        hEvent = eventMap[hEvent.parentKey];
                    }
                } else {
                    this.dispose(wasClicked);
                }

                return addedToQueue;
            };

            /*
             * return a fresh copy of this event
             * @public
             * @function
             * @name overstat-HoverEvent.clone
             * @return {HoverTest} Returns a copy of this event with a reset hover time
             */
            this.clone = function () {
                var cloneEvent = new HoverEvent(this.domNode, this.gridX, this.gridY);
                cloneEvent.parentKey = this.parentKey;

                return cloneEvent;
            };
        }

        function createHoverEvent(node, x, y, webEvt) {
            return new HoverEvent(node, x, y, webEvt);
        }

        /*
         * get element offset according to the top left of the document
         * @private
         * @function
         * @name overstat-calculateNodeOffset
         * @return {object} Returns an object with x and y offsets
         */
        function calculateNodeOffset(node) {
            if (node && node.position) { return { x: node.position.x, y: node.position.y }; }
            node = getNodeElement(node);
            var offsetX = node.offsetLeft,
                offsetY = node.offsetTop,
                lastOffsetX = offsetX,
                lastOffsetY = offsetY,
                offsetDiffX = 0,
                offsetDiffY = 0,
                curNode = getOffsetParent(node);

            while (curNode) {
                if (stopNode(curNode)) { break; }

                offsetDiffX = curNode.offsetLeft - (curNode.scrollLeft || 0);
                offsetDiffY = curNode.offsetTop - (curNode.scrollTop || 0);

                if (offsetDiffX !== lastOffsetX || offsetDiffY !== lastOffsetY) {
                    offsetX += offsetDiffX;
                    offsetY += offsetDiffY;

                    lastOffsetX = offsetDiffX;
                    lastOffsetY = offsetDiffY;
                }

                curNode = getOffsetParent(curNode);
            }

            if (isNaN(offsetX)) { offsetX = 0; }
            if (isNaN(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * calculate position relative to top left corner of element
         * @private
         * @function
         * @name overstat-calculateRelativeCursorPos
         * @return {object} Returns an object with x and y offsets
         */
        function calculateRelativeCursorPos(node, cursorX, cursorY) {
            node = getNodeElement(node);
            var nodeOffset = calculateNodeOffset(node),
                offsetX = cursorX - nodeOffset.x,
                offsetY = cursorY - nodeOffset.y;

            if (!isFinite(offsetX)) { offsetX = 0; }
            if (!isFinite(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * determine grid cell dimensions based on the constants
         * @private
         * @function
         * @name overstat-calculateGridCell
         * @return {object} Returns the x and y grid location
         */
        function calculateGridCell(node, offsetX, offsetY) {
            node = getNodeElement(node);
            var cellWidth = node.offsetWidth > 0 ? Math.max(node.offsetWidth / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_WIDTH")) : getConfigValue("GRIDCELL_MIN_WIDTH"),
                cellHeight = node.offsetHeight > 0 ? Math.max(node.offsetHeight / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_HEIGHT")) : getConfigValue("GRIDCELL_MIN_HEIGHT"),

                cellX = Math.floor(offsetX / cellWidth),
                cellY = Math.floor(offsetY / cellHeight);

            if (!isFinite(cellX)) { cellX = 0; }
            if (!isFinite(cellY)) { cellY = 0; }
            return { x: cellX, y: cellY };
        }

        /*
         * called when a hover event fires - processes all unrelated hover events from the queue.
         * events are related if they are the calling event, or any parent events
         * @private
         * @function
         * @name overstat-cleanupHoverEvents
         */
        function cleanupHoverEvents(curEvent) {
            var hEvent = curEvent,
                curKey = curEvent.getKey(),
                allowedKeyMap = {},
                key = null,
                childKey = null;

            allowedKeyMap[curKey] = true;

            while (typeof hEvent !== "undefined") {
                allowedKeyMap[hEvent.parentKey] = true;
                if (hEvent.parentKey === "" || hEvent.parentKey === hEvent.getKey()) {
                    break;
                }

                hEvent = eventMap[hEvent.parentKey];
            }

            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key) && !allowedKeyMap[key]) {
                    hEvent = eventMap[key];
                    if (hEvent) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * similar to cleanupHoverEvents, this will process all events within a domNode (fired on mouseout)
         * @private
         * @function
         * @name overstat-processEventsByDomNode
         */
        function processEventsByDomNode(eventNode, keyToIgnore) {
            var hEvent = null,
                key = null;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    if (hEvent.domNode === eventNode && hEvent.getKey() !== keyToIgnore) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * 1) determine element and grid position for event
         * 2) find existing matching event if possible
         * 3) update event hover time
         * 4) bubble to parent node, for linking purposes
         * within the UI SDK framework, this should be called for each node in the heirarchy (box model)
         * going top down. so the parent (if the calculation is correct) should already exist, and have
         * it's own parent link, which helps during cleanupHoverEvents
         * @private
         * @function
         * @name overstat-hoverHandler
         * @return {HoverEvent} Returns the relevant HoverEvent object (either found or created)
         */
        function hoverHandler(e, node, isParent) {
            if (!node) { node = e.target; }
            if (stopNode(node)) { return null; }
            if (context.utils.isiOS || context.utils.isAndroid) { return null; }

            var rPos, gPos, hEvent, key, parentKey, parentEvent, offsetParent;

            if (!ignoreNode(node)) {
                rPos = calculateRelativeCursorPos(node, e.position.x, e.position.y);
                gPos = calculateGridCell(node, rPos.x, rPos.y);
                hEvent = new HoverEvent(node, gPos.x, gPos.y, e);
                key = hEvent.getKey();

                if (eventMap[key]) {
                    hEvent = eventMap[key];
                } else {
                    eventMap[key] = hEvent;
                }

                hEvent.update();

                // link parent, but in the case that it refers to itself (sometimes with frames) make sure the parentKey
                // is not the same as the current key
                if (!isParent) {
                    offsetParent = getOffsetParent(node);
                    if (offsetParent) {
                        parentEvent = hoverHandler(e, offsetParent, true);
                        if (parentEvent !== null) {
                            parentKey = parentEvent.getKey();
                            key = hEvent.getKey();
                            if (key !== parentKey) {
                                hEvent.parentKey = parentKey;
                            }
                        }
                    }

                    cleanupHoverEvents(hEvent);
                }
            } else {
                hEvent = hoverHandler(e, getOffsetParent(node), isParent);
            }

            return hEvent;
        }

        /*
         * process all events related to the event target, as hovering stops when leaving the element
         * @private
         * @function
         * @name overstat-leaveHandler
         */
        function leaveHandler(e) {
            e = getNativeEvent(e);
            if (isChildOf(e.target, e.relatedTarget)) {
                return;
            }

            processEventsByDomNode(e.target);
        }

        /*
         * on click, resolve current hover events, and reset hover count
         * @private
         * @function
         * @name overstat-clickHandler
         */
        function clickHandler(e) {
            var hEvent = null, key;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    hEvent.process(true);
                }
            }
        }

        /*
         * switches on window event type and routes it appropriately
         * @private
         * @function
         * @name overstat-handleEvent
         */
        function handleEvent(e) {
            var targetId = getValue(e, "target.id");

            // Sanity check
            if (!targetId) {
                return;
            }

            switch (e.type) {
            case "mousemove":
                hoverHandler(e);
                break;
            case "mouseout":
                leaveHandler(e);
                break;
            case "click":
                clickHandler(e);
                break;
            }
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {


            /**
             * Initialize the overstat module.
             */
            init: function () {
            },

            /**
             * Terminate the overstat module.
             */
            destroy: function () {
                var key, i;
                for (key in eventMap) {
                    if (eventMap.hasOwnProperty(key)) {
                        eventMap[key].dispose();
                        delete eventMap[key];
                    }
                }
            },

            /**
             * Handle events subscribed by the overstat module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                handleEvent(event);
            },

            /**
             * Handle system messages subscribed by the overstat module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            },

			createHoverEvent: createHoverEvent,
			cleanupHoverEvents: cleanupHoverEvents,
            eventMap: eventMap
        };
    });  // End of TLT.addModule
} else {


}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Performance module implements the logic for monitoring and
 * reporting performance data such as the W3C Navigation Timing.
 * @exports performance
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name performance
     * @namespace
     */
    TLT.addModule("performance", function (context) {
        "use strict";

        var moduleState = {
                loadReceived: false,
                unloadReceived: false,
                perfEventSent: false
            },
            calculatedRenderTime = 0;


        /**
         * Returns true if the property is filtered out. The property is considered
         * to be filtered out if it exists in the filter object with a value of true.
         * @private
         * @function
         * @name performance-isFiltered
         * @param {string} prop The property name to be tested.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {boolean} true if the property is filtered out, false otherwise.
         */
        function isFiltered(prop, filter) {
            // Sanity check
            if (typeof prop !== "string") {
                return false;
            }

            // If there is no filter object then the property is not filtered out.
            if (!filter || typeof filter !== "object") {
                return false;
            }

            return (filter[prop] === true);
        }

        /**
         * Returns the normalized timing object. Normalized values are offsets measured
         * from the "navigationStart" timestamp which serves as the epoch. Also applies
         * the filter.
         * @private
         * @function
         * @name performance-parseTiming
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {object} The normalized timing properties.
         */
        function parseTiming(timing, filter) {
            var epoch = 0,
                normalizedTiming = {},
                prop = "",
                value = 0;

            // Sanity checks
            if (!timing || typeof timing !== "object" || !timing.navigationStart) {
                return {};
            }

            epoch = timing.navigationStart;
            for (prop in timing) {
                // IE_COMPAT, FF_COMPAT: timing.hasOwnProperty(prop) returns false for
                // performance timing members in IE 9 and Firefox 14.0.1.

                // IE_COMPAT: timing.hasOwnProperty does not exist in IE8 and lower for
                // host objects. Legacy IE does not support hasOwnProperty on hosted objects.
                if (Object.prototype.hasOwnProperty.call(timing, prop) || typeof timing[prop] === "number") {
                    if (!isFiltered(prop, filter)) {
                        value = timing[prop];
                        if (typeof value === "number" && value && prop !== "navigationStart") {
                            normalizedTiming[prop] = value - epoch;
                        } else {
                            normalizedTiming[prop] = value;
                        }
                    }
                }
            }

            return normalizedTiming;
        }

        /**
         * Calculates the render time from the given timing object.
         * @private
         * @function
         * @name performance-getRenderTime
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @return {integer} The calculated render time or 0.
         */
        function getRenderTime(timing) {
            var renderTime = 0,
                startTime,
                endTime,
                utils = context.utils;

            if (timing) {
                // Use the lesser of domLoading or responseEnd as the start of render, see data in CS-8915
                startTime = (timing.responseEnd > 0 && timing.responseEnd < timing.domLoading) ? timing.responseEnd : timing.domLoading;
                endTime = timing.loadEventStart;
                if (utils.isNumeric(startTime) && utils.isNumeric(endTime) && endTime > startTime) {
                    renderTime = endTime - startTime;
                }
            }

            return renderTime;
        }

        /**
         * Calculates the render time by measuring the difference between when the
         * library core was loaded and when the page load event occurs.
         * @private
         * @function
         * @name performance-processLoadEvent
         * @param  {Object} event The normalized data extracted from a browser event object.
         */
        function processLoadEvent(event) {
            var startTime = context.getStartTime();
            if (event.timestamp > startTime && !calculatedRenderTime) {
                // Calculate the render time
                calculatedRenderTime = event.timestamp - startTime;
            }
        }

        /**
         * Posts the performance event.
         * @private
         * @function
         * @name performance-postPerformanceEvent
         * @param {object} window The DOM window
         */
        function postPerformanceEvent(window) {
            var config = context.getConfig() || {},
                navType = "UNKNOWN",
                queueEvent = {
                    type: 7,
                    performance: {}
                },
                navigation,
                performance,
                timing;

            // Sanity checks
            if (!window || moduleState.perfEventSent) {
                return;
            }

            performance = window.performance || {};
            timing = performance.timing;
            navigation = performance.navigation;

            if (timing) {
                queueEvent.performance.timing = parseTiming(timing, config.filter);
                queueEvent.performance.timing.renderTime = getRenderTime(timing);
            } else if (config.calculateRenderTime) {
                queueEvent.performance.timing = {
                    renderTime: calculatedRenderTime,
                    calculated: true
                };
            } else {
                // Nothing to report.
                return;
            }

            // Do not include renderTime if it is over the threshold.
            if (config.renderTimeThreshold && queueEvent.performance.timing.renderTime > config.renderTimeThreshold) {
                queueEvent.performance.timing.invalidRenderTime = queueEvent.performance.timing.renderTime;
                delete queueEvent.performance.timing.renderTime;
            }

            if (navigation) {
                switch (navigation.type) {
                case 0:
                    navType = "NAVIGATE";
                    break;
                case 1:
                    navType = "RELOAD";
                    break;
                case 2:
                    navType = "BACKFORWARD";
                    break;
                default:
                    navType = "UNKNOWN";
                    break;
                }
                queueEvent.performance.navigation = {
                    type: navType,
                    redirectCount: navigation.redirectCount
                };
            }

            // Invoke the context API to post this event
            context.post(queueEvent);
            // TODO: Remove all instances of perfEventSent flag from this method and localize it's use in the caller?
            moduleState.perfEventSent = true;
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {


            /**
             * Initialize the performance module.
             */
            init: function () {
                // TODO: Possibly add check to see if navigation timing interface is supported. If not, short circuit the implementation below.
            },

            /**
             * Terminate the performance module.
             */
            destroy: function () {

            },

            /**
             * Handle events subscribed by the performance module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                switch (event.type) {
                case "load":
                    moduleState.loadReceived = true;
                    processLoadEvent(event);
                    break;
                case "unload":
                    moduleState.unloadReceived = true;
                    // Force the performance data to be posted (if it hasn't been done already.)
                    if (!moduleState.perfEventSent) {
                        // TODO: Directly referencing the global window but may want to sandbox this.
                        postPerformanceEvent(window);
                    }
                    break;
                default:
                    break;
                }
            },

            /**
             * Handle system messages subscribed by the performance module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            }
        };
    });  // End of TLT.addModule
} else {


}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Replay module implements the logic for monitoring and
 * reporting user interaction data used for replay and usability.
 * @exports replay
 */

/*global TLT:true */

// Sanity check
TLT.addModule("replay", function (context) {
    "use strict";

    var tlTypes = {
    // Keep these sorted for readability.
            "a:": "link",
            "button:button": "button",
            "button:submit": "button",
            "input:button": "button",
            "input:checkbox": "checkBox",
            "input:color": "colorPicker",
            "input:date": "datePicker",
            "input:datetime": "datetimePicker",
            "input:datetime-local": "datetime-local",
            "input:email": "emailInput",
            "input:file": "fileInput",
            "input:image": "image",
            "input:month": "month",
            "input:number": "numberPicker",
            "input:password": "textBox",
            "input:radio": "radioButton",
            "input:range": "slider",
            "input:reset": "resetButton",
            "input:search": "searchBox",
            "input:submit": "submitButton",
            "input:tel": "tel",
            "input:text": "textBox",
            "input:time": "timePicker",
            "input:url": "urlBox",
            "input:week": "week",
            "select:": "selectList",
            "select:select-one": "selectList",
            "textarea:": "textBox",
            "textarea:textarea": "textBox"
        },
        utils = context.utils,
        currOrientation = window.orientation || 0,
        savedTouch = {
            scale: 0,
            timestamp: 0
        },
        pastEvents = {},
        prevHash = window.location.hash,
        lastEventId = null,
        tmpQueue = [],
        eventCounter = 0,
        curClientState = null,
        pastClientState = null,
        errorCount = 0,
        visitOrder = "",
        lastVisit = "",
        pageLoadTime = (new Date()).getTime(),
        pageDwellTime = 0,
        prevWebEvent = null,
        viewEventStart = null,
        viewTimeStart = null,
        scrollViewStart = null,
        scrollViewEnd = null,
        nextScrollViewStart = null,
        viewPortXStart = 0,
        viewPortYStart = 0,
        inBetweenEvtsTimer = null,
        lastFocusEvent = { inFocus: false },
        lastClickEvent = null,
        //TODO move these to a global section due to they might be used elsewhere
        isApple = utils.isiOS,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && utils.isAndroid,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = (window.screen ? window.screen.width : 0),
        deviceOriginalHeight = (window.screen ? window.screen.height : 0),
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        config = context.getConfig(),
        deviceScale = 1,
        previousDeviceScale = 1,
        extendGetItem;

    /**
     * Returns true if the click event changes the target state or is otherwise
     * relevant for the target.
     * @private
     * @param {WebEvent.target} target Webevent target
     * @return {boolean} true if the click event is relevant for the target, false otherwise.
     */
    function isTargetClickable(target) {
        var clickable = false,
            clickableInputTypes = "|button|image|submit|reset|checkbox|radio|",
            subType = null;

        if (typeof target !== "object" || !target.type) {
            return clickable;
        }

        switch (target.type) {
        case "INPUT":
            // Clicks are relevant for button type inputs only.
            subType = "|" + (target.subType || "") + "|";
            if (clickableInputTypes.indexOf(subType.toLowerCase()) === -1) {
                clickable = false;
            } else {
                clickable = true;
            }
            break;
        case "SELECT":
        case "TEXTAREA":
            clickable = false;
            break;
        default:
            // By default, clicks are relevant for all targets.
            clickable = true;
            break;
        }

        return clickable;
    }

    function parentElements(node) {
        var parents = [];
        node = node.parentNode;
        while (node) {
            parents.push(node);
            node = node.parentNode;
        }
        return parents;
    }

    function getParentLink(parents) {
        return context.utils.some(parents, function (node) {
            // Either links or buttons could have content
            if (node.tagName === "A" || node.tagName === "BUTTON") {
                return node;
            }
            return null;
        });
    }

    /**
     * Get the normalized tlEvent from the underlying DOM event and target.
     * @private
     * @param {object} webEvent The normalized webEvent with event and target (control.)
     * @return {string} The normalized value for the tlEvent as per the JSON Logging Data Format.
     */
    function getTlEvent(webEvent) {
        var tlEvent = webEvent.type,
            target = webEvent.target;

        if (typeof tlEvent === "string") {
            tlEvent = tlEvent.toLowerCase();
        } else {
            tlEvent = "unknown";
        }

        if (tlEvent === "blur") {
            tlEvent = "focusout";
        }

        if (tlEvent === "change") {
            if (target.type === "INPUT") {
                switch (target.subType) {
                case "text":
                case "date":
                case "time":
                    // tlEvent is textChange, dateChange or timeChange respectively.
                    tlEvent = target.subType + "Change";
                    break;
                default:
                    // For all other input fields the tlEvent is valueChange.
                    tlEvent = "valueChange";
                    break;
                }
            } else if (target.type === "TEXTAREA") {
                tlEvent = "textChange";
            } else {
                tlEvent = "valueChange";
            }
        }

        return tlEvent;
    }

    /**
     * Invoke the core API to take the DOM capture. If a delay is specified, then
     * schedule a DOM capture.
     * @private
     * @param {DOMElement} root Root element from which the DOM capture snapshot should be taken.
     * @param {object} [config] Configuration options for the capture.
     * @param {Number} [delay] Milliseconds after which to take the DOM snapshot.
     * @return {string} Returns the unique DOM Capture id.
     */
    function scheduleDOMCapture(root, config, delay) {
        var dcid = null;
        // Sanity check
        if (!root) {
            return dcid;
        }
        config = config || {};
        if (delay) {
            dcid = "dcid-" + context.utils.getSerialNumber() + "." + (new Date()).getTime() + "s";
            window.setTimeout(function () {
                config.dcid = dcid;
                context.performDOMCapture(root, config);
            }, delay);
        } else {
            delete config.dcid;
            dcid = context.performDOMCapture(root, config);
        }
        return dcid;
    }

    /**
     * Check the DOM capture rules to see if DOM capture should be triggered for this combination
     * of event, target, screenview as applicable.
     * @private
     * @param {String} eventType Name of the event e.g. click, change, load, unload
     * @param {DOMElement} target The target element of the event. Some events (such as load/unload) may not
     * have a target in which case it would be null.
     * @param {String} [screenviewName] The screenview name for load and unload events.
     * @returns {String} Returns the unique DOM Capture id or null.
     */
    function addDOMCapture(eventType, target, screenviewName) {
        var i,
            capture = false,
            captureConfig,
            dcEnabled = false,
            dcTrigger,
            dcTriggerList,
            dcid = null,
            delay = 0,
            len,
            replayConfig;

        // Sanity check
        if (!eventType || (!target && !screenviewName)) {
            return dcid;
        }
        if (!target && !(eventType === "load" || eventType === "unload")) {
            return dcid;
        }

        replayConfig = context.getConfig() || {};
        dcEnabled = utils.getValue(replayConfig, "domCapture.enabled", false);
        if (!dcEnabled || context.utils.isLegacyIE) {
            // DOM Capture is not supported for IE8 and below
            return dcid;
        }

        dcTriggerList = utils.getValue(replayConfig, "domCapture.triggers") || [];
        for (i = 0, len = dcTriggerList.length; i < len; i += 1) {
            dcTrigger = dcTriggerList[i];
            if (dcTrigger.event === eventType) {
                if (eventType === "load" || eventType === "unload") {
                    if (dcTrigger.screenviews) {
                        capture = (-1 !== utils.indexOf(dcTrigger.screenviews, screenviewName));
                    } else {
                        capture = true;
                    }
                } else {
                    if (dcTrigger.targets) {
                        capture = (-1 !== utils.matchTarget(dcTrigger.targets, target));
                    } else {
                        capture = true;
                    }
                }
            }

            if (capture) {
                // Get the configuration (if any)
                captureConfig = utils.getValue(replayConfig, "domCapture.options", {});
                // Immediate or delayed?
                delay = dcTrigger.delay || 0;

                dcid = scheduleDOMCapture(window.document, captureConfig, delay);
                break;
            }
        }
        return dcid;
    }

    /**
     * Used to create control object from a webEvent.
     * TODO: Move tlType and similar normalization to message service.
     * XXX - Requires review and clean-up.
     * @private
     * @function
     * @name replay-createQueueEvent
     * @param {object} options An object with the following properties:
     *                 webEvent A webEvent that will created into a control.
     *                 id Id of the object.
     *                 prevState Previous state of the object.
     *                 currState Current state of the object.
     *                 visitedCount Visited count of the object.
     *                 dwell Dwell time on the object.
     *                 focusInOffset When you first focused on the object.
     * @return {object} Control object.
     */
    function createQueueEvent(options) {
        var control,
            dcid,
            target        = utils.getValue(options, "webEvent.target", {}),
            targetType    = target.type,
            targetSubtype = target.subType || null,
            tlType        = tlTypes[targetType.toLowerCase() + ":" + targetSubtype] || targetType,
            parents       = parentElements(utils.getValue(target, "element")),
            parentLinkNode = null,
            relXY         = utils.getValue(target, "position.relXY"),
            eventSubtype  = utils.getValue(options, "webEvent.subType", null);

        control = {
            type: 4,
            target: {
                id: target.id || "",
                idType: target.idType,
                name: target.name,
                tlType: tlType,
                type: targetType,
                position: {
                    width: utils.getValue(target, "element.offsetWidth"),
                    height: utils.getValue(target, "element.offsetHeight")
                },
                currState: options.currState || null
            },
            event: {
                tlEvent: getTlEvent(utils.getValue(options, "webEvent")),
                type: utils.getValue(options, "webEvent.type", "UNKNOWN")
            }
        };

        if (targetSubtype) {
            control.target.subType = targetSubtype;
        }

        if (relXY) {
            control.target.position.relXY = relXY;
        }

        if (typeof options.dwell === "number" && options.dwell > 0) {
            control.target.dwell = options.dwell;
        }

        if (typeof options.visitedCount === "number") {
            control.target.visitedCount = options.visitedCount;
        }

        if (typeof options.prevState !== "undefined") {
            control.prevState = options.prevState;
        }

        if (eventSubtype) {
            control.event.subType = eventSubtype;
        }

        // Add usability to config settings
        parentLinkNode = getParentLink(parents);
        control.target.isParentLink = !!parentLinkNode;
        if (parentLinkNode) {
            // Add the parent's href, value and innerText if the actual target doesn't
            // support these properties
            if (parentLinkNode.href) {
                control.target.currState = control.target.currState || {};
                control.target.currState.href = control.target.currState.href || parentLinkNode.href;
            }
            if (parentLinkNode.value) {
                control.target.currState = control.target.currState || {};
                control.target.currState.value = control.target.currState.value || parentLinkNode.value;
            }
            if (parentLinkNode.innerText || parentLinkNode.textContent) {
                control.target.currState = control.target.currState || {};
                control.target.currState.innerText = utils.trim(control.target.currState.innerText || parentLinkNode.innerText || parentLinkNode.textContent);
            }
        }

        if (utils.isUndefOrNull(control.target.currState)) {
            delete control.target.currState;
        }
        if (utils.isUndefOrNull(control.target.name)) {
            delete control.target.name;
        }

        // Check if DOM Capture needs to be triggered for this message.
        // If the event is click then DOM capture is only allowed if the target is click-able
        if (control.event.type !== "click" || isTargetClickable(target)) {
            // Check and add DOM Capture
            dcid = addDOMCapture(control.event.type, target);
            if (dcid) {
                control.dcid = dcid;
            }
        }

        return control;
    }

    function postUIEvent(queueEvent) {
        context.post(queueEvent);
    }


    /**
     * Posts all events from given array to the message service. The input
     * array is cleared on exit from the function.
     * Function additionally consolidates events fired on the same DOM element
     * TODO: Explain the consolidation process. Needs to be refactored!
     * @private
     * @param {Array} queue An array of QueueEvents
     * @return void
     */
    function postEventQueue(queue) {
        var i = 0,
            j,
            len = queue.length,
            e1,
            e2,
            tmp,
            ignoredEvents = {
                mouseout: true,
                mouseover: true
            },
            results = [];

        for (i = 0; i < len; i += 1) {
            e1 = queue[i];
            if (!e1) {
                continue;
            }
            if (ignoredEvents[e1.event.type]) {
                results.push(e1);
            } else {
                for (j = i + 1; j < len && queue[j]; j += 1) {
                    if (!ignoredEvents[queue[j].event.type]) {
                        break;
                    }
                }
                if (j < len) {
                    e2 = queue[j];
                    if (e2 && e1.target.id === e2.target.id && e1.event.type !== e2.event.type) {
                        if (e1.event.type === "click") {
                            tmp = e1;
                            e1 = e2;
                            e2 = tmp;
                        }
                        if (e2.event.type === "click") {
                            e1.target.position = e2.target.position;
                            i += 1;
                        } else if (e2.event.type === "blur") {
                            e1.target.dwell = e2.target.dwell;
                            e1.target.visitedCount = e2.target.visitedCount;
                            e1.focusInOffset = e2.focusInOffset;
                            e1.target.position = e2.target.position;
                            i += 1;
                        }
                        queue[j] = null;
                        queue[i] = e1;
                    }
                }
                results.push(queue[i]);
            }
        }

        for (e1 = results.shift(); e1; e1 = results.shift()) {
            context.post(e1);
        }
        queue.splice(0, queue.length);
    }


    if (typeof window.onerror !== "function") {
        window.onerror = function (msg, url, line) {
            var errorMessage = null;

            if (typeof msg !== "string") {
                return;
            }
            line = line || -1;
            errorMessage = {
                type: 6,
                exception: {
                    description: msg,
                    url: url,
                    line: line
                }
            };

            errorCount += 1;
            context.post(errorMessage);
        };
    }

    /**
     * Handles the focus events. It is fired either when the real focus event take place
     * or right after the click event on an element (only when browser focus event was not fired)
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleFocus(id, webEvent) {
        lastFocusEvent = webEvent;
        lastFocusEvent.inFocus = true;
        if (typeof pastEvents[id] === "undefined") {
            pastEvents[id] = {};
        }

        pastEvents[id].focus = lastFocusEvent.dwellStart = Number(new Date());
        pastEvents[id].focusInOffset = viewTimeStart ? lastFocusEvent.dwellStart - Number(viewTimeStart) : -1;
        pastEvents[id].prevState = utils.getValue(webEvent, "target.state");
        pastEvents[id].visitedCount = pastEvents[id].visitedCount + 1 || 1;
    }

    /**
     * Create and add value that will be posted to queue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function addToTmpQueue(webEvent, id) {
        tmpQueue.push(createQueueEvent({
            webEvent: webEvent,
            id: id,
            currState: utils.getValue(webEvent, "target.state")
        }));
    }

    /**
     * Handles blur events. It is invoked when browser blur events fires or from the
     * handleFocus method (only when browser 'blur' event didn't take place).
     * In the first case it's called with current event details, in the second one -
     * with lastFocusEvent. Method posts the tmpQueue of events. If during the same
     * focus time change event was fired the focus data will be combined together with
     * the last change event from the tmpQueue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleBlur(id, webEvent) {
        var convertToBlur = false,
            dcid,
            lastQueueEvent,
            i = 0;

        if (typeof id === "undefined" || id === null || typeof webEvent === "undefined" || webEvent === null) {
            return;
        }

        lastFocusEvent.inFocus = false;

        if (typeof pastEvents[id] !== "undefined" && pastEvents[id].hasOwnProperty("focus")) {
            pastEvents[id].dwell =  Number(new Date()) - pastEvents[id].focus;
        } else {
            // Blur without any prior event on this control.
            pastEvents[id] = {};
            pastEvents[id].dwell = 0;
        }

        if (tmpQueue.length === 0) {
            // Orphaned blur without any prior event.
            addToTmpQueue(webEvent, id);
        }

        // Visited count is missing 
        if (tmpQueue[tmpQueue.length - 1]) {
            for (i = tmpQueue.length - 1; i >= 0; i--) {
                tmpQueue[i].target.visitedCount = pastEvents[id].visitedCount;
            }
        }

        lastQueueEvent = tmpQueue[tmpQueue.length - 1];
        if (lastQueueEvent) {
            lastQueueEvent.target.dwell = pastEvents[id].dwell;
            lastQueueEvent.focusInOffset = pastEvents[id].focusInOffset;
            lastQueueEvent.target.visitedCount = pastEvents[id].visitedCount;

            // if the click (without generating change event) fires on an
            // input element for which it's not relevant - report event as a blur and update the currState
            if (lastQueueEvent.event.type === "click") {
                if (!isTargetClickable(lastQueueEvent.target)) {
                    lastQueueEvent.target.currState = utils.getValue(webEvent, "target.state");
                    convertToBlur = true;
                }
            } else if (lastQueueEvent.event.type === "focus") {
                convertToBlur = true;
            }

            if (convertToBlur) {
                lastQueueEvent.event.type = "blur";
                lastQueueEvent.event.tlEvent = "focusout";
                // Check if DOM Capture needs to be triggered for this message.
                dcid = addDOMCapture(lastQueueEvent.event.type, webEvent.target);
                if (dcid) {
                    lastQueueEvent.dcid = dcid;
                }
            }
        }

        postEventQueue(tmpQueue);
    }

    /**
     * Checks to see in tmpQueue there is an older control that needs to be posted to server.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return Whether it has been sent to server.
     */
    function checkQueue(id, webEvent) {
        var hasInQueue = false;

        // TODO: Optimize the index by storing tmpQueue.length - 1 into a variable?
        if (tmpQueue.length > 0 && tmpQueue[tmpQueue.length - 1] && tmpQueue[tmpQueue.length - 1].target.id !== id &&
                // iOS scrolls & Android resizes after selecting a textbox
                webEvent.type !== "scroll" && webEvent.type !== "resize" &&
                // mouseover should not affect handleBlur invocation
                webEvent.type !== "mouseout" && webEvent.type !== "mouseover" &&
                // Need focus and click values to complete consolidation of message for these types
                (tmpQueue[tmpQueue.length - 1].target.tlType !== "textBox" &&
                tmpQueue[tmpQueue.length - 1].target.tlType !== "selectList")) {
            handleBlur(tmpQueue[tmpQueue.length - 1].target.id, tmpQueue[tmpQueue.length - 1]);
            hasInQueue = true;
        }
        return hasInQueue;
    }

    /**
     * Handles change and click events. Its called when browser 'change' event fires
     * or together with click event (from 'handleClick' method).
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleChange(id, webEvent) {
        if (typeof pastEvents[id] !== "undefined" && !pastEvents[id].hasOwnProperty("focus")) {
            handleFocus(id, webEvent);
        }

        addToTmpQueue(webEvent, id);

        if (typeof pastEvents[id] !== "undefined" && typeof pastEvents[id].prevState !== "undefined") {
            // TODO: Optimize the index by storing tmpQueue.length - 1 to a variable.
            if (tmpQueue[tmpQueue.length - 1].target.tlType === "textBox" ||
                    tmpQueue[tmpQueue.length - 1].target.tlType === "selectList") {
                tmpQueue[tmpQueue.length - 1].target.prevState = pastEvents[id].prevState;
            }
        }
    }

    /**
     * Sets the relative X & Y values to a webEvent.
     * TODO: Explain how relative X & Y should be calculated (in other words, define relative X & Y)
     * XXX - Shouldn't this be named "get" instead of "set"?
     * @private
     * @param {WebEvent} webEvent Normalized browser event
     * @return String value of relative X & Y
     */
    function setRelativeXY(webEvent) {
        var x = webEvent.target.position.x,
            y = webEvent.target.position.y,
            width = webEvent.target.size.width,
            height = webEvent.target.size.height,
            relX = Math.abs(x / width).toFixed(1),
            relY = Math.abs(y / height).toFixed(1);

        relX = relX > 1 || relX < 0 ? 0.5 : relX;
        relY = relY > 1 || relY < 0 ? 0.5 : relY;

        return relX + "," + relY;
    }

    /**
     * Handles click events. Additionally it recognizes situations when browser didn't
     * fire the focus event and in such case it invokes 'handleFocus' method.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleClick(id, webEvent) {
        var relXY,
            addRelXY = true,
            tmpQueueLength = 0;

        if (webEvent.target.element.tagName === "SELECT" && lastClickEvent && lastClickEvent.target.id === id) {
            lastClickEvent = null;
            return;
        }

        if (!lastFocusEvent.inFocus) {
            handleFocus(id, webEvent);
        }

        // Sometimes the change triggers before the click (observed in Chrome and Android)
        // XXX - Not sure I fully understand this logic - MP
        tmpQueueLength = tmpQueue.length;
        if (tmpQueueLength && utils.getValue(tmpQueue[tmpQueueLength - 1], "event.type") !== "change") {
            handleChange(id, webEvent);
        }

        relXY = setRelativeXY(webEvent);

        // During use of arrow keys to select a radio option, it throws a click event after change event
        // which is incorrect for usability data. We only capture user clicks and not framework clicks.
        tmpQueueLength = tmpQueue.length;

        if (webEvent.position.x === 0 && webEvent.position.y === 0 && tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.tlType") === "radioButton") {
            addRelXY = false;
        } else {
            // For all other cases, record the relXY in the target.position
            webEvent.target.position.relXY = relXY;
        }

        // Update the existing queue entry with relXY info. from the click event
        if (tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.id") === id) {
            if (addRelXY) {
                tmpQueue[tmpQueueLength - 1].target.position.relXY = relXY;
            }
        } else {
            // Else add the click event to the queue
            addToTmpQueue(webEvent, id);
        }

        // XXX - What is lastClickEvent being used for? - MP
        lastClickEvent = webEvent;
    }

    /**
     * Returns the normalized orientation in degrees. Normalized values are measured
     * from the default portrait position which has an orientation of 0. From this
     * position the respective values are as follows:
     * 0   - Portrait orientation. Default
     * -90 - Landscape orientation with screen turned clockwise.
     * 90  - Landscape orientation with screen turned counterclockwise.
     * 180 - Portrait orientation with screen turned upside down.
     * @private
     * @function
     * @name replay-getNormalizedOrientation
     * @param {object} webEvent A normalized event object per the WebEvent
     * @return {integer} The normalized orientation value.
     */
    function getNormalizedOrientation(webEvent) {
        var orientation = 0;
        if (window.orientation) {
            orientation = window.orientation;
        } else if (webEvent !== undefined && webEvent.orientation) {
            orientation = webEvent.orientation;
        }

        // XXX - This functionality should probably be moved into the browser service.
        // TODO: Normalize for Android
        return orientation;
    }


    /**
     * Handles the "orientationchange" event and posts the appropriate message
     * to the replay module's queue.
     * @private
     * @function
     * @name replay-handleOrientationChange
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleOrientationChange(webEvent) {
        var newOrientation = getNormalizedOrientation(webEvent),
            orientationChangeEvent = {
                type: 4,
                event: {
                    type: "orientationchange"
                },
                target: {
                    prevState: {
                        orientation: currOrientation,
                        orientationMode: utils.getOrientationMode(currOrientation)
                    },
                    currState: {
                        orientation: newOrientation,
                        orientationMode: utils.getOrientationMode(newOrientation)
                    }
                }
            };

        postUIEvent(orientationChangeEvent);
        currOrientation = newOrientation;
    }

    /* TODO: Refactor this to use a well-defined touchState object */
    function isDuplicateTouch(touchState) {
        var result = false;

        if (!touchState) {
            return result;
        }

        result = (savedTouch.scale === touchState.scale &&
                Math.abs((new Date()).getTime() - savedTouch.timestamp) < 500);

        return result;
    }

    function saveTouchState(touchState) {
        savedTouch.scale = touchState.scale;
        savedTouch.rotation = touchState.rotation;
        savedTouch.timestamp = (new Date()).getTime();
    }

    /**
     * Takes the scale factor and returns the pinch mode as a text string.
     * Values less than 1 correspond to a pinch close gesture. Values greater
     * than 1 correspond to a pinch open gesture.
     * @private
     * @function
     * @name replay-getPinchType
     * @return {String} "CLOSE", "OPEN" or "NONE" for valid scale values.
     * "INVALID" in case of error.
     */
    function getPinchType() {
        var s,
            pinchType;

        s = deviceScale - previousDeviceScale;
        if (isNaN(s)) {
            pinchType = "INVALID";
        } else if (s < 0) {
            pinchType = "CLOSE";
        } else if (s > 0) {
            pinchType = "OPEN";
        } else {
            pinchType = "NONE";
        }

        return pinchType;
    }


    /**
     * Used to create the client state message from a webEvent.
     * @private
     * @function
     * @name replay-getClientStateMessage
     * @param {object} webEvent A webEvent that will be used to create the clientState.
     * @return {object} Client state message object.
     */
    function getClientStateMessage(webEvent) {
        var documentElement = document.documentElement,
            documentBody = document.body,
            msg = {
                type: 1,
                clientState: {
                    pageWidth: document.width || (!documentElement ? 0 : documentElement.offsetWidth),
                    pageHeight: Math.max((!document.height ? 0 : document.height), (!documentElement ? 0 : documentElement.offsetHeight), (!documentElement ? 0 : documentElement.scrollHeight)),
                    viewPortWidth: window.innerWidth || documentElement.clientWidth,
                    viewPortHeight: window.innerHeight || documentElement.clientHeight,
                    viewPortX: window.pageXOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollLeft) : documentElement.scrollLeft || 0),
                    viewPortY: window.pageYOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollTop) : documentElement.scrollTop || 0),
                    deviceOrientation: window.orientation || 0,
                    event: utils.getValue(webEvent, "type")
                }
            },
            deviceWidth = 1,
            scaleWidth = 1;

        pastClientState = pastClientState || msg;

        if (Math.abs(msg.clientState.deviceOrientation) === 90) {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalHeight - deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalHeight - deviceToolbarHeight : ((deviceOriginalHeight / devicePixelRatio) - deviceToolbarHeight);
            }
        } else {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalWidth + deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalWidth - deviceToolbarHeight : ((deviceOriginalWidth / devicePixelRatio) - deviceToolbarHeight);
            }
        }

        scaleWidth = (msg.clientState.viewPortWidth === 0 ? 1 : deviceWidth / msg.clientState.viewPortWidth);

        // Made scale a bit smaller to adjust for scroll bars that appear on top of content on certain browsers.
        msg.clientState.deviceScale = (scaleWidth - 0.02).toFixed(3);

        // Set the viewTime for this client state
        msg.clientState.viewTime = 0;
        if (scrollViewStart && scrollViewEnd) {
            msg.clientState.viewTime = scrollViewEnd.getTime() - scrollViewStart.getTime();
        }

        if (webEvent.type === "scroll") {
            msg.clientState.viewPortXStart = pastClientState.clientState.viewPortX;
            msg.clientState.viewPortYStart = pastClientState.clientState.viewPortY;
        }

        return msg;
    }

    /**
     * Post the current client state and also record it as pastClientState.
     * Reset the scrollViewStart/End values.
     * @private
     * @function
     * @name replay-sendClientState
     */
    function sendClientState() {
        if (curClientState) {
            postUIEvent(curClientState);
            pastClientState = curClientState;
            curClientState = null;
            scrollViewStart = nextScrollViewStart || scrollViewStart;
            scrollViewEnd = null;
        }
    }

    /**
     * Used to create client state from a webEvent.
     * @private
     * @function
     * @name replay-handleClientState
     * @param {object} webEvent A webEvent that will created into a clientState and saved for previous and current client state.
     * @return {object} Client state object.
     */
    function handleClientState(webEvent) {
        var attentionMsg = null;

        curClientState = getClientStateMessage(webEvent);

        // TODO: Change these if-else to a switch statement
        if (webEvent.type === "scroll" || webEvent.type === "resize") {
            // Set the interval timeout so we can collect related scroll / resize events in one batch
            if (sendClientState.timeoutId) {
                window.clearTimeout(sendClientState.timeoutId);
                sendClientState.timeoutId = 0;
            }
            sendClientState.timeoutId = window.setTimeout(sendClientState, utils.getValue(config, "scrollTimeout", 2000));
        } else if (webEvent.type === "touchstart" || webEvent.type === "load") {
            if (curClientState) {
                // set the initial device scale which is used to determine what type of pinch happened
                previousDeviceScale = parseFloat(curClientState.clientState.deviceScale);
            }
        } else if (webEvent.type === "touchend") {
            if (curClientState) {
                // used to determine what type of pinch happened
                deviceScale = parseFloat(curClientState.clientState.deviceScale);
                // Send client state on touchend
                sendClientState();
            }
        }

        if (webEvent.type === "load" || webEvent.type === "unload") {
            // The "Attention" event is deprecated
            if (webEvent.type === "unload" && pageLoadTime) {
                // Save the "attention" event which is essentially a dup of the unload with viewTime starting from page load.
                attentionMsg = utils.clone(curClientState);
                attentionMsg.clientState.event = "attention";
                attentionMsg.clientState.viewTime = (new Date()).getTime() - pageLoadTime;
            }

            sendClientState();

            if (attentionMsg) {
                // send the attentionMsg
                curClientState = attentionMsg;
                sendClientState();
            }
        }

        return curClientState;
    }

    /**
     * Handles the "touchstart" event, which is only used to get the deviceScale before a pinch
     * @private
     * @function
     * @name replay-handleTouchStart
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchStart(webEvent) {
        var fingerCount = utils.getValue(webEvent, "nativeEvent.touches.length", 0);

        if (fingerCount === 2) {
            handleClientState(webEvent);
        }
    }

    /**
     * Handles the "touchend" event and posts the appropriate message to the
     * replay module's queue.
     * @private
     * @function
     * @name replay-handleTouchEnd
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchEnd(webEvent) {
        var fingerCount,
            prevTouchState = {},
            // Rotation angle for android devices does not work for all devices/browsers
            rotation = utils.getValue(webEvent, "nativeEvent.rotation", 0) || utils.getValue(webEvent, "nativeEvent.touches[0].webkitRotationAngle", 0),
            scale = utils.getValue(webEvent, "nativeEvent.scale", 1),
            touchState = null,
            touchEndEvent = {
                type: 4,
                event: {
                    type: "touchend"
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        // count the number of fingers placed on the screen
        fingerCount = utils.getValue(webEvent, "nativeEvent.changedTouches.length", 0) + utils.getValue(webEvent, "nativeEvent.touches.length", 0);
        if (fingerCount !== 2) {
            return;
        }

        // 1st handle the client state change. This will update the device scale information.
        handleClientState(webEvent);

        // Only post when there are two fingers reported by the touchend event object
        // create the current touchstate
        touchState = {
            rotation: rotation ? rotation.toFixed(2) : 0,
            scale: deviceScale ? deviceScale.toFixed(2) : 1
        };
        touchState.pinch = getPinchType();

        // create the prev touch state
        prevTouchState.scale = previousDeviceScale ? previousDeviceScale.toFixed(2) : 1;

        // Set the curr and prev states
        touchEndEvent.target.prevState = prevTouchState;
        touchEndEvent.target.currState = touchState;

        postUIEvent(touchEndEvent);
    }

    /**
     * Compares two WebEvent's to determine if they are duplicates. Examines
     * the event type, target id and the timestamp to make this determination.
     * XXX - Push this into the browser service or core?!?
     * @private
     * @function
     * @name replay-isDuplicateEvent
     * @param {object} curr A WebEvent object
     * @param {object} prev A WebEvent object
     * @return {boolean} Returns true if the WebEvents are duplicates.
     */
    function isDuplicateEvent(curr, prev) {
        var propsToCompare = ["type", "target.id"],
            prop = null,
            i,
            len,
            duplicate = true,
            DUPLICATE_EVENT_THRESHOLD_TIME = 10,
            timeDiff = 0,
            currTimeStamp = 0,
            prevTimeStamp = 0;

        // Sanity check
        if (!curr || !prev || typeof curr !== "object" || typeof prev !== "object") {
            duplicate = false;
        }

        // Compare WebEvent properties
        for (i = 0, len = propsToCompare.length; duplicate && i < len; i += 1) {
            prop = propsToCompare[i];
            if (utils.getValue(curr, prop) !== utils.getValue(prev, prop)) {
                duplicate = false;
                break;
            }
        }

        if (duplicate) {
            currTimeStamp = utils.getValue(curr, "timestamp");
            prevTimeStamp = utils.getValue(prev, "timestamp");
            // Don't compare if neither objects have a timestamp
            if (!(isNaN(currTimeStamp) && isNaN(prevTimeStamp))) {
                // Check if the event timestamps are within the predefined threshold
                timeDiff = Math.abs(utils.getValue(curr, "timestamp") - utils.getValue(prev, "timestamp"));
                if (isNaN(timeDiff) || timeDiff > DUPLICATE_EVENT_THRESHOLD_TIME) {
                    duplicate = false;
                }
            }
        }

        return duplicate;
    }

    /**
     * Keeps track of the location.hash and logs the appropriate screenview messages
     * when a hash change is detected.
     * @private
     * @function
     * @name replay-trackHashchange
     */
    function trackHashchange() {
        var currHash = window.location.hash;

        if (currHash === prevHash) {
            return;
        }

        // TODO: Expose logScreenview on context so we don't reference TLT
        if (prevHash) {
            // Send the screenview unload
            TLT.logScreenviewUnload(prevHash);
        }

        if (currHash) {
            // Send the screenview load
            TLT.logScreenviewLoad(currHash);
        }

        // Save the current hash value
        prevHash = currHash;
    }


    /**
     * Default handler for event types that are not being processed by the module.
     * @private
     * @function
     * @param {object} webEvent A WebEvent object
     * @name replay-defaultEventHandler
     */
    function defaultEventHandler(webEvent) {
        var msg = {
                type: 4,
                event: {
                    type: webEvent.type
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        postUIEvent(msg);
    }

    return {
        init: function () {
            tmpQueue = [];
        },
        destroy: function () {
            handleBlur(lastEventId);
            tmpQueue = [];
        },
        onevent: function (webEvent) {
            var id = null,
                returnObj = null;

            // Sanity checks
            if (typeof webEvent !== "object" || !webEvent.type) {
                return;
            }

            if (isDuplicateEvent(webEvent, prevWebEvent)) {
                prevWebEvent = webEvent;
                return;
            }

            prevWebEvent = webEvent;


            id = utils.getValue(webEvent, "target.id");

            if (Object.prototype.toString.call(pastEvents[id]) !== "[object Object]") {
                pastEvents[id] = {};
            }

            checkQueue(id, webEvent);
            inBetweenEvtsTimer = new Date();

            switch (webEvent.type) {
            case "hashchange":
                trackHashchange();
                break;
            case "focus":
                returnObj = handleFocus(id, webEvent);
                break;
            case "blur":
                returnObj = handleBlur(id, webEvent);
                break;
            case "click":
                // Normal click processing
                returnObj = handleClick(id, webEvent);
                break;
            case "change":
                returnObj = handleChange(id, webEvent);
                break;
            case "orientationchange":
                returnObj = handleOrientationChange(webEvent);
                break;
			case "touchstart":
				handleTouchStart(webEvent);
				break;
            case "touchend":
                returnObj = handleTouchEnd(webEvent);
                break;
            case "load":
                // initialize the start time for the scrolled view
                scrollViewStart = new Date();

                // send initial clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewLoad("root");

                break;
            case "screenview_load":
                // starts screenview time used for calculating the offset
                viewTimeStart = new Date();

                // Check and add DOM Capture
                returnObj = addDOMCapture("load", null, webEvent.name);

                break;
            case "screenview_unload":
                // Check and add DOM Capture
                returnObj = addDOMCapture("unload", null, webEvent.name);

                break;
            case "resize":
            case "scroll":
                if (!scrollViewEnd) {
                    scrollViewEnd = new Date();
                }
                nextScrollViewStart = new Date();

                handleClientState(webEvent);

                break;
            case "unload":
                // Flush any saved control
                if (tmpQueue !== null) {
                    postEventQueue(tmpQueue);
                }

                // set the final timestamp of this scrolled view.
                scrollViewEnd = new Date();

                // send final clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewUnload("root");

                break;
            default:
                // Call the default handler for all other DOM events
                defaultEventHandler(webEvent);
                break;
            }

            lastEventId = id;
            return returnObj;
        },
        onmessage: function () {
        }
    };
});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SaaS module implements the logic for using Tealeaf in the cloud.
 * @exports saas
 */

/*global TLT:true */

// Sanity check
TLT.addModule("saas", function (context) {
    "use strict";

    /**
     * Sets the SaaS data object to the configuration specified by the user in the config.
     * @private
     */
    var SaasData = function () {
			if (typeof TLT.getCoreConfig().modules.saas !== "undefined") {
				var key;

				for (key in TLT.getCoreConfig().modules.saas) {
					if (TLT.getCoreConfig().modules.saas.hasOwnProperty(key) && typeof key === "string" && typeof TLT.getCoreConfig().modules.saas[key] === "string") {
						this[key] = TLT.getCoreConfig().modules.saas[key];
						document.cookie = key + "=" + this[key];
					}
				}

				/**
				* Gets Tealeaf SaaS session data
				* @function
				* @name saas-saasData.get
				* @param {string} key SaaS session key to get.
				* @return {string} Value associated with the SaaS session key or error description.
				*/
				this.get = function (key) {
					if (typeof key !== "string" || typeof this === "undefined") {
						return "SaaS Data undefined or key is not a string";
					}
					if (typeof this[key] === "undefined") {
						return "Key does not exist within saasData";
					}
					return this[key];
				};

				/**
				* Sets Tealeaf SaaS session data.
				* @function
				* @name saas-saasData.set
				* @param {string} key SaaS session key to be changed or created.
				* @param {string} value SaaS session value to be set.
				* @return {boolean} True if the cookie was set, false if not.
				*/
				this.set = function (key, value) {
					if (typeof key !== "string" || typeof value !== "string" || typeof this === "undefined" || key === "get" || key === "set" || key === "toSaasString" || key === "clear" || key === "remove") {
						return false;
					}
					this[key] = value;
					document.cookie = key + "=" + value;
					return true;
				};

				/**
				* Clears Tealeaf SaaS data.
				* @function
				* @name saas-saasData.clear
				* @returns {void}
				*/
				this.clear = function () {
					var key;
					for (key in this) {
						if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
							document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
							delete this[key];
						}
					}
					return;
				};

				/**
				* Removes a key/value pair from Tealeaf SaaS data.
				* @function
				* @name saas-saasData.remove
				* @returns {void}
				*/
				this.remove = function (key) {
					if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
						document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
						delete this[key];
					}
					return;
				};

				/**
				* Converts Tealeaf SaaS session key/value pairs into a semi-colon separated string
				* @function
				* @name saas-saasData.toString
				* @return {string} Key/value pairs in a semi-colon separated string like "key1=value1;key2=value2..."
				*/
				this.toSaasString = function () {
					var saasDataString = "",
						key;
					for (key in this) {
						if (this.hasOwnProperty(key) && typeof this.get(key) === "string") {
							saasDataString += key + "=" + this.get(key) + ";";
						}
					}
					return saasDataString;
				};
			}
		},
		_saasData = new SaasData();

    // Return the module's interface object. This contains callback functions which
    // will be invoked by the UIC core.
    return {
        init: function () {
            // Attach any custom event handlers here
			TLT.saasData = _saasData;
        },
        destroy: function () {
            // Detach any custom event handlers here
        },
        onevent: function (webEvent) {
            // Process DOM events that you registered in the configuration as
            // per your customized requirements
        }
    };

});
</script>
<script type="text/tljs" id="UIC-SDK-FILE-w3c-prod">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags w3c,NDEBUG
 */

/**
 * @fileOverview Defines the core of the system, namely the TLT object.
 * @exports TLT
 */
/*global window*/
/*jshint loopfunc:true*/
/**
 * TLT (short for Tealeaf Technology) is the top-level object for the system. All
 * objects and functions live under TLT to prevent polluting the global
 * scope. This object also manages the modules and services on the page,
 * controlling their lifecycle, manages inter-module communication.
 * @namespace
 */
// Sanity check
if (window.TLT) {
    throw "Attempting to recreate TLT. Library may be included more than once on the page.";
}
var TLT = (function () {

    "use strict";

    /* Create and add a screenview message to the default queue. Also
     * notifies any listeners of the screenview load/unload event.
     * @param {Enum} type "LOAD" or "UNLOAD" indicating the type
     * of screenview event.
     * @param {string} name User friendly name of the screenview.
     * @param {string} [referrerName] Name of the previous screenview that
     * is being replaced.
     * @param {object} [root] DOMNode which represents the root or
     * parent of this screenview. Usually this is a div container.
     * @returns {void}
     */
    function logScreenview(type, name, referrerName, root) {
        var dcid = null,
            screenviewMsg = null,
            queue = TLT.getService("queue"),
            replay = TLT.getModule("replay"),
            webEvent = null,
            winLocation = window.location,
            host = winLocation.origin || null,
            url = winLocation.pathname;

        // Sanity checks
        if (!name || typeof name !== "string") {
            return;
        }
        if (!referrerName || typeof referrerName !== "string") {
            referrerName = "";
        }

        if (!host) {
            host = (winLocation.protocol || "") + "//" + (winLocation.host || "");
        }

        // This is needed for Native hybrid replay to get file path of webview assets used.
        if (host.indexOf("file://") > -1) {
            url = url.replace(/(.*?)(?=\/[^.\/]*\.app)/g, '').replace('.app//', '.app/');
        }

        screenviewMsg = {
            type: 2,
            screenview: {
                type: type,
                name: name,
                url: url,
                host: host,
                referrer: referrerName
            }
        };

        // XXX: Fix this hack. At least send a fully populated WebEvent object.
        // Ideally, want to use the publishEvent to route this to the correct modules.
        if (type === "LOAD") {
            webEvent = {
                type: "screenview_load",
                name: name
            };
        } else if (type === "UNLOAD") {
            webEvent = {
                type: "screenview_unload",
                name: name
            };
        }

        if (webEvent && replay) {
            dcid = replay.onevent(webEvent);
        }

        // If DOM Capture was triggered for this add it to the screenview message.
        if (dcid) {
            screenviewMsg.dcid = dcid;
        }

        if (type === "LOAD" || type === "UNLOAD") {
            queue.post("", screenviewMsg, "DEFAULT");
        }
    }


    var tltStartTime = (new Date()).getTime(),

        /**
         * A collection of module information. The keys in this object are the
         * module names and the values are an object consisting of three pieces
         * of information: the creator function, the instance, and context object
         * for that module.
         * @private
         */
        modules = {},

        /**
         * A collection of service information. The keys in this object are the
         * service names and the values are an object consisting of two pieces
         * of information: the creator function and the service object.
         * @private
         */
        services = {},

        /**
         * Indicates if the core has been initialized or not.
         * @private
         */
        initialized = false,
        state = null,

        /**
         * Checks whether given frame is blacklisted (in the config) or not.
         * @function
         * @private
         * @param {DOMElement} iframe an element to examine
         * @return {boolean} true if given iframe is blacklisted, false otherwise
         */
        isFrameBlacklisted = (function () {
            var blacklistedFrames,
                checkedFrames = [];

            function prepareBlacklistedFrames(scope) {
                var browserService = core.getService("browser"),
                    blacklist = core.getCoreConfig().framesBlacklist,
                    foundFrames,
                    i;
                blacklistedFrames = blacklistedFrames || [];
                scope = scope || null;
                if (typeof blacklist !== "undefined" && blacklist.length > 0) {
                    for (i = 0; i < blacklist.length; i += 1) {
                        foundFrames = browserService.queryAll(blacklist[i], scope);
                        if (foundFrames && foundFrames.length > 0) {
                            blacklistedFrames = blacklistedFrames.concat(foundFrames);
                        }
                    }
                    checkedFrames = checkedFrames.concat(browserService.queryAll('iframe', scope));
                }
            }

            function isFrameBlacklisted(iframe) {
                if (core.utils.indexOf(checkedFrames, iframe) < 0) {
                    prepareBlacklistedFrames(iframe.ownerDocument);
                }
                return core.utils.indexOf(blacklistedFrames, iframe) > -1;
            }

            isFrameBlacklisted.clearCache = function () {
                blacklistedFrames = null;
            };

            return isFrameBlacklisted;
        }()),

        /**
         * Last clicked element, needed for IE and 'beforeunload'
         * @private
         */
        lastClickedElement = null,

        /**
         * List of service passthroughs. These are methods that are called
         * from TLT and simply pass through to the given service without
         * changing the arguments. Doing this dynamically keeps the code
         * smaller and easier to update.
         * @private
         */
        servicePassthroughs = {

            "config": [

                /**
                 * Returns the global configuration object (the one passed to init()).
                 * @name getConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The global configuration object.
                 */
                "getConfig",

                /**
                 * Updates the global configuration object (the one passed to init()).
                 * @name updateConfig
                 * @memberOf TLT
                 * @function
                 * @returns {void}
                 */
                "updateConfig",

                /**
                 * Returns the core configuration object.
                 * @name getCoreConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The core configuration object.
                 */
                "getCoreConfig",

                /**
                 * Updates the core configuration object.
                 * @name updateCoreConfig
                 * @memberOf TLT
                 * @function
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateCoreConfig",

                /**
                 * Returns the configuration object for a module.
                 * @name getModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getModuleConfig",

                /**
                 * Updates a configuration object for a module.
                 * @name updateModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateModuleConfig",

                /**
                 * Returns a configuration object for a service.
                 * @name getServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getServiceConfig",

                /**
                 * Updates a configuration object for a service.
                 * @name updateServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateServiceConfig"

            ],

            "queue": [
                /**
                 * Send event information to the module's default queue.
                 * This doesn't necessarily force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name post
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName The name of the module saving the event.
                 * @param  {Object} queueEvent The event information to be saved to the queue.
                 * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "post",
                /**
                 * Enable/disable the automatic flushing of all queues.
                 * Either periodically by a timer or whenever the queue threshold is reached.
                 * @name setAutoFlush
                 * @memberOf TLT
                 * @function
                 * @param {Boolean} flag Set this to false to disable flushing
                 *                 or set it to true to enable automatic flushing (default)
                 * @returns {void}
                 */
                "setAutoFlush",
                /**
                 * Forces all queues to send their data to the server.
                 * @name flushAll
                 * @memberOf TLT
                 * @function
                 */
                "flushAll"

            ],

            "browserBase": [
                /**
                 * Calculates the xpath of the given DOM Node.
                 * @name getXPathFromNode
                 * @memberOf TLT
                 * @function
                 * @param {DOMElement} node The DOM node who's xpath is to be calculated.
                 * @returns {String} The calculated xpath.
                 */
                "getXPathFromNode",

                /**
                 * Let the UIC library process a DOM event, which was prevented
                 * from bubbling by the application.
                 * @name processDOMEvent
                 * @memberOf TLT
                 * @function
                 * @param {Object} event The browsers event object which was prevented.
                 */
                "processDOMEvent"
            ]
        },

        /**
         * Provides methods for handling load/unload events to make sure that this
         * kind of events will be handled independently to browser caching mechanism
         * @namespace
         * @private
         */
        loadUnloadHandler = (function () {
            var status = {};

            return {

                /**
                 * Normalizes the events specified in the configuration in the following ways:
                 * - For each load/unload module event adds corresponding pageshow/pagehide event.
                 * - Adds beforeunload
                 * - Adds propertychange if W3C service is being used for correct operation on legacy IE.
                 * @param {String} moduleName Name of the module
                 * @param {Array} moduleEvents An array of module event configs
                 * @param {object} [localTop] Local window element
                 * @param {object} [documentScope] document element
                 */
                normalizeModuleEvents: function (moduleName, moduleEvents, localTop, documentScope) {
                    var load = false,
                        unload = false,
                        browserService = core.getService("browser");

                    localTop = localTop || core._getLocalTop();
                    documentScope = documentScope || localTop.document;

                    status[moduleName] = {
                        loadFired: false,
                        pageHideFired: false
                    };

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        switch (eventConfig.name) {
                        case "load":
                            load = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pageshow"
                            }));
                            break;

                        case "unload":
                            unload = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pagehide"
                            }));
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "beforeunload"
                            }));
                            break;

                        // IE6, IE7 and IE8 - catching 'onpropertychange' event to
                        // simulate correct 'change' events on radio and checkbox.
                        // required for W3C only as jQuery normalizes it.
                        case "change":
                            if (core.utils.isLegacyIE && core.getFlavor() === "w3c") {
                                moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                    name: "propertychange"
                                }));
                            }
                            break;
                        }
                    });
                    if (!load && !unload) {
                        delete status[moduleName];
                        return;
                    }
                    status[moduleName].silentLoad = !load;
                    status[moduleName].silentUnload = !unload;
                    if (!load) {
                        moduleEvents.push({name: "load", target: localTop});
                    }
                    if (!unload) {
                        moduleEvents.push({name: "unload", target: localTop});
                    }
                },

                /**
                 * Checks if event can be published for the module(s) or not.
                 * The negative case can take place for load/unload events only, to avoid
                 * redundancy in handler execution. If as example load event was handled
                 * properly, the pageshow event will be ignored.
                 * @param {string} moduleName Name of the module
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                canPublish: function (moduleName, event) {
                    var mod;
                    if (status.hasOwnProperty(moduleName) === false) {
                        return true;
                    }
                    mod = status[moduleName];
                    switch (event.type) {
                    case "load":
                        mod.pageHideFired = false;
                        mod.loadFired = true;
                        return !mod.silentLoad;
                    case "pageshow":
                        mod.pageHideFired = false;
                        event.type = "load";
                        return !mod.loadFired && !mod.silentLoad;
                    case "pagehide":
                        event.type = "unload";
                        mod.loadFired = false;
                        mod.pageHideFired = true;
                        return !mod.silentUnload;
                    case "unload":
                    case "beforeunload":
                        event.type = "unload";
                        mod.loadFired = false;
                        return !mod.pageHideFired && !mod.silentUnload;
                    }
                    return true;
                },

                /**
                 * Checks if event indicates the core context is unloading.
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                isUnload: function (event) {
                    return typeof event === "object" ?
                            (event.type === "unload" || event.type === "beforeunload" || event.type === "pagehide") :
                            false;
                }
            };

        }()),

        /**
         * Keeps track of the events being handled.
         * @private
         */
        events = {},

        /**
         * Keeps track of callback functions registered by the iOS and Android native libraries.
         * These are used for communication with the native library.
         */
        bridgeCallbacks = {},

        /**
         * init implementation (defined later)
         * @private
         */
        _init = function () {},
        _callback = null,

        /**
         * Flag to track if TLT.init API can been called.
         * @private
         */
        okToCallInit = true,

        // Tracks the inactivity timeout in publishEvent
        inactivityTimerId = null,
        // Placeholder for the inactivity timeout handler, defined after core.
        inactivityTimeoutHandler = function () {},

        // main interface for the core
        core = /**@lends TLT*/ {


            /**
             * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
             */
            getStartTime: function () {
                return tltStartTime;
            },

            //---------------------------------------------------------------------
            // Core Lifecycle
            //---------------------------------------------------------------------

            /**
             * Initializes the system. The configuration information is passed to the
             * config service to management it. All modules are started (unless their
             * configuration information indicates they should be disabled), and web events
             * are hooked up.
             * @param {Object} config The global configuration object.
             * @param {function} [callback] function executed after initialization and destroy
                    the callback function takes one parameter which describes UIC state;
                    its value can be set to "initialized" or "destroyed"
             * @returns {void}
             */
            init: function (config, callback) {
                var timeoutCallback;
                _callback = callback;
                if (!okToCallInit) {
                    throw "init must only be called once!";
                }
                okToCallInit = false;
                timeoutCallback = function (event) {
                    event = event || window.event || {};
                    if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
                        if (document.removeEventListener) {
                            document.removeEventListener("DOMContentLoaded", timeoutCallback, false);
                            window.removeEventListener("load", timeoutCallback, false);
                        } else {
                            document.detachEvent("onreadystatechange", timeoutCallback);
                            window.detachEvent("onload", timeoutCallback);
                        }
                        _init(config, callback);
                    }
                };

                // case when DOM already loaded (lazy-loaded UIC)
                if (document.readyState === "complete") {
                    // Lets the current browser cycle to complete before calling init
                    setTimeout(timeoutCallback);
                } else if (document.addEventListener) {
                    document.addEventListener("DOMContentLoaded", timeoutCallback, false);
                    // A fallback in case DOMContentLoaded is not supported
                    window.addEventListener("load", timeoutCallback, false);
                } else {
                    document.attachEvent("onreadystatechange", timeoutCallback);
                    // A fallback in case onreadystatechange is not supported
                    window.attachEvent("onload", timeoutCallback);
                }
            },

            /**
             * Indicates if the system has been initialized.
             * @returns {Boolean} True if init() has been called, false if not.
             */
            isInitialized: function () {
                return initialized;
            },

            getState: function () {
                return state;
            },

            /**
             * Shuts down the system. All modules are stopped and all web events
             * are unsubscribed.
             * @returns {void}
             */
            // destroy: function (skipEvents, callback) {
            destroy: function (skipEvents) {

                var token = "",
                    eventName = "",
                    target = null,
                    serviceName = null,
                    service = null,
                    browser = null,
                    delegateTarget = false;

                if (okToCallInit) { //nothing to do
                    return false;
                }

                this.stopAll();

                if (!skipEvents) {
                    browser = this.getService("browser");
                    // Unregister events
                    for (token in events) {
                        if (events.hasOwnProperty(token) && browser !== null) {
                            eventName = token.split("|")[0];
                            target = events[token].target;
                            delegateTarget = events[token].delegateTarget || undefined;
                            browser.unsubscribe(eventName, target, this._publishEvent, delegateTarget);
                        }
                    }
                }

                // call destroy on services that have it
                for (serviceName in services) {
                    if (services.hasOwnProperty(serviceName)) {
                        service = services[serviceName].instance;

                        if (service && typeof service.destroy === "function") {
                            service.destroy();
                        }

                        services[serviceName].instance = null;
                    }
                }

                isFrameBlacklisted.clearCache();
                events = {};
                initialized = false;

                // Reset to allow re-initialization.
                okToCallInit = true;

                state = "destroyed";

                if (typeof _callback === "function") {
                    // Protect against unexpected exceptions since _callback is 3rd party code.
                    try {
                        _callback("destroyed");
                    } catch (e) {
                        // Do nothing!
                    }
                }
            },

            /**
             * Iterates over each module and starts or stops it according to
             * configuration information.
             * @returns {void}
             * @private
             */
            _updateModules: function (scope) {

                var config = this.getCoreConfig(),
                    browser = this.getService("browser"),
                    moduleConfig = null,
                    moduleName = null;

                if (config && browser && config.modules) {
                    try {
                        for (moduleName in config.modules) {
                            if (config.modules.hasOwnProperty(moduleName)) {
                                moduleConfig = config.modules[moduleName];

                                if (modules.hasOwnProperty(moduleName)) {
                                    if (moduleConfig.enabled === false) {
                                        this.stop(moduleName);
                                        continue;
                                    }

                                    this.start(moduleName);

                                    // If the module has specified events in the configuration
                                    // register event handlers for them.
                                    if (moduleConfig.events) {
                                        this._registerModuleEvents(moduleName, moduleConfig.events, scope);
                                    }
                                } else {    // it needs to be loaded
                                    if (browser.loadScript) {
                                        browser.loadScript(config.moduleBase + moduleName + ".js");
                                        // no callback needed because the module will start automatically
                                    }
                                }
                            }
                        }
                        this._registerModuleEvents.clearCache();
                    } catch (e) {
                        core.destroy();
                        return false;
                    }
                } else {
                    return false;
                }
                return true;
            },

            /**
             * Registers event handlers for all modules in a specific scope.
             * E.g. if the application changed the DOM via ajax and want to let
             * us rebind event handlers in this scope.
             * @param  {Object} scope A DOM element as a scope.
             */
            rebind: function (scope) {
                core._updateModules(scope);
            },

            /* Public API which returns the Tealeaf session data that has been
             * configured to be shared with 3rd party scripts.
             * @returns {object} JSON object containing the session data as
             * name-value pairs. If no data is available then returns null.
             */
            getSessionData: function () {

                if (!core.isInitialized()) {
                    return;
                }

                var rv = null,
                    sessionData = null,
                    scName,
                    scValue,
                    config = core.getCoreConfig();

                if (!config || !config.sessionDataEnabled) {
                    return null;
                }

                sessionData = config.sessionData || {};

                // Add any session ID data
                scName = sessionData.sessionQueryName;
                if (scName) {
                    scValue = core.utils.getQueryStringValue(scName, sessionData.sessionQueryDelim);
                } else {
                    // Either the cookie name is configured or the default is assumed.
                    scName = sessionData.sessionCookieName || "TLTSID";
                    scValue = core.utils.getCookieValue(scName);
                }

                if (scName && scValue) {
                    rv = rv || {};
                    rv.tltSCN = scName;
                    rv.tltSCV = scValue;
                    rv.tltSCVNeedsHashing = !!sessionData.sessionValueNeedsHashing;
                }

                return rv;
            },

            /* Public API to create and add a custom event message to the default
             * queue.
             * @param {string} name Name of the custom event.
             * @param {object} customObj Custom object which will be serialized
             * to JSON and included with the custom message.
             * @returns {void}
             */
            logCustomEvent: function (name, customMsgObj) {

                if (!core.isInitialized()) {
                    return;
                }

                var customMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!name || typeof name !== "string") {
                    name = "CUSTOM";
                }
                customMsgObj = customMsgObj || {};

                customMsg = {
                    type: 5,
                    customEvent: {
                        name: name,
                        data: customMsgObj
                    }
                };
                queue.post("", customMsg, "DEFAULT");
            },

            /* Public API to create and add an exception event message to the
             * default queue.
             * @param {string} msg Description of the error or exception.
             * @param {string} [url] URL related to the error or exception.
             * @param {integer} [line] Line number associated with the error or exception.
             * @returns {void}
             */
            logExceptionEvent: function (msg, url, line) {

                if (!core.isInitialized()) {
                    return;
                }

                var exceptionMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!msg || typeof msg !== "string") {
                    return;
                }
                url = url || "";
                line = line || "";

                exceptionMsg = {
                    type: 6,
                    exception: {
                        description: msg,
                        url: url,
                        line: line
                    }
                };

                queue.post("", exceptionMsg, "DEFAULT");
            },

            /* Public API to create and add a screenview LOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * being loaded. Note: The same name must be used when the screenview
             * UNLOAD API is called.
             * @param {string} [referrerName] Name of the previous screenview that
             * is being replaced.
             * @param {object} [root] DOMNode which represents the root or
             * parent of this screenview. Usually this is a div container.
             * @returns {void}
             */
            logScreenviewLoad: function (name, referrerName, root) {

                if (!core.isInitialized()) {
                    return;
                }

                logScreenview("LOAD", name, referrerName, root);
            },

            /* Public API to create and add a screenview UNLOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * unloaded. Note: This should be the same name used in the screenview
             * LOAD API.
             * @returns {void}
             */
            logScreenviewUnload: function (name) {

                if (!core.isInitialized()) {
                    return;
                }

                logScreenview("UNLOAD", name);
            },

            /* Public API to log a DOM Capture message to the default queue.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            logDOMCapture: function (root, config) {
                var dcid = null,
                    domCaptureData,
                    domCaptureService,
                    msg,
                    queue;

                if (!this.isInitialized()) {
                    return dcid;
                }

                // DOM Capture is not supported on IE 8 and below
                if (core.utils.isLegacyIE) {
                    return dcid;
                }

                domCaptureService = this.getService("domCapture");
                if (domCaptureService) {
                    root = root || window.document;
                    config = config || {};
                    domCaptureData = domCaptureService.captureDOM(root, config);
                    if (domCaptureData) {
                        // Add the unique id for this DOM Capture message
                        dcid = config.dcid || ("dcid-" + this.utils.getSerialNumber() + "." + (new Date()).getTime());
                        domCaptureData.dcid = dcid;
                        // Create the message
                        msg = {
                            "type": 12,
                            "domCapture": domCaptureData
                        };
                        // POST it to the queue
                        queue = this.getService("queue");
                        queue.post("", msg, "DEFAULT");
                    } else {
                        dcid = null;
                    }
                }
                return dcid;
            },

            /* Function invoked by modules to log a DOM Capture message to the default queue.
             * @param {String} moduleName Name of the module which invoked this function.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            performDOMCapture: function (moduleName, root, config) {
                return this.logDOMCapture(root, config);
            },

            /**
             * Helper function for registerBridgeCallbacks
             * It checks if the call back type is valid and enabled.
             * @function
             * @private
             * @param {String}
             * @returns {boolean} Whether callback type is enabled.
             */
            _bridgeCallback: function (cbType) {
                var callBackType = bridgeCallbacks[cbType];

                if (callBackType && callBackType.enabled) {
                    return callBackType;
                }
                return null;
            },

            /**
             * Public API to add a screenshot capture. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            logScreenCapture: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("screenCapture");
                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to enable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            enableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("enableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to disable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            disableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("disableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start a new Tealeaf session. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            startNewTLFSession: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var bridgeCallback = core._bridgeCallback("startNewTLFSession");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start get current Tealeaf session Id. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {String} Current session Id
             */
            currentSessionId: function () {
                if (!core.isInitialized()) {
                    return;
                }
                var sessionId,
                    bridgeCallback = core._bridgeCallback("currentSessionId");

                if (bridgeCallback !== null) {
                    sessionId = bridgeCallback.cbFunction();
                }
                return sessionId;
            },

            /**
             * Public API to get default value of a configurable item in
             * TLFConfigurableItems.properties file.  This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            defaultValueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    return;
                }
                var value,
                    bridgeCallback = core._bridgeCallback("defaultValueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to get the value of a configurable item either from TLFConfigurableItems.properties file
             * or in memory data structure. This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            valueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    return;
                }
                var value,
                    bridgeCallback = core._bridgeCallback("valueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to set the value of a configurable item in TLFConfigurableItems.properties file.
             * This updates only in the memory value. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            setConfigurableItem: function (configItem, value) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("setConfigurableItem");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(configItem, value);
                }
                return result;
            },

            /**
             * Public API to add additional http header.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} key This is the key of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            addAdditionalHttpHeader: function (key, value) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("addAdditionalHttpHeader");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(key, value);
                }
                return result;
            },

            /**
             * Public API to log custom event.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} eventName A custom event name.
             * @param {String} jsonData JSON data string.
             * @param {int} logLevel Tealeaf library logging level for the event.
             * @returns {boolean} Wether item was set.
             */
            logCustomEventBridge: function (eventName, jsonData, logLevel) {
                if (!core.isInitialized()) {
                    return;
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("logCustomEventBridge");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(eventName, jsonData, logLevel);
                }
                return result;
            },

            /**
             * Public API to allow registration of callback functions
             * These callback types are supported currently:
             * 1. screenCapture: Registering this type enables ability to
             *    take screenshots from script.
             * 2. messageRedirect: Registering this type will allow the
             *    callback function to process (and consume) the message
             *    instead of being handled by the default queue.
             * 3. addRequestHeaders: Registering this type will allow the
             *    callback function to return an array of HTTP request headers
             *    that will be set by the UIC in it's requests to the target.
             * @param {Array} callbacks Array of callback objects. Each object
             *                is of the format: {
             *                    {boolean}  enabled
             *                    {string}   cbType
             *                    {function} cbFunction
             *                }
             *                If the callbacks array is empty then any previously
             *                registered callbacks would be removed.
             * @returns {boolean} true if callbacks were registered. false otherwise.
             */
            registerBridgeCallbacks: function (callbacks) {
                var i = 0,
                    len = 0,
                    cb = null;

                // Sanity check
                if (!callbacks) {
                    return false;
                }
                if (callbacks.length === 0) {
                    // Reset any previously registered callbacks.
                    bridgeCallbacks = {};
                    return false;
                }
                try {
                    for (i = 0, len = callbacks.length; i < len; i += 1) {
                        cb = callbacks[i];
                        if (typeof cb === "object" && cb.cbType && cb.cbFunction) {
                            bridgeCallbacks[cb.cbType] = {
                                enabled: cb.enabled,
                                cbFunction: cb.cbFunction
                            };
                        }
                    }
                } catch (e) {
                    return false;
                }
                return true;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the queue to be redirected if a messageRedirect callback
             * has been registered. (see registerBridgeCallbacks)
             * @param {array} queue The queue array containing the individual
             *                message objects.
             * @returns {array} The array that should replace the previously
             *                  passed queue.
             */
            redirectQueue: function (queue) {
                var i,
                    len,
                    cb,
                    retval,
                    sS;

                // Sanity check
                if (!queue || !queue.length) {
                    return queue;
                }

                cb = bridgeCallbacks.messageRedirect;
                if (cb && cb.enabled) {
                    sS = core.getService("serializer");
                    for (i = 0, len = queue.length; i < len; i += 1) {
                        retval = cb.cbFunction(sS.serialize(queue[i]), queue[i]);
                        if (retval && typeof retval === "object") {
                            queue[i] = retval;
                        } else {
                            queue.splice(i, 1);
                            i -= 1;
                            len = queue.length;
                        }
                    }
                }
                return queue;
            },

            _hasSameOrigin: function (iframe) {
                try {
                    return iframe.document.location.host === document.location.host && iframe.document.location.protocol === document.location.protocol;
                } catch (e) {
                    // to be ignored. Error when iframe from different domain
                    //#ifdef DEBUG
                    //TODO add debug log
                    //#endif
                }
                return false;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the addRequestHeaders callback (if registered) to be invoked.
             * (see registerBridgeCallbacks)
             * @returns {array} The array of request headers to be set. Each
             *                  object is of the format:
             *                  {
             *                      name: "header name",
             *                      value: "header value",
             *                      recurring: true
             *                  }
             */
            provideRequestHeaders: function () {
                var headers = null,
                    addHeadersCB = bridgeCallbacks.addRequestHeaders;

                if (addHeadersCB && addHeadersCB.enabled) {
                    headers = addHeadersCB.cbFunction();
                }

                return headers;
            },

            /**
             * Utility function used by core._updateModules.
             * It registers event listners according to module configuration.
             * @name core._registerModuleEvents
             * @function
             * @param {string} moduleName name of the module
             * @param {Array} moduleEvents an array of all module-specific events (from UIC configuration)
             * @param {object} scope DOM element where event will be registered; points either to a main window
             *                 object or to IFrame's content window
             */
            _registerModuleEvents: (function () {

                /**
                 * An instance of core.utils.WeakMap us as a cache for mapping DOM elements with their IDs.
                 * Introduced to reduce number of expensive browserBase.ElementData.prototype.examineID calls.
                 * Object initialization in _registerModuleEvents function
                 * @private
                 * @type {object}
                 */
                var idCache,
                    /**
                     * Helper function that returns the localTop or documentScope object if the
                     * specified prop is "window" or "document" respectively.
                     * @private
                     * @function
                     * @param {string|object} prop
                     * @param {object} localTop
                     * @param {object} documentScope
                     * @returns {string|object} localTop if prop value is "window",
                     *                          documentScope if prop value is "document" else
                     *                          returns the prop value itself
                     */
                    normalizeToObject = function (prop, localTop, documentScope) {
                        if (prop === "window") {
                            return localTop;
                        }
                        if (prop === "document") {
                            return documentScope;
                        }
                        return prop;
                    };

                /**
                 * Helper function for core._registerModuleEvents
                 * It does actual event listeners registration, while the main function managesthe scopes.
                 * @function
                 * @private
                 */
                function _registerModuleEventsOnScope(moduleName, moduleEvents, scope) {
                    var browserBase = core.getService("browserBase"),
                        browser = core.getService("browser"),
                        documentScope = core.utils.getDocument(scope),
                        localTop = core._getLocalTop(),
                        isFrame = core.utils.isIFrameDescendant(scope),
                        frameId,
                        e,
                        i;

                    scope = scope || documentScope;
                    loadUnloadHandler.normalizeModuleEvents(moduleName, moduleEvents, localTop, documentScope);

                    if (isFrame) {
                        frameId = browserBase.ElementData.prototype.examineID(scope).id;
                        // remove one closing ']'
                        if (typeof frameId === "string") {
                            frameId = frameId.slice(0, frameId.length - 1);
                            for (e in events) {
                                if (events.hasOwnProperty(e)) {
                                    for (i = 0; i < events[e].length; i += 1) {
                                        if (moduleName === events[e][i]) {
                                            if (e.indexOf(frameId) !== -1) {
                                                delete events[e];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        var target = normalizeToObject(eventConfig.target, localTop, documentScope) || documentScope,
                            delegateTarget = normalizeToObject(eventConfig.delegateTarget, localTop, documentScope),
                            token = "";

                        if (eventConfig.recurseFrames !== true && isFrame) {
                            return;
                        }

                        // If the target is a string it is a CSS query selector, specified in the config.
                        if (typeof target === "string") {
                            if (eventConfig.delegateTarget && core.getFlavor() === "jQuery") {
                                token = core._buildToken4delegateTarget(eventConfig.name, target, eventConfig.delegateTarget);

                                if (!events.hasOwnProperty(token)) {
                                    events[token] = [moduleName];
                                    events[token].target = target;
                                    events[token].delegateTarget = delegateTarget;
                                    browser.subscribe(eventConfig.name, target, core._publishEvent, delegateTarget, token);
                                } else {
                                    events[token].push(moduleName);
                                }
                            } else {
                                core.utils.forEach(browser.queryAll(target, scope), function (element) {
                                    var idData = idCache.get(element);
                                    if (!idData) {
                                        idData = browserBase.ElementData.prototype.examineID(element);
                                        idCache.set(element, idData);
                                    }
                                    token = eventConfig.name + "|" + idData.id + idData.type;
                                    // If the token already exists, do nothing
                                    if (core.utils.indexOf(events[token], moduleName) !== -1) {
                                        return;
                                    }
                                    events[token] = events[token] || [];
                                    events[token].push(moduleName);
                                    // Save a reference to the tokens target to be able to unregister it later.
                                    events[token].target = element;
                                    browser.subscribe(eventConfig.name, element, core._publishEvent);
                                });
                            }
                        // Else: The target, specified in the config, is an object or empty
                        // (defaults to document), generate a token for events which bubble up
                        // (to the window or document object).
                        } else {
                            token = core._buildToken4bubbleTarget(eventConfig.name, target, typeof eventConfig.target === "undefined");
                            if (!events.hasOwnProperty(token)) {
                                events[token] = [moduleName];
                                browser.subscribe(eventConfig.name, target, core._publishEvent);
                            } else {
                                /* XXX: Only add if module entry doesn't exist. */
                                if (core.utils.indexOf(events[token], moduleName) === -1) {
                                    events[token].push(moduleName);
                                }
                            }
                        }

                        if (token !== "") {
                            if (typeof target !== "string") {
                                events[token].target = target;
                            }
                        }
                    });
                }

                /**
                 * Helper function for core._registerModuleEvents. Checks load status of iframes.
                 * @function
                 * @private
                 * @returns {boolean} true when given frame is completely loaded; false otherwise
                 */
                function _isFrameLoaded(hIFrame) {
                    var iFrameWindow = core.utils.getIFrameWindow(hIFrame);
                    return (iFrameWindow !== null) &&
                            core._hasSameOrigin(iFrameWindow) &&
                            (iFrameWindow.document !== null) &&
                            iFrameWindow.document.readyState === "complete";
                }

                // actual implementation of core._registerModuleEvents
                function registerModuleEvents(moduleName, moduleEvents, scope) {
                    scope = scope || core._getLocalTop().document;
                    idCache = idCache || new core.utils.WeakMap();

                    _registerModuleEventsOnScope(moduleName, moduleEvents, scope);
                    if (moduleName !== "performance") {
                        var hIFrame = null,
                            hIFrameWindow = null,
                            browserService = core.getService("browser"),
                            cIFrames = browserService.queryAll("iframe, frame", scope),
                            i,
                            iLength;

                        for (i = 0, iLength = cIFrames.length; i < iLength; i += 1) {
                            hIFrame = cIFrames[i];
                            if (isFrameBlacklisted(hIFrame)) {
                                continue;
                            }
                            if (_isFrameLoaded(hIFrame)) {
                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                            }

                            (function (moduleName, moduleEvents, hIFrame) {
                                var hIFrameWindow = null,
                                    _iframeContext = {
                                        moduleName: moduleName,
                                        moduleEvents: moduleEvents,
                                        hIFrame: hIFrame,

                                        _registerModuleEventsDelayed: function () {
                                            var hIFrameWindow = null;

                                            if (!isFrameBlacklisted(hIFrame)) {
                                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                                if (core._hasSameOrigin(hIFrameWindow)) {
                                                    core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                                                }
                                            }
                                        }
                                    };

                                core.utils.addEventListener(hIFrame, "load", function () {
                                    _iframeContext._registerModuleEventsDelayed();
                                });

                                if (core.utils.isLegacyIE && _isFrameLoaded(hIFrame)) {
                                    hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                    core.utils.addEventListener(hIFrameWindow.document, "readystatechange", function () {
                                        _iframeContext._registerModuleEventsDelayed();
                                    });
                                }

                            }(moduleName, moduleEvents, hIFrame));
                        }
                    }
                }

                registerModuleEvents.clearCache = function () {
                    if (idCache) {
                        idCache.clear();
                        idCache = null;
                    }
                };

                return registerModuleEvents;
            }()), // end of _registerModuleEvents factory


            /**
             * Build the token for an event using the currentTarget of the event
             * (only if the current browser supports currenTarget) Otherwise uses
             * the event.target
             * @param  {Object} event The WebEvent
             * @return {String}       Returns the token as a string, consist of:
             *         eventType | target id target idtype
             */
            _buildToken4currentTarget: function (event) {
                var target = event.nativeEvent ? event.nativeEvent.currentTarget : null,
                    idData = target ? this.getService("browserBase").ElementData.prototype.examineID(target) :
                            {
                                id: event.target.id,
                                type: event.target.idType
                            };
                return event.type + "|" + idData.id + idData.type;
            },

            /**
             * Build the token for delegate targets
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | target | delegateTarget
             */
            _buildToken4delegateTarget: function (eventType, target, delegateTarget) {
                return eventType + "|" + target + "|" + delegateTarget;
            },

            /**
             * Build the token for bubble targets (either window or document)
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | null-2 | window or document
             */
            _buildToken4bubbleTarget: function (eventType, target, checkIframe, delegateTarget) {
                var localTop = core._getLocalTop(),
                    localWindow,
                    browserService = core.getService("browser"),
                    _getIframeElement = function (documentScope) {
                        var retVal = null;

                        if (core._hasSameOrigin(localWindow.parent)) {
                            core.utils.forEach(browserService.queryAll("iframe, frame", localWindow.parent.document), function (iframe) {
                                var iFrameWindow = null;

                                if (!isFrameBlacklisted(iframe)) {
                                    iFrameWindow = core.utils.getIFrameWindow(iframe);
                                    if (core._hasSameOrigin(iFrameWindow) && iFrameWindow.document === documentScope) {
                                        retVal = iframe;
                                    }
                                }
                            });
                        }
                        return retVal;
                    },
                    documentScope = core.utils.getDocument(target),
                    browserBase = this.getService("browserBase"),
                    iframeElement = null,
                    tmpTarget,
                    retVal = eventType,
                    idData;

                if (documentScope) {
                    localWindow = documentScope.defaultView || documentScope.parentWindow;
                }

                if (target === window || target === window.window) {
                    retVal += "|null-2|window";
                } else {
                    if (checkIframe && localWindow && core._hasSameOrigin(localWindow.parent) && typeof documentScope !== "undefined" && localTop.document !== documentScope) {
                        iframeElement = _getIframeElement(documentScope);
                        if (iframeElement) {
                            tmpTarget = browserBase.ElementData.prototype.examineID(iframeElement);
                            retVal += "|" + tmpTarget.xPath + "-2";
                        }
                    } else if (delegateTarget && delegateTarget !== document && core.getFlavor() === "jQuery") {
                        // NOTE: elegateTarget !== document  --- because simple jQuery.on has delegateTarget set to document
                        // for event defined without target e.g. { name: "click", recurseFrame: true }
                        retVal += "|null-2|" + core.utils.getTagName(target) + "|" + core.utils.getTagName(delegateTarget);
                    } else {
                        retVal += "|null-2|document";
                    }
                }

                return retVal;
            },

            /**
             * Event handler for when configuration gets updated.
             * @returns {void}
             * @private
             */
            _reinitConfig: function () {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.
                core._updateModules();
            },

            /**
             * Iterates over each module delivers the event object if the module
             * is interested in that event.
             * @param {Event} event An event object published by the browser service.
             * @returns {void}
             * @private
             */
            _publishEvent: function (event) {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.

                var moduleName = null,
                    module = null,
                    // generate the explicit token for the element which received the event
                    // if event is delegated it will have event.data set to the token
                    token = (event.delegateTarget && event.data) ? event.data : core._buildToken4currentTarget(event),
                    modules = null,
                    i,
                    len,
                    target,
                    modEvent = null,
                    canIgnore = false,
                    canPublish = false,
                    coreConfig = core.getCoreConfig(),
                    browserService = core.getService("browser"),
                    delegateTarget = event.delegateTarget || null;

                // Reset the inactivity timer
                if (inactivityTimerId) {
                    clearTimeout(inactivityTimerId);
                }
                // Set inactivity timeout with default of 10 minutes.
                inactivityTimerId = setTimeout(inactivityTimeoutHandler, core.utils.getValue(coreConfig, "inactivityTimeout", 600000));

                // ignore native browser 'load' events
                if ((event.type === "load" || event.type === "pageshow") && !event.nativeEvent.customLoad) {
                    return;
                }

                // IE only: ignore 'beforeunload' fired by link placed in blacklist of excluded links
                if (core.utils.isIE) {
                    if (event.type === "click") {
                        lastClickedElement = event.target.element;
                    }
                    if (event.type === "beforeunload") {
                        canIgnore = false;
                        core.utils.forEach(coreConfig.ieExcludedLinks, function (selector) {
                            var i,
                                len,
                                el = browserService.queryAll(selector);

                            for (i = 0, len = el ? el.length : 0; i < len; i += 1) {
                                if (typeof el[i] !== undefined && el[i] === lastClickedElement) {
                                    // Last clicked element was in the blacklist. Set the ignore flag.
                                    canIgnore = true;
                                    return;
                                }
                            }
                        });

                        if (canIgnore) {
                            // The beforeunload can be ignored.
                            return;
                        }
                    }
                }

                // if an unload event is triggered update the core's internal state to "unloading"
                if (loadUnloadHandler.isUnload(event)) {
                    state = "unloading";
                }

                // ignore native browser 'change' events on IE<9/W3C for radio buttons and checkboxes
                if (event.type === "change" && core.utils.isLegacyIE && core.getFlavor() === "w3c" &&
                        (event.target.element.type === "checkbox" || event.target.element.type === "radio")) {
                    return;
                }

                // use 'propertychange' event in IE<9 to simulate 'change' event on radio and checkbox
                if (event.type === "propertychange") {
                    if (event.nativeEvent.propertyName === "checked" && (event.target.element.type === "checkbox" || (event.target.element.type === "radio" && event.target.element.checked))) {
                        event.type = "change";
                        event.target.type = "INPUT";
                    } else {
                        return;
                    }
                }

                // No module has registered the event for the currentTarget,
                // build token for bubble target (document or window)
                if (!events.hasOwnProperty(token)) {
                    if (event.hasOwnProperty("nativeEvent")) {
                        target = event.nativeEvent.currentTarget || event.nativeEvent.target;
                    }
                    token = core._buildToken4bubbleTarget(event.type, target, true, delegateTarget);
                }

                if (events.hasOwnProperty(token)) {
                    modules = events[token];
                    for (i = 0, len = modules.length; i < len; i += 1) {
                        moduleName = modules[i];
                        module = core.getModule(moduleName);
                        modEvent = core.utils.mixin({}, event);
                        if (module && core.isStarted(moduleName) && typeof module.onevent === "function") {
                            canPublish = loadUnloadHandler.canPublish(moduleName, modEvent);
                            if (canPublish) {
                                module.onevent(modEvent);
                            }
                        }
                    }
                }

                if (modEvent && modEvent.type === "unload" && canPublish) {
                    core.destroy();
                }

            },

            _getLocalTop: function () {
                // Return window.window instead of window due to an IE quirk where (window == top) is true but (window === top) is false
                // In such cases, (window.window == top) is true and so is (window.window === top)  Hence window.window is more reliable
                // to compare to see if the library is included in the top window.
                return window.window;
            },

            //---------------------------------------------------------------------
            // Module Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a module creator with TLT.
             * @param {String} moduleName The name of the module that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the module.
             * @returns {void}
             */
            addModule: function (moduleName, creator) {


                modules[moduleName] = {
                    creator: creator,
                    instance: null,
                    context: null,
                    messages: []
                };

                // If the core is initialized, then this module has been dynamically loaded. Start it.
                if (this.isInitialized()) {
                    this.start(moduleName);
                }
            },

            /**
             * Returns the module instance of the given module.
             * @param {String} moduleName The name of the module to retrieve.
             * @returns {Object} The module instance if it exists, null otherwise.
             */
            getModule: function (moduleName) {
                if (modules[moduleName] && modules[moduleName].instance) {
                    return modules[moduleName].instance;
                }
                return null;
            },

            /**
             * Unregisters a module and stops and destroys its instance.
             * @param {String} moduleName The name of the module to remove.
             * @returns {void}
             */
            removeModule: function (moduleName) {

                this.stop(moduleName);
                delete modules[moduleName];
            },

            /**
             * Determines if a module is started by looking for the instance.
             * @param {String} moduleName The name of the module to check.
             * @returns {void}
             */
            isStarted: function (moduleName) {
                return modules.hasOwnProperty(moduleName) && modules[moduleName].instance !== null;
            },

            /**
             * Creates a new module instance and calls it's init() method.
             * @param {String} moduleName The name of the module to start.
             * @returns {void}
             */
            start: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;


                // Only continue if the module data exists and there's not already an instance
                if (moduleData && moduleData.instance === null) {

                    // create the context and instance
                    moduleData.context = new TLT.ModuleContext(moduleName, this);
                    instance = moduleData.instance = moduleData.creator(moduleData.context);

                    // allow module to initialize itself
                    if (typeof instance.init === "function") {
                        instance.init();
                    }

                }
            },

            /**
             * Starts all registered modules, creating an instance and calling their
             * init() methods.
             * @returns {void}
             */
            startAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.start(moduleName);
                    }
                }
            },

            /**
             * Stops a module, calls it's destroy() method, and deletes the instance.
             * @param {String} moduleName The name of the module to stop.
             * @returns {void}
             */
            stop: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                // Only continue if the module instance exists
                if (moduleData && moduleData.instance !== null) {

                    instance = moduleData.instance;

                    // allow module to clean up after itself
                    if (typeof instance.destroy === "function") {
                        instance.destroy();
                    }

                    moduleData.instance = moduleData.context = null;

                }
            },

            /**
             * Stops all registered modules, calling their destroy() methods,
             * and removing their instances.
             * @returns {void}
             */
            stopAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.stop(moduleName);
                    }
                }
            },

            //---------------------------------------------------------------------
            // Service Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a service creator with TLT.
             * @param {String} serviceName The name of the service that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the service.
             * @returns {void}
             */
            addService: function (serviceName, creator) {


                services[serviceName] = {
                    creator: creator,
                    instance: null
                };
            },

            /**
             * Retrieves a service instance, creating it if one doesn't already exist.
             * @param {String} serviceName The name of the service to retrieve.
             * @returns {Object} The service object as returned from the service
             *      creator or null if the service doesn't exist.
             */
            getService: function (serviceName) {
                if (services.hasOwnProperty(serviceName)) {
                    if (!services[serviceName].instance) {
                        // If you want to have a separate ServiceContext, pass it here instead of "this"
                        try {
                            services[serviceName].instance = services[serviceName].creator(this);
                            if (typeof services[serviceName].instance.init === "function") {
                                services[serviceName].instance.init();
                            }
                        } catch (e) {
                            // shut the library down if jQuery or sizzle is not found / not supported
                            return null;
                        }
                        if (typeof services[serviceName].instance.getServiceName !== "function") {
                            services[serviceName].instance.getServiceName = function () {
                                return serviceName;
                            };
                        }
                    }
                    return services[serviceName].instance;
                }
                return null;
            },

            /**
             * Unregisters a service and destroys its instance.
             * @param {String} serviceName The name of the service to remove.
             * @returns {void}
             */
            removeService: function (serviceName) {
                delete services[serviceName];
            },

            //---------------------------------------------------------------------
            // Intermodule Communication
            //---------------------------------------------------------------------

            /**
             * Broadcasts a message throughout the system to all modules who are
             * interested.
             * @param {Object} message An object containing at least a type property
             *      indicating the message type.
             * @returns {void}
             */
            broadcast: function (message) {
                var i = 0,
                    len = 0,
                    prop = null,
                    module = null;

                if (message && typeof message === "object") {


                    for (prop in modules) {
                        if (modules.hasOwnProperty(prop)) {
                            module = modules[prop];

                            if (core.utils.indexOf(module.messages, message.type) > -1) {
                                if (typeof module.instance.onmessage === "function") {
                                    module.instance.onmessage(message);
                                }
                            }
                        }
                    }
                }
            },

            /**
             * Instructs a module to listen for a particular type of message.
             * @param {String} moduleName The module that's interested in the message.
             * @param {String} messageType The type of message to listen for.
             * @returns {void}
             */
            listen: function (moduleName, messageType) {
                var module = null;

                if (this.isStarted(moduleName)) {
                    module = modules[moduleName];

                    if (core.utils.indexOf(module.messages, messageType) === -1) {
                        module.messages.push(messageType);
                    }
                }
            },
            /**
             * Stops UIC and throws an error.
             * @function
             * @throws {UICError}
             */
            fail: function (message, failcode, skipEvents) {
                message = "UIC FAILED. " + message;
                try {
                    core.destroy(!!skipEvents);
                } finally {
                    core.utils.clog(message);
                    throw new core.UICError(message, failcode);
                }
            },

            /**
             * @constructor
             */
            UICError: (function () {
                function UICError(message, errorCode) {
                    this.message = message;
                    this.code = errorCode;
                }
                UICError.prototype = new Error();
                UICError.prototype.name = "UICError";
                UICError.prototype.constructor = UICError;
                return UICError;
            }()),


            /**
             * Return the name of UIC flavor ("w3c" or "jQuery")
             * @function
             */
            getFlavor: function () {
                // TODO: Use the existing browserService method here
                return "w3c";
            }
        };

    /**
     * Inactivity timeout handler function. When the timer expires,
     * log an exception message indicating the timeout and shutdown.
     * @private
     */
    inactivityTimeoutHandler = function () {
        core.logExceptionEvent("Inactivity timeout.");
        core.destroy();
    }

    /**
     * Actual init function called from TLT.init when the DOM is ready.
     * @private
     * @see TLT.init
     */
    _init = function (config, callback) {
        var configService,
            event,
            webEvent,
            baseBrowser,
            browserService;

        if (initialized) {
            core.utils.clog("TLT.init() called more than once. Ignoring.");
            return;
        }

        // Do not initialize if replay is enabled.
        if (TLT && TLT.replay) {
            return;
        }

        configService = core.getService("config");
        configService.updateConfig(config);

        if (!core._updateModules()) {
            if (state !== "destroyed") {
                core.destroy();
            }
            return;
        }

        if (configService.subscribe) {
            configService.subscribe("configupdated", core._reinitConfig);
        }

        initialized = true;
        state = "loaded";

        //generate fake load event to send for modules
        event = {
            type: 'load',
            target: window.window,
            srcElement: window.window,
            currentTarget: window.window,
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            timeStamp: +new Date(),
            customLoad: true
        };

        baseBrowser = core.getService("browserBase");
        webEvent = new baseBrowser.WebEvent(event);
        core._publishEvent(webEvent);

        if (typeof _callback === "function") {
            // Protect against unexpected exceptions since _callback is 3rd party code.
            try {
                _callback("initialized");
            } catch (e) {
                // Do nothing!
            }
        }
    };

    // Add methods that passthrough to services
    (function () {

        var name = null,
            i,
            len;

        for (name in servicePassthroughs) {
            if (servicePassthroughs.hasOwnProperty(name)) {
                for (i = 0, len = servicePassthroughs[name].length; i < len; i += 1) {
                    (function (serviceName, methodName) {
                        core[methodName] = function () {
                            var service = this.getService(serviceName);
                            if (service) {
                                return service[methodName].apply(service, arguments);
                            }
                        };
                    }(name, servicePassthroughs[name][i]));

                }
            }
        }

    }());

    return core;
}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines utility functions available to all modules via context object or as TLT.utils
 * @exports TLT.utils
 */

/*global TLT, window*/
/*jshint loopfunc:true*/

(function () {

    "use strict";

    var ua = window.navigator.userAgent.toLowerCase(),

        _isIE = (ua.indexOf("msie") !== -1),

        _isLegacyIE = (function () {
            // W3 Navigation timing spec. supported from IE 9 onwards.
            var isNavTimingSupported = !!window.performance;
            return (_isIE && (!isNavTimingSupported || document.documentMode < 9));
        }()),

        _isAndroid = (ua.indexOf("android") !== -1),

        _isiOS = /(ipad|iphone|ipod)/.test(ua),

        tltUniqueIndex = 1,

        utils = {
            /**
             * Indicates if browser is IE.
             */
            isIE: _isIE,

            /**
             * Indicates if browser is IE<9 or IE 9+ running in
             * compatibility mode.
             */
            isLegacyIE: _isLegacyIE,

            /**
             * Indicates if the browser is based on an Android platform device.
             */
            isAndroid: _isAndroid,

            /**
             * Indicates if the browser is based on an iOS platform device.
             */
            isiOS: _isiOS,

            /**
             * Checks whether given parameter is null or undefined
             * @param {*} obj Any value
             * @returns {boolean} True if obj is null or undefined; false otherwise
             */
            isUndefOrNull: function (obj) {
                return typeof obj === "undefined" || obj === null;
            },

            /**
             * Returns a unique serial number
             * @returns {int} A number that can be used as a unique identifier.
             */
            getSerialNumber: function () {
                var id;

                id = tltUniqueIndex;
                tltUniqueIndex += 1;

                return id;
            },

            /**
             * Used to test and get value from an object.
             * @private
             * @function
             * @name core.utils.getValue
             * @param {object} parentObj An object you want to get a value from.
             * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
             * @param {object|String|Number} [defaultValue] The default value to be returned if the property is not found.
             * @return {object} If object is found, if not then default value will be returned. If the default value is
             * not defined then null will be returned.
             */
            getValue: function (parentObj, propertyAsStr, defaultValue) {
                var i,
                    len,
                    properties;

                defaultValue = defaultValue || null;

                // Sanity check
                if (!parentObj || typeof parentObj !== "object" || typeof propertyAsStr !== "string") {
                    return defaultValue;
                }

                properties = propertyAsStr.split(".");
                for (i = 0, len = properties.length; i < len; i += 1) {
                    if (this.isUndefOrNull(parentObj) || typeof parentObj[properties[i]] === "undefined") {
                        return defaultValue;
                    }
                    parentObj = parentObj[properties[i]];
                }
                return parentObj;
            },

            /**
             * Helper function to find an item in an array.
             * @param {Array} array The array to search.
             * @param {String} item The item to search for.
             * @returns {int} The index of the item if found, -1 if not.
             */
            indexOf: function (array, item) {
                var i,
                    len;

                if (array && array instanceof Array) {
                    for (i = 0, len = array.length; i < len; i += 1) {
                        if (array[i] === item) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            /**
             * Invokes callback for each element of an array.
             * @param {Array} array The array (or any indexable object) to walk through
             * @param {function} callback Callback function
             * @param {object} [context] context object; if not provided global object will be considered
             */
            forEach: function (array, callback, context) {
                var i,
                    len;

                // Sanity checks
                if (!array || !array.length || !callback || !callback.call) {
                    return;
                }

                for (i = 0, len = array.length; i < len; i += 1) {
                    callback.call(context, array[i], i, array);
                }
            },

            /**
             * Returns true if callback returns true at least once. Callback is
             * called for each array element unless it reaches end of array or
             * returns true.
             * @param {object} array An Array or any indexable object to walk through
             * @param {function} callback A callback function
             * @returns {boolean} True if callback returned true at least once; false otherwise
             */
            some: function (array, callback) {
                var i,
                    len,
                    val = false;

                for (i = 0, len = array.length; i < len; i += 1) {
                    val = callback(array[i], i, array);
                    if (val) {
                        return val;
                    }
                }
                return val;
            },

            /**
             * Converts an arguments object into an array. This is used to augment
             * the arguments passed to the TLT methods used by the Module Context.
             * @param {Arguments} items An array-like collection.
             * @return {Array} An array containing the same items as the collection.
             */
            convertToArray: function (items) {
                var i = 0,
                    len = items.length,
                    result = [];

                while (i < len) {
                    result.push(items[i]);
                    i += 1;
                }

                return result;
            },

            mixin: function (dst) {
                var prop,
                    src,
                    srcId,
                    len;

                for (srcId = 1, len = arguments.length; srcId < len; srcId += 1) {
                    src = arguments[srcId];
                    for (prop in src) {
                        if (Object.prototype.hasOwnProperty.call(src, prop)) {
                            dst[prop] = src[prop];
                        }
                    }
                }
                return dst;
            },

            extend: function (deep, target, src) {
                var prop = "";

                for (prop in src) {
                    if (Object.prototype.hasOwnProperty.call(src, prop)) {
                        if (deep && Object.prototype.toString.call(src[prop]) === "[object Object]") {
                            if (typeof target[prop] === "undefined") {
                                target[prop] = {};
                            }
                            utils.extend(deep, target[prop], src[prop]);
                        } else {
                            target[prop] = src[prop];
                        }
                    }
                }
                return target;
            },

            /**
             * Makes copy of an object.
             * @function
             * @name core.utils.clone
             * @param {object} obj A object that will be cloned.
             * @return {object} Object cloned.
             */
            clone: function (obj) {
                var copy,
                    attr;

                if (null === obj || "object" !== typeof obj) {
                    return obj;
                }

                if (obj instanceof Object) {
                    copy = (Object.prototype.toString.call(obj) === "[object Array]") ? [] : {};
                    for (attr in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, attr)) {
                            copy[attr] = utils.clone(obj[attr]);
                        }
                    }
                    return copy;
                }
            },

            /**
             *
             */
            createObject: (function () {
                var fn = null,
                    F = null;
                if (typeof Object.create === "function") {
                    fn = Object.create;
                } else {
                    F = function () {};
                    fn = function (o) {
                        if (typeof o !== "object" && typeof o !== "function") {
                            throw new TypeError("Object prototype need to be an object!");
                        }
                        F.prototype = o;
                        return new F();
                    };
                }
                return fn;
            }()),

            /**
             * Method access the object element based on a string. By default it searches starting from window object.
             * @function
             * @example core.utils.access("document.getElementById");
             * @example core.utils.access("address.city", person);
             * @param {string} path Path to object element. Currently on dot separators are supported (no [] notation support)
             * @param {object} [rootObj=window] Root object where there search starts. window by default
             * @return {*} Object element or undefined if the path is not valid
             */
            access: function (path, rootObj) {
                var obj = rootObj || window,
                    arr,
                    i,
                    len;

                if (typeof path !== "string" || (typeof obj !== "object" && obj !== null)) {
                    return;
                }
                arr = path.split(".");
                for (i = 0, len = arr.length; i < len; i += 1) {
                    if (i === 0 && arr[i] === "window") {
                        continue;
                    }
                    if (!Object.prototype.hasOwnProperty.call(obj, arr[i])) {
                        return;
                    }
                    obj = obj[arr[i]];
                    if (i < (len - 1) && !(obj instanceof Object)) {
                        return;
                    }
                }
                return obj;
            },

            /**
             * Checks if a given character is numeric.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the given character is a number.
             */
            isNumeric: function (character) {
                return !isNaN(character + 1 - 1);
            },

            /**
             * Checks if a given character is uppercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is uppercase.
             *                        Otherwise false.
             */
            isUpperCase: function (character) {
                return character === character.toUpperCase() &&
                        character !== character.toLowerCase();
            },

            /**
             * Checks if a given character is lowercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is lowercase.
             *                        Otherwise false.
             */
            isLowerCase: function (character) {
                return character === character.toLowerCase() &&
                        character !== character.toUpperCase();
            },

            getDocument: function (node) {
                if (node.nodeType !== 9) {
                    return (!utils.isUndefOrNull(node.ownerDocument)) ? (node.ownerDocument) : (node.document);
                }
                return node;
            },

            getWindow: function (node) {
                if (node.self !== node) {
                    var ownerDocument = utils.getDocument(node);
                    return (!utils.isUndefOrNull(ownerDocument.defaultView)) ? (ownerDocument.defaultView) : (ownerDocument.parentWindow);
                }
                return node;
            },

            /**
             * Given a HTML frame element, returns the window object of the frame. Tries the contentWindow property
             * first. If contentWindow is not accessible, tries the contentDocument.parentWindow property instead.
             * @param {Object} iFrameElement The HTML frame element object.
             * @return {Object} Returns the window object of the frame element or null.
             */
            getIFrameWindow: function (iFrameElement) {
                var contentWindow = null;

                if (!iFrameElement) {
                    return contentWindow;
                }

                try {
                    contentWindow = iFrameElement.contentWindow ||
                        (iFrameElement.contentDocument ? iFrameElement.contentDocument.parentWindow : null);
                } catch (e) {
                    // Do nothing.
                }

                return contentWindow;
            },

            getTagName: function (node) {
                if (node === document) {
                    return "document";
                }
                if (node === window || node === window.window) {
                    return "window";
                }
                if (typeof node === "string") {
                    return node.toLowerCase();
                }
                if (typeof node === "object" && !utils.isUndefOrNull(node) && typeof node.tagName === "string") {
                    return node.tagName.toLowerCase();
                }
                return "";
            },

            /**
             * Returns true if given node is element from a frame
             * @private
             * @param {Element} node DOM element
             * @return {boolean} true if input element is element from a frame; false otherwise
             */
            isIFrameDescendant: function (node) {
                /*jshint eqeqeq:false, eqnull: false */
                /* The != operator below is on purpose due to legacy IE issues, where:
                   window === top returns false, but window == top returns true */
                return utils.getWindow(node) != TLT._getLocalTop();
            },

            /**
             * Takes the orientation in degrees and returns the orientation mode as a
             * text string. 0, 180 and 360 correspond to portrait mode while 90, -90
             * and 270 correspond to landscape.
             * @function
             * @name core.utils.getOrientationMode
             * @param {number} orientation A normalized orientation value such as
             *          0, -90, 90, 180, 270, 360.
             * @return {string} "PORTRAIT" or "LANDSCAPE" for known orientation values.
             * "UNKNOWN" for unrecognized values. "INVALID" in case of error.
             */
            getOrientationMode: function (orientation) {
                var mode = "INVALID";

                if (typeof orientation !== "number") {
                    return mode;
                }

                switch (orientation) {
                case 0:
                case 180:
                case 360:
                    mode = "PORTRAIT";
                    break;
                case 90:
                case -90:
                case 270:
                    mode = "LANDSCAPE";
                    break;
                default:
                    mode = "UNKNOWN";
                    break;
                }

                return mode;
            },

            clog: (function (window) {
                return function () {
                    // Do nothing!
                };
            }(window)),

            /**
             * Trims any whitespace and returns the trimmed string.
             * @function
             * @name core.utils.trim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            trim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+|\s+$/g, "");
            },

            /**
             * Trims any whitespace at the beginning of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.ltrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            ltrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+/, "");
            },

            /**
             * Trims any whitespace at the end of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.rtrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            rtrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/\s+$/, "");
            },

            /**
             * Finds and returns the named cookie's value.
             * @function
             * @name core.utils.getCookieValue
             * @param {string} cookieName The name of the cookie.
             * @param {string} [cookieString] Optional cookie string in which to search for cookieName.
             * If none is specified, then document.cookie is used by default.
             * @return {string} The cookie value if a match is found or null.
             */
            getCookieValue: function (cookieName, cookieString) {
                var i,
                    len,
                    cookie,
                    cookies,
                    cookieValue = null,
                    cookieNameLen;

                try {
                    cookieString = cookieString || document.cookie;

                    // Sanity check.
                    if (!cookieName || !cookieName.toString) {
                        return null;
                    }

                    // Append an '=' to the cookie name
                    cookieName += "=";
                    cookieNameLen = cookieName.length;

                    // Get the individual cookies into an array and look for a match
                    cookies = cookieString.split(';');
                    for (i = 0, len = cookies.length; i < len; i += 1) {
                        cookie = cookies[i];
                        cookie = utils.ltrim(cookie);

                        // Check if cookieName matches the current cookie prefix.
                        if (cookie.indexOf(cookieName) === 0) {
                            // Match found! Get the value (i.e. RHS of "=" sign)
                            cookieValue = cookie.substring(cookieNameLen, cookie.length);
                            break;
                        }
                    }
                } catch (e) {
                    cookieValue = null;
                }

                return cookieValue;
            },

            /**
             * Finds and returns the query parameter's value.
             * @function
             * @name core.utils.getQueryStringValue
             * @param {string} paramName The name of the query parameter.
             * @param {string} [queryDelim] The query string delimiter. Either ";" or "&"
             * @param {string} [queryString] Optional query string in which to search for the query parameter.
             * If none is specified, then document.location.search is used by default.
             * @return {string} The query parameter value if a match is found or null.
             */
            getQueryStringValue: function (paramName, queryDelim, queryString) {
                var i,
                    j,
                    queryStringLen,
                    paramValue = null,
                    valueStartIndex;

                try {
                    queryString = queryString || window.location.search;
                    queryStringLen = queryString.length;

                    // Sanity check.
                    if (!paramName || !paramName.toString || !queryStringLen) {
                        return null;
                    }

                    // Default delimiter is &
                    queryDelim = queryDelim || "&";
                    // Normalize for easy searching by replacing initial '?' with the delimiter
                    queryString = queryDelim + queryString.substring(1);
                    // Modify the parameter name to prefix the delimiter and append an '='
                    paramName = queryDelim + paramName + "=";

                    i = queryString.indexOf(paramName);
                    if (i !== -1) {
                        valueStartIndex = i + paramName.length;
                        // Match found! Get the value (i.e. RHS of "=" sign upto the delim or end of string)
                        j = queryString.indexOf(queryDelim, valueStartIndex);
                        if (j === -1) {
                            j = queryStringLen;
                        }
                        paramValue = decodeURIComponent(queryString.substring(valueStartIndex, j));
                    }
                } catch (e) {
                    // Do nothing!
                }

                return paramValue;
            },

            /**
             * Quick wrapper for addEventL:istener/attachEvent. Mainly to be used for core, before UIC is fully
             * initialized
             * @function
             * @name core.util.addEventListener
             */
            addEventListener: (function () {
                if (window.addEventListener) {
                    return function (element, eventName, listener) {
                        element.addEventListener(eventName, listener, false);
                    };
                }
                return function (element, eventName, listener) {
                    element.attachEvent("on" + eventName, listener);
                };
            }()),

            /**
             * Returns the index of the rule that is matched by the target object.
             * @function
             * @name core.utils.matchTarget
             * @param {Array} rules An array of match rules containing objects such as
             * {id, idType} or { { regex }, idType } or a string representing "CSS Selectors"
             * @param {Object} target  The normalized target object of the message.
             * @return {int} Returns the index of the matching rule. If none of the rules match then returns -1.
             */
            matchTarget: function (rules, target) {
                var i,
                    j,
                    matchIndex = -1,
                    qr,
                    qrLen,
                    qrTarget,
                    regex,
                    len,
                    rule;

                // Sanity check
                if (!rules || !target) {
                    return matchIndex;
                }

                if (!this.browserService || !this.browserBaseService) {
                    this.browserService = TLT.getService("browser");
                    this.browserBaseService = TLT.getService("browserBase");
                }

                for (i = 0, len = rules.length; i < len && matchIndex === -1; i += 1) {
                    rule = rules[i];

                    // Check if rule is a selector string.
                    if (typeof rule === "string") {
                        qr = this.browserService.queryAll(rule);
                        for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                            if (qr[j]) {
                                qrTarget = this.browserBaseService.ElementData.prototype.examineID(qr[j]);
                                if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                                    matchIndex = i;
                                    break;
                                }
                            }
                        }
                    } else if (rule.id && rule.idType && target.idType.toString() === rule.idType.toString()) {
                        // Note: idType provided by wizard is a string so convert both to strings before comparing.

                        // An id in the rules list could be a direct match, in which case it will be a string OR
                        // it could be a regular expression in which case it would be an object like this:
                        // {regex: ".+private$", flags: "i"}
                        switch (typeof rule.id) {
                        case "string":
                            if (rule.id === target.id) {
                                matchIndex = i;
                            }
                            break;
                        case "object":
                            regex = new RegExp(rule.id.regex, rule.id.flags);
                            if (regex.test(target.id)) {
                                matchIndex = i;
                            }
                            break;
                        }
                    }
                }
                return matchIndex;
            },

            /**
             * Basic WeakMap implementation - a map which can be indexed with objects.
             * In comparison to the original API 'delete' method has been replaced with 'remove'
             * due to compatibility with legacy IE
             * @constructor
             * @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/WeakMap
             */
            WeakMap: (function () {
                function index(data, key) {
                    var i,
                        len;
                    data = data || [];
                    for (i = 0, len = data.length; i < len; i += 1) {
                        if (data[i][0] === key) {
                            return i;
                        }
                    }
                    return -1;
                }
                return function () {
                    var data = [];
                    this.set = function (key, val) {
                        var idx = index(data, key);
                        data[idx > -1 ? idx : data.length] = [key, val];
                    };
                    this.get = function (key) {
                        var arr = data[index(data, key)];
                        return (arr ? arr[1] : undefined);
                    };
                    this.clear = function () {
                        data = [];
                    };
                    this.has = function (key) {
                        return (index(data, key) >= 0);
                    };
                    this.remove = function (key) {
                        var idx = index(data, key);
                        if (idx >= 0) {
                            data.splice(idx, 1);
                        }
                    };
                    this["delete"] = this.remove;
                };
            }())
        };


    if (typeof TLT === "undefined" || !TLT) {
        window.TLT = {};
    }

    TLT.utils = utils;

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines a simple event target interface that can be inherited
 *      from by other parts of the system.
 * @exports TLT.EventTarget
 */
/*global TLT*/

(function () {

    "use strict";

    /**
     * Abstract type that implements basic event handling capabilities.
     * Other types may inherit from this in order to provide custom
     * events.
     * @constructor
     */
    TLT.EventTarget = function () {

        /**
         * Holds all registered event handlers. Each property represents
         * a specific event, each property value is an array containing
         * the event handlers for that event.
         * @type Object
         */
        this._handlers = {};

    };

    TLT.EventTarget.prototype = {

        /**
         * Restores the constructor to the correct value.
         * @private
         */
        constructor: TLT.EventTarget,

        /**
         * Publishes an event with the given name, which causes all
         * event handlers for that event to be called.
         * @param {String} name The name of the event to publish.
         * @param {Variant} [data] The data to provide for the event.
         * @returns {void}
         */
        publish: function (name, data) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name],
                event = {
                    type: name,
                    data: data
                };

            if (typeof handlers !== "undefined") {
                for (len = handlers.length; i < len; i += 1) {
                    handlers[i](event);
                }
            }

        },

        /**
         * Registers an event handler for the given event.
         * @param {String} name The name of the event to subscribe to.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
        subscribe: function (name, handler) {

            if (!this._handlers.hasOwnProperty(name)) {
                this._handlers[name] = [];
            }


            this._handlers[name].push(handler);
        },

        /**
         * Unregisters an event handler for the given event.
         * @param {String} name The name of the event to unsubscribe from.
         * @param {Function} handler The event handler to remove.
         * @returns {void}
         */
        unsubscribe: function (name, handler) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name];

            if (handlers) {
                for (len = handlers.length; i < len; i += 1) {
                    if (handlers[i] === handler) {
                        handlers.splice(i, 1);
                        return;
                    }
                }
            }
        }

    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines ModuleContext, which is used by all modules.
 * @exports TLT.ModuleContext
 */

/*global TLT*/
/*jshint loopfunc:true*/

/**
 * A layer that abstracts core functionality for each modules. Modules interact
 * with a ModuleContext object to ensure that they're not doing anything
 * they're not allowed to do.
 * @class
 * @param {String} moduleName The name of the module that will use this context.
 * @param {TLT} core The core object. This must be passed in to enable easier
 *        testing.
 */
TLT.ModuleContext = (function () {

    "use strict";

    /**
     * Methods to be exposed from the Core to ModuleContext. ModuleContext
     * simply passes through these methods to the Core. By listing the
     * methods here, the ModuleContext object can be dynamically created
     * to keep the code as small as possible. You can easily add new methods
     * to ModuleContext by adding them to this array. Just make sure the
     * method also exists on TLT and that the first argument for the method
     * on TLT is always the module name.
     *
     * If the method name on ModuleContext is different than on TLT, you can
     * specify that via "contextMethodName:coreMethodName", where contextMethodName
     * is the name of the method on ModuleContext and coreMethodName is
     * the name of the method on TLT.
     *
     * Because the methods aren't actually defined in the traditional sense,
     * the documentation comments are included within the array for proper
     * context.
     * @private
     * @type String[]
     */
    var methodsToExpose = [

        /**
         * Broadcasts a message to the entire system.
         * @name broadcast
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to send.
         * @param {Variant} data The data to send along with the message.
         * @returns {void}
         */
        "broadcast",

        /**
         * Returns the configuration object for the module.
         * @name getConfig
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {Object} The configuration object for the module.
         */
        "getConfig:getModuleConfig",

        /**
         * Tells the system that the module wants to know when a particular
         * message occurs.
         * @name listen
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to listen for.
         * @returns {void}
         */
        "listen",


        /**
         * Posts an event to the module's queue.
         * @name post
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {Object} event The event to put into the queue.
         * @param {String} [queueId] The ID of the queue to add the event to.
         * @returns {void}
         */
        "post",

        /**
         * Calculates the xpath of the given DOM Node.
         * @name getXPathFromNode
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {DOMElement} node The DOM node who's xpath is to be calculated.
         * @returns {String} The calculated xpath.
         */
        "getXPathFromNode",

        /* Log a DOM Capture message to the default queue.
         * @name performDOMCapture
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} moduleName Name of the module which invoked this function.
         * @param {DOMElement} [root] Parent element from which to start the capture.
         * @param {Object} [config] DOM Capture configuration options.
         * @returns {String} The unique string representing the DOM Capture id.
         * null if DOM Capture failed.
         */
        "performDOMCapture",

        /**
         * @name getStartTime
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
         */
        "getStartTime"
    ];

    /**
     * Creates a new ModuleContext object. This function ends up at TLT.ModuleContext.
     * @private
     * @param {String} moduleName The name of the module that will use this context.
     * @param {TLT} core The core object. This must be passed in to enable easier
     *        testing.
     */
    return function (moduleName, core) {

        // If you want to add methods that aren't directly mapped from TLT, do it here
        var context = {},
            i = 0,
            len = methodsToExpose.length,
            parts = null,
            coreMethod = null,
            contextMethod = null;

        // Copy over all methods onto the context object
        for (i = 0; i < len; i += 1) {

            // Check to see if the method names are the same or not
            parts = methodsToExpose[i].split(":");
            if (parts.length > 1) {
                contextMethod = parts[0];
                coreMethod = parts[1];
            } else {
                contextMethod = parts[0];
                coreMethod = parts[0];
            }

            context[contextMethod] = (function (coreMethod) {

                return function () {

                    // Gather arguments and put moduleName as the first one
                    var args = core.utils.convertToArray(arguments);
                    args.unshift(moduleName);


                    // Pass through to the Core
                    return core[coreMethod].apply(core, args);
                };

            }(coreMethod));
        }

        context.utils = core.utils;

        return context;
    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The ConfigService is responsible for managing global configuration settings.
 * This may include receiving dynamic configuration updates from the server at regular intervals.
 * The ConfigService fires a configupdated event when it receives updated configuration information.
 * @exports configService
 */

/*global TLT:true */

/**
 * @name configService
 * @namespace
 */
TLT.addService("config", function (core) {
    "use strict";

    /**
     * Merges a new configuration object/diff into the existing configuration by doing a deep copy.
     * @name configService-mergeConfig
     * @function
     * @private
     * @param  {Object} oldConf Existing configuration object.
     * @param  {Object} newConf New configuration object.
     */
    function mergeConfig(oldConf, newConf) {
        core.utils.extend(true, oldConf, newConf);
        configService.publish("configupdated", configService.getConfig());
    }



    /**
     * Holds the config for core and all services and modules.
     * @private
     * @name configService-config
     * @type {Object}
     */
    var config = {
            core: {},
            modules: {},
            services: {}
        },
        configService = core.utils.extend(false, core.utils.createObject(new TLT.EventTarget()), {
            /**
             * Returns the global configuration object.
             * @return {Object} The global configuration object.
             */
            getConfig: function () {
                return config;
            },
            /**
             * Assigns the global configuration for the system.
             * This is first called when Core.init() is called and also may be called later if new
             * configuration settings are returned from the server. After initial configuration is set,
             * all further calls are assumed to be diffs of settings that should be changed rather than
             * an entirely new configuration object.
             * @param  {Object} newConf The global configuration object.
             */
            updateConfig: function (newConf) {
                mergeConfig(config, newConf);
            },
            /**
             * Returns the configuration object for the core.
             * @return {Object} The core configuration object.
             */
            getCoreConfig: function () {
                return config.core;
            },
            /**
             * Assigns the configuration for the core. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {Object} newConf     A partial or complete core configuration object.
             */
            updateCoreConfig: function (newConf) {
                mergeConfig(config.core, newConf);
            },
            /**
             * Returns the configuration object for a given service.
             * @param {String} serviceName The name of the service to retrieve configuration information for.
             * @return {Object|null} The service configuration object or null if the named service doesn't exist.
             */
            getServiceConfig: function (serviceName) {
                // XXX - Return empty object {} instead of null and correct all places where this is being called.
                return config.services[serviceName] || null;
            },
            /**
             * Assigns the configuration for the named service. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} serviceName The name of the service to update configuration information for.
             * @param  {Object} newConf     A partial or complete service configuration object.
             */
            updateServiceConfig: function (serviceName, newConf) {
                if (typeof config.services[serviceName] === "undefined") {
                    config.services[serviceName] = {};
                }
                mergeConfig(config.services[serviceName], newConf);
            },
            /**
             * Returns the configuration object for a given module.
             * @param {String} moduleName The name of the module to retrieve configuration information for.
             * @return {Object|null} The module configuration object or null if the named module doesn't exist.
             */
            getModuleConfig: function (moduleName) {
                return config.modules[moduleName] || null;
            },
            /**
             * Assigns the configuration for the named module. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} moduleName The name of the module to update configuration information for.
             * @param  {Object} newConf     A partial or complete module configuration object.
             */
            updateModuleConfig: function (moduleName, newConf) {
                if (typeof config.modules[moduleName] === "undefined") {
                    config.modules[moduleName] = {};
                }
                mergeConfig(config.modules[moduleName], newConf);
            },
            destroy: function () {
                config = {
                    core: {},
                    modules: {},
                    services: {}
                };
            }
        });

    return configService;

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The QueueService manages all queues in the system.
 * @exports queueService
 */

/*global TLT:true */

/**
 * @name queueService
 * @namespace
 */
TLT.addService("queue", function (core) {
    "use strict";

    /**
     * queueMananger
     * @private
     * @static
     * @name queueService-queueManager
     * @namespace
     */
    var CONFIG       = null,    // queue configuration
        // TODO: replace these with long form names i.e. aS -> ajaxService
        aS           = core.getService("ajax"),          // ajaxService
        bS           = core.getService("browser"),       // browserService
        eS           = core.getService("encoder"),       // encoderService
        sS           = core.getService("serializer"),    // serializerService
        cS           = core.getService("config"),        // configService
        mS           = core.getService("message"),       // messageService
        defaultQueue = null,    // config object for default queue
        queueTimers  = {},      // timer id for the queueTick
        autoFlushing = true,    // Bool, indicates whether to flush queues when
                                // threshold is reached or let the application control flushing.
        isInitialized = false,
        queueManager = (function () {
            var queues = {};

            /**
             * Checks if the specified queue exists.
             * @function
             * @name queueService-queueManager.exists
             * @param  {String} queueId The id of the queue to check for existence.
             * @return {Boolean}         Returns true if the queue exists, otherwise false.
             */
            function queueExists(queueId) {
                return typeof queues[queueId] !== "undefined";
            }

            /**
             * Adds a queue to the system.
             * @function
             * @name queueService-queueManager.add
             * @param {String} queueId The id of the queue to add.
             * @param {Object} opts    Some additional configuration options for this queue.
             * @param {String} opts.url  The endpoint URL to which the queue should be flushed.
             * @param {Number} opts.threshold The maximal amount of messages to store
             * in the queue before it gets flushed.
             * @param {String} opts.serialzer The serializer which should be used to serialize
             * the data in the queue when sending it to the server.
             * @return {Object} Returns the newly created queue.
             */
            function addQueue(queueId, opts) {
                if (!queueExists(queueId)) {
                    /* TODO: Add prototype functions to access queue members */
                    queues[queueId] = {
                        data: [],
                        queueId: queueId,
                        url: opts.url,
                        threshold: opts.threshold,
                        serializer: opts.serializer,
                        encoder: opts.encoder,
                        crossDomainEnabled: !!opts.crossDomainEnabled,
                        crossDomainIFrame: opts.crossDomainIFrame
                    };
                }
                return queues[queueId];
            }

            /**
             * Removes a queue from the system.
             * @function
             * @name queueService-queueManager.remove
             * @param  {String} queueId The id of the queue which should be deleted.
             */
            function removeQueue(queueId) {
                if (queueExists(queueId)) {
                    delete queues[queueId];
                }
            }

            /**
             * Returns the queue object associated with the given queueId.
             * @function
             * @name queueService-queueManager.get
             * @param  {String} queueId The id of the queue to return.
             * @return {Object}         Returns the queue object for the given id.
             */
            function getQueue(queueId) {
                if (queueExists(queueId)) {
                    return queues[queueId];
                }
                return null;
            }

            /**
             * Clears all items in the queue specified by the queue id.
             * @function
             * @name queueService-queueManager.clear
             * @param  {String} queueId The id of the queue which should be cleared.
             */
            function clearQueue(queueId) {
                var queue = getQueue(queueId);
                if (queue !== null) {
                    queue.data = [];
                }
            }

            /**
             * Returns the queue data and clears the queue.
             * @function
             * @name queueService-queueManager.flush
             * @param  {String} queueId The id of the queue to be flushed.
             * @return {Array}         Returns all items which were stored in the queue.
             */
            function flushQueue(queueId) {
                var data = null;
                if (queueExists(queueId)) {
                    data = getQueue(queueId).data;
                    clearQueue(queueId);
                }
                return data;
            }

            /**
             * Adds an item to a specific queue.
             * @function
             * @name queueService-queueManager.push
             * @param  {String} queueId The id of the queue to which the item should be added.
             * @param  {Object} data    The message object which should be stored in the queue.
             * @return {Number}         Returns the current length of the queue.
             */
            function pushToQueue(queueId, data) {
                var queue = null,
                    jsonStr = null,
                    bridgeAndroid = window.tlBridge,
                    bridgeiOS = window.iOSJSONShuttle;

                // Send to Native Android Bridge
                if ((typeof bridgeAndroid !== "undefined") &&
                        (typeof bridgeAndroid.addMessage === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeAndroid.addMessage(jsonStr);
                // Send to Native iOS Bridge
                } else if ((typeof bridgeiOS !== "undefined") &&
                        (typeof bridgeiOS === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeiOS(jsonStr);
                // Send to normal library queue
                } else {
                    if (queueExists(queueId)) {
                        queue = getQueue(queueId);
                        queue.data.push(data);
                        /* Redirect the queue so any registered callback function
                         * can optionally modify it.
                         */
                        queue.data = core.redirectQueue(queue.data);
                        return queue.data.length;
                    }
                }
                return 0;
            }

            /**
             * @scope queueManager
             */
            return {
                exists: queueExists,
                add: addQueue,
                remove: removeQueue,
                get: getQueue,
                clear: clearQueue,
                flush: flushQueue,
                push: pushToQueue
            };

        }());


    /**
     * Handles the xhr response of the server call.
     * @function
     * @private
     * @name queueService-handleXhrCallback
     */
    function handleXhrCallback() {
        // TODO
    }

    /**
    * Get the path relative to the host.
    * @addon
    */
    function getUrlPath() {
        return window.location.pathname;
    }

    /**
     * Adds a HTTP header (name,value) pair to the specified queue.
     * @function
     * @private
     * @name queueService-addHeaderToQueue
     * @param  {String} queueId The id of the queue which should be flushed.
     * @param  {String} headerName The name of the header to be added.
     * @param  {String} headerValue The value of the header to be added.
     * @param  {Boolean} [recurring] Flag specifying if header should be sent
     *                   once (false) or always (true). Default behavior is to
     *                   send the header once.
     */
    function addHeaderToQueue(queueId, headerName, headerValue, recurring) {
        var queue = queueManager.get(queueId),
            header = {
                name: headerName,
                value: headerValue
            },
            qHeadersList = null;

        // Sanity check
        if (typeof headerName !== "string" || typeof headerValue !== "string") {
            return;
        }

        if (!queue.headers) {
            // TODO: Add prototype functions to help add/copy/remove headers
            queue.headers = {
                once: [],
                always: []
            };
        }

        qHeadersList = !!recurring ? queue.headers.always : queue.headers.once;
        qHeadersList.push(header);
    }

    /**
     * Copies HTTP headers {name,value} from the specified queue to an
     * object.
     * @function
     * @private
     * @name queueService-copyHeaders
     * @param  {String} queueId The id of the queue whose headers are copied.
     * @param  {Object} [headerObj] The object to which headers are added. If no
     * object is specified then a new one is created.
     * @return {Object} The object containing the copied headers.
     */
    function copyHeaders(queueId, headerObj) {
        var i = 0,
            len = 0,
            queue = queueManager.get(queueId),
            qHeaders = queue.headers,
            headersList = null;

        headerObj = headerObj || {};

        function copy(l, o) {
            var i = 0,
                len = 0,
                header = null;

            for (i = 0, len = l.length; i < len; i += 1) {
                header = l[i];
                o[header.name] = header.value;
            }
        }

        if (qHeaders) {
            headersList = [qHeaders.always, qHeaders.once];

            for (i = 0, len = headersList.length; i < len; i += 1) {
                copy(headersList[i], headerObj);
            }
        }

        return headerObj;
    }

    /**
     * Clear HTTP headers {name,value} from the specified queue. Only headers
     * that are to be sent once are cleared.
     * @function
     * @private
     * @name queueService-clearHeaders
     * @param  {String} queueId The id of the queue whose headers are cleared.
     */
    function clearHeaders(queueId) {
        var queue = null,
            qHeaders = null;

        if (!queueManager.exists(queueId)) {
            throw new Error("Queue: " + queueId + " does not exist!");
        }

        queue = queueManager.get(queueId);
        qHeaders = queue ? queue.headers : null;
        if (qHeaders) {
            // Only reset headers that are sent once.
            qHeaders.once = [];
        }
    }

    /**
     * Invoke the core function to get any HTTP request headers from
     * external scripts and add these headers to the default queue.
     * @function
     * @private
     * @returns The number of external headers added to the queue.
     */
    function getExternalRequestHeaders() {
        var i = 0,
            len,
            header,
            headers = core.provideRequestHeaders();

        if (headers && headers.length) {
            for (i = 0, len = headers.length; i < len; i += 1) {
                header = headers[i];
                addHeaderToQueue("DEFAULT", header.name, header.value, header.recurring);
            }
        }
        return i;
    }

    /**
     * Clears a specific queue and sends its serialized content to the server.
     * @function
     * @private
     * @name queueService-flushQueue
     * @param  {String} queueId The id of the queue to be flushed.
     */
    function flushQueue(queueId, sync) {
        var data = queueManager.flush(queueId),
            count = data !== null ? data.length : 0,
            queue = queueManager.get(queueId),
            httpHeaders = {
                "Content-Type": "application/json",
                "X-Tealeaf": "device (UIC) Lib/4.0.0.1607",
                "X-TealeafType": "GUI",  // For our past sins
                "X-TeaLeaf-Page-Url": getUrlPath()
            },
            serializer = queue.serializer || "json",
            contentEncoder = queue.encoder,
            requestData,
            retObj,
            xdomainFrameWindow = null;

        if (!count) {
            return;
        }

        // Wrap the messages with the header
        data = mS.wrapMessages(data);

        // Serialize the data
        if (serializer) {
            data = sS.serialize(data, serializer);
        }

        // Encode if specified
        if (contentEncoder) {
            retObj = eS.encode(data, contentEncoder);
            if (retObj && retObj.data && !retObj.error) {
                data = retObj.data;
                httpHeaders["Content-Encoding"] = retObj.encoding;
            }
        }

        getExternalRequestHeaders();
        copyHeaders(queueId, httpHeaders);

        if (queue.crossDomainEnabled) {
            xdomainFrameWindow = core.utils.getIFrameWindow(queue.crossDomainIFrame);
            if (!xdomainFrameWindow) {
                return;
            }
            requestData = {
                request: {
                    url: queue.url,
                    async: !sync,
                    headers: httpHeaders,
                    data: data
                }
            };

            if (!core.utils.isIE && typeof window.postMessage === "function") {
                xdomainFrameWindow.postMessage(requestData, queue.crossDomainIFrame.src);
            } else {
                try {
                    xdomainFrameWindow.sendMessage(requestData);
                } catch (e) {
                    return;
                }
            }
        } else {
            aS.sendRequest({
                oncomplete: handleXhrCallback,
                url: queue.url,
                async: !sync,
                headers: httpHeaders,
                data: data
            });
        }
        clearHeaders(queueId);
    }

    /**
     * Iterates over all queues and sends their contents to the servers.
     * @function
     * @private
     * @name queueServive-flushAll
     */
    function flushAll(sync) {
        var conf = null,
            queues = CONFIG.queues,
            i = 0;
        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            flushQueue(conf.qid, sync);
        }
        return true;
    }


    /**
     * Adds a message event to the specified queue.
     * If the queue threshold is reached the queue gets flushed.
     * @function
     * @private
     * @name queueService-addToQueue
     * @param {String} queueId The id of the queue which should be flushed.
     * @param {Object} data    The message event which should be stored in the queue.
     */
    function addToQueue(queueId, data) {
        var length = queueManager.push(queueId, mS.createMessage(data));
        if (length >= queueManager.get(queueId).threshold &&
                autoFlushing && core.getState() !== "unloading") {
            flushQueue(queueId);
        }
    }

    /**
     * Returns the queue id for the queue which is responsible for the given module.
     * @function
     * @private
     * @name queueService-getQueueId
     * @param  {String} moduleName The name of the module for which the id should get looked up.
     * @return {String}            Returns the queue id for the corresponding queue or the default queue id.
     */
    function getQueueId(moduleName) {
        var conf = null,
            queues = CONFIG.queues,
            module = "",
            i = 0,
            j = 0;

        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            if (conf && conf.modules) {
                for (j = 0; j < conf.modules.length; j += 1) {
                    module = conf.modules[j];
                    if (module === moduleName) {
                        return conf.qid;
                    }
                }
            }
        }
        return defaultQueue.qid;
    }


    function setTimer(qid, interval) {
        queueTimers[qid] = window.setTimeout(function tick() {
            flushQueue(qid);
            queueTimers[qid] = window.setTimeout(tick, interval);
        }, interval);
    }


    function clearTimers() {
        var key = 0;

        for (key in queueTimers) {
            if (queueTimers.hasOwnProperty(key)) {
                window.clearTimeout(queueTimers[key]);
                delete queueTimers[key];
            }
        }

        queueTimers = {};
    }


    /**
     * Handles the configupdated event from the configService and reinitialize all queues.
     * @function
     * @private
     * @name queueService-handleConfigUpdated
     * @param  {Object} newConf The new configuration object diff.
     */
    function handleConfigUpdated(newConf) {
        // TODO: merge config
    }



    /**
     * Sets up all the needed queues and event handlers and start the queueTick.
     * @function
     * @private
     * @param  {Object} config The queueService configuration object.
     */
    function initQueueService(config) {
        CONFIG = config;

        core.utils.forEach(CONFIG.queues, function (conf, i) {
            var crossDomainIFrame = null;
            if (conf.qid === "DEFAULT") {
                defaultQueue = conf;
            }
            if (conf.crossDomainEnabled) {
                crossDomainIFrame = bS.query(conf.crossDomainFrameSelector);
                if (!crossDomainIFrame) {
                    core.fail("Cross domain iframe not found");
                }
            }

            queueManager.add(conf.qid, {
                url: conf.endpoint,
                threshold: conf.maxEvents,
                serializer: conf.serializer,
                encoder: conf.encoder,
                timerInterval: conf.timerInterval || 0,
                crossDomainEnabled: conf.crossDomainEnabled || false,
                crossDomainIFrame: crossDomainIFrame
            });

            if (typeof conf.timerInterval !== "undefined" && conf.timerInterval > 0) {
                setTimer(conf.qid, conf.timerInterval);
            }
        });

        cS.subscribe("configupdated", handleConfigUpdated);

        isInitialized = true;
    }

    function destroy() {
        if (autoFlushing) {
            flushAll(!CONFIG.asyncReqOnUnload);
        }
        cS.unsubscribe("configupdated", handleConfigUpdated);

        clearTimers();

        CONFIG = null;
        defaultQueue = null;
        isInitialized = false;
    }

    /**
     * @scope queueService
     */
    return {
        init: function () {
            if (!isInitialized) {
                initQueueService(cS.getServiceConfig("queue") || {});
            } else {
            }
        },

        /**
         * Get's called when the core shut's down.
         * Clean up everything.
         */
        destroy: function () {
            destroy();
        },

        // TODO: Need to expose for selenium functional tests
        _getQueue: function (qid) { return queueManager.get(qid).data; },


        /**
         * Enables/disables automatic flushing of queues so that the application
         * could decide on their own when to flush by calling flushAll.
         * @param {Boolean} flag Could be either true or false to enable or disable
         *                  auto flushing respectively.
         */
        setAutoFlush: function (flag) {
            if (flag === true) {
                autoFlushing = true;
            } else {
                autoFlushing = false;
            }
        },

        /**
         * Forces a particular queue to be flushed, sending its information to the server.
         * @param  {String} queueId The ID of the queue to be flushed.
         */
        flush: function (queueId) {
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            flushQueue(queueId);
        },

        /**
         * Forces all queues to be flushed, sending all queue information to the server.
         */
        flushAll: function (sync) {
            return flushAll(!!sync);
        },

        /**
         * Send event information to the module's default queue.
         * This doesn't necessarily force the event data to be sent to the server,
         * as this behavior is defined by the queue itself.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {Object} queueEvent The event information to be saved to the queue.
         * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
         */
        post: function (moduleName, queueEvent, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addToQueue(queueId, queueEvent);
        }
    };

});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document, ActiveXObject */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browserBase", function (core) {
    "use strict";

    var nonClickableTags = {
            OPTGROUP: true,
            OPTION: true,
            NOBR: true
        },
        queryDom = {},
        configService = core.getService("config"),
        serializerService = null,
        config,
        blacklist,
        customid,
        getXPathFromNode,
        isInitialized = false;

    function updateConfig() {
        configService = core.getService("config");
        serializerService = core.getService("serializer");
        config = core.getService("config").getServiceConfig("browser") || {};
        blacklist = config.hasOwnProperty("blacklist") ? config.blacklist : [];
        customid = config.hasOwnProperty("customid") ? config.customid : [];
    }

    function initBrowserBase() {
        updateConfig();
        configService.subscribe("configupdated", updateConfig);
        serializerService = core.getService("serializer");

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    function checkId(node) {
        var i,
            len,
            re;

        if (!node || !node.id || typeof node.id !== "string") {
            return false;
        }

        for (i = 0, len = blacklist.length; i < len; i += 1) {
            if (typeof blacklist[i] === "string") {
                if (node.id === blacklist[i]) {
                    return false;
                }
            } else if (typeof blacklist[i] === "object") {
                re = new RegExp(blacklist[i].regex, blacklist[i].flags);
                if (re.test(node.id)) {
                    return false;
                }
            }
        }
        return true;
    }

    function getEventType(event, target) {
        var returnObj = {
                type: null,
                // Event subtype is not used in the UIC
                subType: null
            },
            type;

        // Sanity check
        if (!event) {
            return returnObj;
        }

        // Normalize event type for jQuery events focusin, focusout
        type = event.type;
        switch (type) {
        case "focusin":
            type = "focus";
            break;
        case "focusout":
            type = "blur";
            break;
        default:
            break;
        }
        returnObj.type = type;

        return returnObj;
    }

    /**
     * Examines the type and subType of the target.
     * @function
     * @name browserService-getElementType
     * @param  {Object} element The normalized target element.
     * @return {Object} Returns an object which contains the type and subType of the target element.
     */
    function getElementType(element) {
        var returnObj = {
                type: null,
                subType: null
            };

        // Sanity check
        if (!element) {
            return returnObj;
        }

        returnObj.type = element.tagName;
        returnObj.subType = element.type || null;

        return returnObj;
    }

    /**
     * Returns an element by it's id and idType where id could be either an HTML id,
     *     attribute ID or XPath selector.
     * @param  {String} selector The selector. Either a single HTML ID or an attribute ID
     *                  example: "myid=customid" or a tealeaf XPath string.
     * @param  {Number} type     A number, indicating the type of the query
     *                           as in the object 'idTypes' below.
     *                           -1 for HTML ID, -2 for XPath and -3 for attribute ID.
     * @return {Object}          Returns the node, if found. Otherwise null.
     */
    function getNodeFromID(selector, type, scope) {
        var idTypes = {
                HTML_ID: "-1",
                XPATH_ID: "-2",
                ATTRIBUTE_ID: "-3"
            },
            doc,
            node = null,
            parts;

        // Sanity check
        if (!selector || !type) {
            return node;
        }

        doc = scope || window.document;
        type = type.toString();
        if (type === idTypes.HTML_ID) {
            if (doc.getElementById) {
                node = doc.getElementById(selector);
            } else if (doc.querySelector) {
                node = doc.querySelector("#" + selector);
            }
        } else if (type === idTypes.ATTRIBUTE_ID) {
            parts = selector.split("=");
            if (doc.querySelector) {
                node = doc.querySelector("[" + parts[0] + "=\"" + parts[1] + "\"]");
            }
        } else if (type === idTypes.XPATH_ID) {
            node = queryDom.xpath(selector, doc);
        }
        return node;
    }

    /**
     * Generates an XPath for a given node
     * @function
     */
    getXPathFromNode = (function () {

        var specialChildNodes = {
                "NOBR": true,
                "P": true
            };

        /**
         * Returns Xpath string for a node
         * @private
         * @param {Element} node DOM element
         * @return {string} xpath string
         */
        function getXPathArrayFromNode(node) {
            var i,
                j,
                idValid = false,
                tmp_child = null,
                parent_window = null,
                parent_node = null,
                xpath = [],
                loop = true,
                localTop = core._getLocalTop();

            while (loop) {
                loop = false;

                if (!core.utils.isUndefOrNull(node)) {
                    if (!core.utils.isUndefOrNull(node.tagName)) {
                        // Hack fix to handle tags that are not normally visual elements
                        if (specialChildNodes.hasOwnProperty(node.tagName)) {
                            node = node.parentNode;
                        }
                    }
                    for (idValid = checkId(node);
                            node !== document && !idValid;
                            idValid = checkId(node)) {
                        parent_node = node.parentNode;
                        if (!parent_node) {
                            parent_window = core.utils.getWindow(node);
                            parent_node = (parent_window !== localTop) ? parent_window.frameElement : document;
                        }

                        tmp_child = parent_node.firstChild;
                        if (typeof tmp_child === "undefined") {
                            return xpath;
                        }

                        for (j = 0; tmp_child; tmp_child = tmp_child.nextSibling) {
                            if (tmp_child.nodeType === 1 && tmp_child.tagName === node.tagName) {
                                if (tmp_child === node) {
                                    xpath[xpath.length] = [node.tagName, j];
                                    break;
                                }
                                j += 1;
                            }
                        }
                        node = parent_node;
                    }

                    if (idValid) {
                        xpath[xpath.length] = [node.id];
                        if (core.utils.isIFrameDescendant(node)) {
                            loop = true;
                            node = core.utils.getWindow(node).frameElement;
                        }
                    }
                }
            }

            return xpath;
        }

        // actual getXPathFromNode function
        return function (node) {
            var xpath = getXPathArrayFromNode(node),
                parts = [],
                i = xpath.length;

            if (i < 1) {
                return "null";
            }
            while (i) {
                i -= 1;
                if (xpath[i].length > 1) {
                    parts[parts.length] = '["' + xpath[i][0] + '",' + xpath[i][1] + "]";
                } else {
                    parts[parts.length] = '[' + serializerService.serialize(xpath[i][0], "json") + ']';
                }
            }
            return ("[" + parts.join(",") + "]");
        };
    }());

    /**
     * Returns the scroll position (left, top) of the document
     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX
     * @private
     * @param {DOMObject} doc The document object.
     * @return {Object} An object specifying the document's scroll offset position {left, top}
     */
    function getDocScrollPosition(doc) {
        var scrollPos = {
                left: -1,
                top: -1
            },
            docElement;

        doc = doc || document;
        // Get the scrollLeft, scrollTop from documentElement or body.parentNode or body in that order.
        docElement = doc.documentElement || doc.body.parentNode || doc.body;

        // If window.pageXOffset exists, use it. Otherwise fallback to getting the scrollLeft position.
        scrollPos.left = (typeof window.pageXOffset === "number") ? window.pageXOffset : docElement.scrollLeft;
        scrollPos.top = (typeof window.pageYOffset === "number") ? window.pageYOffset : docElement.scrollTop;

        return scrollPos;
    }

    /**
     * Returns true if an event is a jQuery event wrpper object.
     * @private
     * @param {UIEvent} event Browser event to examine
     * @return {boolean} true if given event is jQuery event
     */
    function isJQueryEvent(event) {
        return event && typeof event.originalEvent !== "undefined" &&
            typeof event.isDefaultPrevented !== "undefined"  &&
            !event.isSimulated;
    }


    /**
     * Looks for event details. Usually it returns an event itself, but for touch events
     * function returns an element from one of the touch arrays.
     * @private
     * @param {UIEvent} event Browser event. If skipped function will look for window.event
     * @return {UIEvent} latest touch details for touch event or original event object
     *          for all other cases
     */
    function getEventDetails(event) {
        if (!event) {
            return null;
        }
        if (event.type && event.type.indexOf("touch") === 0) {
            if (isJQueryEvent(event)) {
                event = event.originalEvent;
            }
            if (event.type === "touchstart") {
                event = event.touches[event.touches.length - 1];
            } else if (event.type === "touchend") {
                event = event.changedTouches[0];
            }
        }
        return event;
    }


    /**
     * Normalizes the event object for InternetExplorer older than 9.
     * @return {HttpEvent} normalized event object
     */
    function normalizeEvent(event) {
        var e = event || window.event,
            doc = document.documentElement,
            body = document.body,
            found = false,
            foundElement = null,
            i = 0;

        // skip jQuery event wrapper
        if (isJQueryEvent(e)) {
            e = e.originalEvent;
        }

        // IE case
        if (typeof event === 'undefined' || typeof e.target === 'undefined') {
            e.target = e.srcElement || window.window;
            e.timeStamp = Number(new Date());
            if (e.pageX === null || typeof e.pageX === "undefined") {
                e.pageX = e.clientX + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
                    ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
                e.pageY = e.clientY + ((doc && doc.scrollTop)  || (body && body.scrollTop)  || 0) -
                    ((doc && doc.clientTop)  || (body && body.clientTop)  || 0);
            }
            e.preventDefault = function () {
                this.returnValue = false;
            };
            e.stopPropagation = function () {
                this.cancelBubble = true;
            };
        }

        // Chrome case getting blur for inner elements sending click
        if (window.chrome && e.path !== undefined && e.type === "click") {
            if (e.path.length === undefined) {
                return e;
            }

            for (i = 0; i < e.path.length; i++) {
                if (e.path[i].tagName === "BUTTON") {
                    found = true;
                    foundElement = e.path[i];
                    i = e.path.length;
                }
            }
            if (found) {
                return {
                    originalEvent: e,
                    target: foundElement,
                    srcElement: foundElement,
                    type: e.type,
                    pageX: document.body.scrollLeft + foundElement.getBoundingClientRect().left,
                    pageY: document.body.scrollTop + foundElement.getBoundingClientRect().top
                };
            }
        }

        return e;
    }

    /**
     * Normalizes target element. In case of touch event the target is considered to be an
     * element for whch the last action took place
     * @private
     * @param {UIEvent} event browser event
     * @return {Element} DOM element
     */
    function normalizeTarget(event) {
        var itemSource = null;

        if (!event) {
            return null;
        }

        if (event.srcElement) {
            // IE
            itemSource = event.srcElement;
        } else {
            // W3C
            itemSource = event.target;
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.explicitOriginalTarget;
            }
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.originalTarget;
            }
        }

        if (!itemSource && event.type.indexOf("touch") === 0) {
            itemSource = getEventDetails(event).target;
        }

        while (itemSource && nonClickableTags[itemSource.tagName]) {
            itemSource = itemSource.parentNode;
        }

        // IE when srcElement pointing to window
        if (!itemSource && event.srcElement === null) {
            itemSource = window.window;
        }

        return itemSource;
    }


    /**
     * Returns event position independently to the event type.
     * In case of touch event the position of last action will be returned.
     * @private
     * @param {UIEvent} event Browser event
     * @return {Object} object containing x and y properties
     */
    function getEventPosition(event) {
        var posX = 0,
            posY = 0,
            doc = document.documentElement,
            body = document.body;

        event = getEventDetails(event);

        if (event) {
            if (event.pageX || event.pageY) {
                posX = event.pageX;
                posY = event.pageY;
            } else if (event.clientX || event.clientY) {
                posX = event.clientX + (doc ? doc.scrollLeft : (body ? body.scrollLeft : 0)) -
                                       (doc ? doc.clientLeft : (body ? body.clientLeft : 0));
                posY = event.clientY + (doc ? doc.scrollTop : (body ? body.scrollTop : 0)) -
                                       (doc ? doc.clientTop : (body ? body.clientTop : 0));
            }
        }

        return {
            x: posX,
            y: posY
        };
    }

    /**
     * Find one or more elements using a XPath selector.
     * @function
     * @name browserService-queryDom.xpath
     * @param  {String} query The XPath query to search for.
     * @param  {Object} [scope="document"] The DOM subtree to run the query in.
     * @return {Object}       Returns the DOM element matching the XPath.
     */
    queryDom.xpath = function (query, scope) {
        var xpath = null,
            elem,
            pathElem = null,
            i,
            j,
            k,
            len,
            jlen;

        // Sanity check
        if (!query) {
            return null;
        }

        xpath = serializerService.parse(query);
        scope = scope || document;
        elem = scope;

        if (!xpath) {
            return null;
        }

        for (i = 0, len = xpath.length; i < len && elem; i += 1) {
            pathElem = xpath[i];
            if (pathElem.length === 1) {
                if (scope.getElementById) {
                    elem = scope.getElementById(pathElem[0]);
                } else if (scope.querySelector) {
                    elem = scope.querySelector("#" + pathElem[0]);
                } else {
                    elem = null;
                }
            } else {
                for (j = 0, k = -1, jlen = elem.childNodes.length; j < jlen; j += 1) {
                    if (elem.childNodes[j].nodeType === 1 && elem.childNodes[j].tagName.toUpperCase() === pathElem[0]) {
                        k += 1;
                        if (k === pathElem[1]) {
                            elem = elem.childNodes[j];
                            break;
                        }
                    }
                }
                if (k === -1) {
                    return null;
                }
            }
        }

        return (elem === scope || !elem) ? null : elem;
    };


    /**
     * The Point interface represents a point on the page to
     *     x- and y-coordinates.
     * @constructor
     * @private
     * @name browserService-Point
     * @param {Integer} x The x-coordinate of the point.
     * @param {Integer} y The y-coordinate of the point.
     */
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }


    /**
     * The Size  interface represents the width and height of an element
     *     on the page.
     * @constructor
     * @private
     * @name browserService-Size
     * @param {Integer} width  Width of the element that received the event.
     * @param {Integer} height Height of the element that received the event.
     */
    function Size(width, height) {
        this.width = width || 0;
        this.height = height || 0;
    }


    /**
     * The ElementData interface represents a normalized browser event object.
     * @constructor
     * @private
     * @name browserService-ElementData
     * @param {Object} event  The browser event.
     * @param {Object} target The HTML element which received the event.
     */
    function ElementData(event, target) {
        var id,
            elementType,
            pos;

        target = normalizeTarget(event);
        id = this.examineID(target);
        elementType = getElementType(target);
        pos = this.examinePosition(event, target);

        this.element = target;
        this.id = id.id;
        this.idType = id.type;
        this.type = elementType.type;
        this.subType = elementType.subType;
        this.state = this.examineState(target);
        this.position = new Point(pos.x, pos.y);
        this.size = new Size(pos.width, pos.height);
        this.xPath = id.xPath;
        this.name = id.name;
    }

    /**#@+
     * @constant
     * @enum {Number}
     * @fieldOf browserService-ElementData
     */
    ElementData.HTML_ID = -1;
    ElementData.XPATH_ID = -2;
    ElementData.ATTRIBUTE_ID = -3;
    /**#@-*/

    /**
     * Examines how to specify the target element
     *     (either by css selectors or xpath)
     *     and returns an object with the properties id and type.
     * @function
     * @name browserService-ElementData.examineID
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object with the properties id and type.
     *      id contains either a css or xpath selector.
     *      type contains a reference to either ElementData.HTML_ID,
     *      ElementData.XPATH_ID or ElementData.ATTRIBUTE_ID
     * @todo determine the element css/xpath/attribute selector.
     */
    ElementData.prototype.examineID = function (target) {
        var id,
            type,
            xPath,
            attribute_id,
            name,
            i = customid.length,
            attrib;

        try {
            xPath = getXPathFromNode(target);
        } catch (e) { }
        name = target.name;

        try {
            if (!core.utils.isIFrameDescendant(target)) {

                if (checkId(target)) {
                    id = target.id;
                    type = ElementData.HTML_ID;
                } else if (customid.length && target.attributes) {
                    while (i) {
                        i -= 1;
                        attrib = target.attributes[customid[i]];
                        if (typeof attrib !== "undefined") {
                            id = customid[i] + "=" + (attrib.value || attrib);
                            type = ElementData.ATTRIBUTE_ID;
                        }
                    }
                }
            }
        } catch (e2) { }

        if (!id) {
            id = xPath;
            type = ElementData.XPATH_ID;
        }

        return {
            id: id,
            type: type,
            xPath: xPath,
            name: name
        };
    };


    /**
     * Examines the current state of the HTML element if it's an input/ui element.
     * @function
     * @name browserService-ElementData.examineState
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object which contains all properties
     *     to describe the state.
     * @todo determine the current state.
     */
    ElementData.prototype.examineState = function (target) {
        var tagnames = {
                "a": ["innerText", "href"],
                "input": {
                    "range": ["maxValue:max", "value"],
                    "checkbox": ["value", "checked"],
                    "radio": ["value", "checked"],
                    "image": ["src"]
                },
                "select": ["value"],
                "button": ["value", "innerText"],
                "textarea": ["value"]
            },
            tagName = typeof target.tagName !== "undefined" ? target.tagName.toLowerCase() : "",
            properties = tagnames[tagName] || null,
            selectedOption = null,
            values = null,
            i = 0,
            len = 0,
            alias = null,
            key = "";

        if (properties !== null) {
            // For input elements, another level of indirection is required
            if (Object.prototype.toString.call(properties) === "[object Object]") {
                // default state for input elements is represented by the "value" property
                properties = properties[target.type] || ["value"];
            }
            values = {};
            for (key in properties) {
                if (properties.hasOwnProperty(key)) {
                    if (properties[key].indexOf(":") !== -1) {
                        alias = properties[key].split(":");
                        values[alias[0]] = target[alias[1]];
                    } else if (properties[key] === "innerText") {
                        values[properties[key]] = core.utils.trim(target.innerText || target.textContent);
                    } else {
                        values[properties[key]] = target[properties[key]];
                    }
                }
            }
        }

        // Special processing for select lists
        if (tagName === "select" && target.options && !isNaN(target.selectedIndex)) {
            values.index = target.selectedIndex;
            if (values.index >= 0 && values.index < target.options.length) {
                selectedOption = target.options[target.selectedIndex];
                /* Select list value is derived from the selected option's properties
                 * in the following order:
                 * 1. value
                 * 2. label
                 * 3. text
                 * 4. innerText
                 */
                values.value = selectedOption.getAttribute("value") || selectedOption.getAttribute("label") || selectedOption.text || selectedOption.innerText;
                values.text = selectedOption.text || selectedOption.innerText;
            }
        }

        return values;
    };


    /**
     * Gets the current zoom value of the browser with 1 being equivalent to 100%.
     * @function
     * @name getZoomValue
     * @return {int}        Returns zoom value of the browser.
     */
    function getZoomValue() {
        var factor = 1,
            rect,
            physicalW,
            logicalW;

        if (document.body.getBoundingClientRect) {
            // rect is only in physical pixel size in IE before version 8
            // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
            // on IE 9
            try {
                rect = document.body.getBoundingClientRect();
            } catch (e) {
                core.utils.clog("getBoundingClientRect failed.", e);
                return factor;
            }
            physicalW = rect.right - rect.left;
            logicalW = document.body.offsetWidth;

            // the zoom level is always an integer percent value
            factor = Math.round((physicalW / logicalW) * 100) / 100;
        }
        return factor;
    }

    /**
     * Gets BoundingClientRect value from a HTML element.
     * @function
     * @name getBoundingClientRectNormalized
     * @param  {Object} element The HTML element.
     * @return {Object} An object with x, y, width, and height.
     */
    function getBoundingClientRectNormalized(element) {
        var rect,
            rectangle,
            zoom,
            scrollPos;

        if (!element || !element.getBoundingClientRect) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
        // on IE 9
        try {
            rect = element.getBoundingClientRect();
            scrollPos = getDocScrollPosition(document);
        } catch (e) {
            core.utils.clog("getBoundingClientRect failed.", e);
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        rectangle = {
            // Normalize viewport-relative left & top with scroll values to get left-x & top-y relative to the document
            x: rect.left + scrollPos.left,
            y: rect.top + scrollPos.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
        if (core.utils.isIE) {
            // IE ONLY: the bounding rectangle include the top and left borders of the client area
            rectangle.x -= document.documentElement.clientLeft;
            rectangle.y -= document.documentElement.clientTop;

            zoom = getZoomValue();
            if (zoom !== 1) {  // IE 7 at non-default zoom level
                rectangle.x = Math.round(rectangle.x / zoom);
                rectangle.y = Math.round(rectangle.y / zoom);
                rectangle.width = Math.round(rectangle.width / zoom);
                rectangle.height = Math.round(rectangle.height / zoom);
            }
        }
        return rectangle;
    }

    /**
     * Examines the position of the event relative to the HTML element which
     * received the event on the page. The top left corner of the element is 0,0
     * and bottom right corner of the element is equal to it's width, height.
     * @function
     * @name browserService-ElementData.examinePosition
     * @param  {Object} target The HTML element which received the event.
     * @return {Point}        Returns a Point object.
     */
    ElementData.prototype.examinePosition = function (event, target) {
        var posOnDoc = getEventPosition(event),
            elPos = getBoundingClientRectNormalized(target);

        elPos.x = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.x - elPos.x)) : elPos.width / 2;
        elPos.y = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.y - elPos.y)) : elPos.height / 2;

        return elPos;
    };


    /**
     * The WebEvent  interface represents a normalized browser event object.
     *     When an event occurs, the BrowserService wraps the native event
     *     object in a WebEvent.
     * @constructor
     * @private
     * @name browserService-WebEvent
     * @param {Object} event The native browser event.
     */
    function WebEvent(event) {
        var pos,
            eventType;

        this.data = event.data || null;
        this.delegateTarget = event.delegateTarget || null;

		//add the gesture event data to the webevent if it exists.
		if (event.gesture || (event.originalEvent && event.originalEvent.gesture)) {
			this.gesture = event.gesture || event.originalEvent.gesture;
		}

        event = normalizeEvent(event);
        pos = getEventPosition(event);
        this.custom = false;    // @TODO: how to determine if it's a custom event?
        this.nativeEvent = this.custom === true ? null : event;
        this.position = new Point(pos.x, pos.y);
        this.target = new ElementData(event, event.target);
        // Do not rely on browser provided event.timeStamp since FF sets
        // incorrect values. Refer to Mozilla Bug 238041
        this.timestamp = (new Date()).getTime();

        eventType = getEventType(event, this.target);
        this.type = eventType.type;
        this.subType = eventType.subType;
    }

    function processDOMEvent(event) {
        core._publishEvent(new WebEvent(event));
    }


    return {
        init: function () {
            if (!isInitialized) {
                initBrowserBase();
            } else {
            }
        },
        destroy: function () {
            destroy();
        },
        WebEvent: WebEvent,
        ElementData: ElementData,
        processDOMEvent: processDOMEvent,

        getXPathFromNode: function (moduleName, node) {
            return getXPathFromNode(node);
        },
        getNodeFromID: getNodeFromID,
        queryDom: queryDom
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document */
/*global console: false */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browser", function (core) {
    "use strict";

    var configService = core.getService("config"),
        browserBaseService = core.getService('browserBase'),
        ajaxService = core.getService('ajax'),
        addEventListener = null,
        removeEventListener = null,
        serviceConfig = configService.getServiceConfig("browser") || {},
        useCapture = (serviceConfig.useCapture === true),
        isInitialized = false,
        errorCodes = {
            NO_QUERY_SELECTOR: "NOQUERYSELECTOR"
        },

        /**
         * Returns a new function which will be used in the subscribe method and which calls the
         * handler function with the normalized WebEvent.
         * @private
         * @function
         * @name browserService-wrapWebEvent
         * @param  {Function} handler The handler which was passed to the browserService's subscribe method.
         * @return {Function}         Returns a new function which, when called, passes a WebEvent to the handler.
         */
        wrapWebEvent = function (handler) {
            return function (event) {
                handler(new browserBaseService.WebEvent(event));
            };
        },

        /**
         * Loads a script by it's URL, appends it to te document and executes
         * it as soon as it's loaded.
         * @private
         * @function
         * @name browserService-loadScript
         * @param  {String} url The URL of the script to load.
         */
        loadScript = function (url) {
            var fjs = document.getElementsByTagName('script')[0],
                js = document.createElement('script');
            js.src = url;
            fjs.parentNode.insertBefore(js, fjs);
        },

        queryDom = {
            /**
             * Helper function to transform a nodelist into an array.
             * @function
             * @name browserService-queryDom.list2Array
             * @param  {List} nodeList Pass in a DOM NodeList
             * @return {Array}          Returns an array.
             */
            list2Array: function (nodeList) {
                var len = nodeList.length,
                    result = [],
                    i;
                if (typeof nodeList.length === "undefined") {
                    return [nodeList];
                }
                for (i = 0; i < len; i += 1) {
                    result[i] = nodeList[i];
                }
                return result;
            },
            /**
             * Finds one or more elements in the DOM using a CSS or XPath selector
             * and returns an array instead of a NodeList.
             * @function
             * @name browserService-queryDom.find
             * @param  {String} query Pass in a CSS or XPath selector query.
             * @param  {Object} [scope="document"]  The DOM subtree to run the query in.
             *      If not provided, document is used.
             * @param  {String} [type="css"]  The type of query. Either "css' (default)
             *      or 'xpath' to allow XPath queries.
             * @return {Array}       Returns an array of nodes that matches the particular query.
             */
            find: function (query, scope, type) {
                type = type || "css";
                return this.list2Array(this[type](query, scope));
            },
            /**
             * Find one or more elements using a CSS selector.
             * @function
             * @name browserService-queryDom.css
             * @param  {String} query The CSS selector query.
             * @param  {Object} [scope="document"] The DOM subtree to run the query in.
             * @return {Array}       Returns an array of nodes that matches the particular query.
             */
            css: function (query, scope) {
                var self = this,
                    message = null,
                    bodyEl = document.getElementsByTagName("body")[0],
                    bConfig = configService.getServiceConfig("browser") || {},
                    sizzleURL = bConfig.sizzleURL || null,
                    jQuery = bConfig.hasOwnProperty("jQueryObject") ? core.utils.access(bConfig.jQueryObject) : window.jQuery,
                    sizzle = bConfig.hasOwnProperty("sizzleObject") ? core.utils.access(bConfig.sizzleObject) : window.Sizzle;

                if (typeof document.querySelectorAll === "undefined") {
                    // redefine self.css to use self.Sizzle as selector engine.
                    self.css = function (query, scope) {
                        scope = scope || document;
                        return self.Sizzle(query, scope);
                    };
                    if (typeof self.Sizzle === "undefined") {
                        // define self.Sizzle function to use either Sizzle library or jQuery.
                        if (sizzleURL) {
                            message = {
                                type: "GET",
                                url: sizzleURL,
                                async: false,
                                oncomplete: function (result) {
                                    // load Sizzle library via xhr and eval it in an AMD context.
                                    function define(definition) {
                                        self.Sizzle = definition();
                                    }
                                    define.amd = true;
                                    eval(result.responseText);
                                }
                            };
                            ajaxService.sendRequest(message);
                        } else {
                            // if sizzleURL is not defined in configuration try
                            // to find jQuery or Sizzle globally.
                            try {
                                if (bodyEl === sizzle("html > body", document)[0]) {
                                    // if Sizzle is defined and behaves as expected, use it as self.Sizzle.
                                    self.Sizzle = sizzle;
                                }
                            } catch (e) {
                                try {
                                    if (bodyEl === jQuery(document).find("html > body").get()[0]) {
                                        // if jQuery is defined on window and behaves correctly define
                                        // self.Sizzle to use jQuery.
                                        self.Sizzle = function (query, scope) {
                                            return jQuery(scope).find(query).get();
                                        };
                                    }
                                } catch (ex) {
                                    core.fail("Sizzle was not found", errorCodes.NO_QUERY_SELECTOR);
                                }
                            }
                        }
                    }
                } else {
                    // otherwise, if document.querySelectorAll is available, use it.
                    self.css = function (query, scope) {
                        scope = scope || document;
                        return scope.querySelectorAll(query);
                    };
                }
                return self.css(query, scope);
            }
        },
        // store handler functions which got passed to subscribe/unsubscribe.
        handlerMappings = (function () {
            var data = new core.utils.WeakMap();

            return {
                add: function (originalHandler) {
                    var handlers = data.get(originalHandler) || [wrapWebEvent(originalHandler), 0];

                    handlers[1] += 1;
                    data.set(originalHandler, handlers);
                    return handlers[0];
                },

                find: function (originalHandler) {
                    var handlers = data.get(originalHandler);
                    return handlers ? handlers[0] : null;
                },

                remove: function (originalHandler) {
                    var handlers = data.get(originalHandler);
                    if (handlers) {
                        handlers[1] -= 1;
                        if (handlers[1] <= 0) {
                            data.remove(originalHandler);
                        }
                    }
                }
            };
        }());

    /**
     * Initialization function
     * @function
     */
    function initBrowserServiceW3C() {
        queryDom.xpath = browserBaseService.queryDom.xpath;

        if (typeof document.addEventListener === 'function') {
            addEventListener = function (target, eventName, handler) {
                target.addEventListener(eventName, handler, useCapture);
            };
            removeEventListener = function (target, eventName, handler) {
                target.removeEventListener(eventName, handler, useCapture);
            };
        } else if (typeof document.attachEvent !== 'undefined') {
            addEventListener = function (target, eventName, handler) {
                target.attachEvent('on' + eventName, handler);
            };
            removeEventListener = function (target, eventName, handler) {
                target.detachEvent('on' + eventName, handler);
            };
        } else {
            throw new Error("Unsupported browser");
        }

        isInitialized = true;
    }


    /**
     * @scope browserService
     */
    return {

        init: function () {
            if (!isInitialized) {
                initBrowserServiceW3C();
            } else {
            }
        },

        destroy: function () {
            isInitialized = false;
        },

        getServiceName: function () {
            return "W3C";
        },

        /**
         * Find a single element in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object|null}       The first matching HTML element or null if not found.
         */
        query: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type)[0] || null;
			} catch (err) {
				return [];
			}
        },

        /**
         * Find all elements in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object[]|Array}       An array of HTML elements matching the query
         *     or and empty array if no elements are matching.
         */
		queryAll: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type);
			} catch (err) {
				return [];
			}
        },

        /**
         * Loads a JavaScript file onto the current page.
         * @param  {String} url The URL of the JavaScript file to load.
         */
        loadScript: function (url) {
            loadScript(url);
        },

        /**
         * Subscribes an event handler to be called when a particular event occurs.
         * @param  {String} eventName The name of the event to listen for.
         * @param  {Object} target    The object on which the event will fire.
         * @param  {Function} handler   The function to call when the event occurs.
         *     The browserServices passes a WebEvent object to this handler
         */
        subscribe: function (eventName, target, handler) {
            var wrappedHandler = handlerMappings.add(handler);
            addEventListener(target, eventName, wrappedHandler);
        },

        /**
         * Unsubscribes an event handler from a particular event.
         * @param  {String} eventName The name of the event for which the handler was subscribed.
         * @param  {Object} target    The object on which the event fires.
         * @param  {Function} handler   The function to remove as an event handler.
         */
        unsubscribe: function (eventName, target, handler) {
            var wrappedHandler = handlerMappings.find(handler);
            if (wrappedHandler) {
                try {
                    removeEventListener(target, eventName,  wrappedHandler);
                } catch (e) {
                }
                handlerMappings.remove(handler);
            }
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*global TLT:true, window: true, ActiveXObject */

/**
 * @name ajaxService
 * @namespace
 */
TLT.addService("ajax", function (core) {
    "use strict";

    var getXHRObject,
		convertHeaders = function (headersObj) {
            var header = "",
                headers = [];
            for (header in headersObj) {
                if (headersObj.hasOwnProperty(header)) {
                    headers.push([header, headersObj[header]]);
                }
            }
            return headers;
        },
		isInitialized = false;

    /**
     * Builds an object of key => value pairs of HTTP headers from a string.
     * @param  {String} headers The string of HTTP headers separated by newlines
     *      (i.e.: "Content-Type: text/html\nLast-Modified: ..")
     * @return {Object}         Returns an object where every key is a header
     *     and every value it's correspondending value.
     */
    function extractResponseHeaders(headers) {
        headers = headers.split('\n');
        var headersObj = {},
            i = 0,
            len = headers.length,
            header = null;
        for (i = 0; i < len; i += 1) {
            header = headers[i].split(': ');
            headersObj[header[0]] = header[1];
        }
        return headersObj;
    }

    /**
     * @private
     * @function
     * @name ajaxService-makeAjaxCall
     * @see browserService.sendRequest
     */
    function makeAjaxCall(message) {
        var xhr = getXHRObject(),
            headers = [["X-Requested-With", "XMLHttpRequest"]],
            timeout = 0,
            async = typeof message.async !== "boolean" ? true : message.async,
            header = "",
            callbackFn = null,
            i,
            length;

        if (message.headers) {
            headers = headers.concat(convertHeaders(message.headers));
        }
        if (message.contentType) {
            headers.push(["Content-Type", message.contentType]);
        }
        xhr.open(message.type.toUpperCase(), message.url, async);

        for (i = 0, length = headers.length; i < length; i += 1) {
            header = headers[i];
            if (header[0] && header[1]) {
                xhr.setRequestHeader(header[0], header[1]);
            }
        }

        xhr.onreadystatechange = callbackFn = function () {
            if (xhr.readyState === 4) {
                xhr.onreadystatechange = callbackFn = function () {};
                if (message.timeout) {
                    window.clearTimeout(timeout);
                }
                message.oncomplete({
                    headers: extractResponseHeaders(xhr.getAllResponseHeaders()),
                    responseText: (xhr.responseText || null),
                    statusCode: xhr.status,
                    success: (xhr.status === 200)
                });
                xhr = null;
            }
        };

        xhr.send(message.data || null);
        callbackFn();

        if (message.timeout) {
            timeout = window.setTimeout(function () {
                if (!xhr) {
                    return;
                }

                xhr.onreadystatechange = function () {};
                if (xhr.readyState !== 4) {
                    xhr.abort();
                }
                xhr = null;
            }, message.timeout);
        }
    }

    function initAjaxService() {
		if (typeof window.XMLHttpRequest !== 'undefined') {
            getXHRObject = function () {
                return new XMLHttpRequest();
            };
        } else {
            getXHRObject = function () {
                return new ActiveXObject("Microsoft.XMLHTTP");
            };
        }

		isInitialized = true;
    }

    return {
		init: function () {
			if (!isInitialized) {
                initAjaxService();
            }
		},

		/**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

		/**
         * Makes an Ajax request to the server.
         * @param {Object} message An AjaxRequest object containing all the information
         *     neccessary for making the request.
         * @param {String} [message.contentType] Set to a string to override the default
         *     content type of the request.
         * @param {String} [message.data] A string containing data to POST to the server.
         * @param {Object} [message.headers] An object whose properties represent HTTP headers.
         * @param {Function} message.oncomplete A callback function to call when the
         *     request has completed.
         * @param {Integer} [message.timeout] The number of milliseconds to wait
         *     for a response before closing the Ajax request.
         * @param {String} [message.type="POST"] Either 'GET' or 'POST',
         *     indicating the type of the request to make.
         * @param {String} message.url The URL to send the request to.
         *     This should contain any required query string parameters.
         */
        sendRequest: function (message) {
            message.type = message.type || "POST";
            makeAjaxCall(message);
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The DOM Capture Service provides the ability to capture a snapshot of
 * the DOM as a HTML snippet.
 * @exports domCaptureService
 */

/*global TLT:true, window: true, Node:true */
/*global console: false */

/**
 * @name domCaptureService
 * @namespace
 */
TLT.addService("domCapture", function (core) {
    "use strict";

    var configService = core.getService("config"),
        messageService,
        isInitialized = false,
        tltUniqueIDIndex = 1,
        dupNode = function () {},
        getDOMCapture = function () {},
        updateConfig = function () {};

    /**
     * Initialization of the service. Subscribe with config service for
     * the configupdated message.
     * @private
     * @function
     * @param {object} config
     */
    function initDOMCaptureService(config) {
        configService.subscribe("configupdated", updateConfig);
        messageService = core.getService("message");
        isInitialized = true;
    }

    /**
     * Destroy the service. Unsubscribe from the configupdated message.
     * @private
     * @function
     */
    function destroyDOMCaptureService() {
        configService.unsubscribe("configupdated", updateConfig);
        isInitialized = false;
    }

    /**
     * Returns a unique identifier string.
     * @private
     * @function
     * @returns {String} A string that can be used as a unique identifier.
     */
    function getUniqueID() {
        var id;

        id = "tlt-" + core.utils.getSerialNumber();

        return id;
    }

    /**
     * Remove child nodes matching the given tag name.
     * @private
     * @function
     * @param {DOMNode} node The root or parent DOM Node element
     * @param {String}  tagName The tag to be removed
     * @returns The node without any tags matching tagName
     */
    function removeTags(node, tagName) {
        var i,
            nodeList;

        // Sanity check
        if (!node || !node.getElementsByTagName || !tagName) {
            return;
        }

        nodeList = node.getElementsByTagName(tagName);
        if (nodeList && nodeList.length) {
            for (i = nodeList.length - 1; i >= 0; i -= 1) {
                nodeList[i].parentNode.removeChild(nodeList[i]);
            }
        }

        return node;
    }

    /**
     * Returns the DOCTYPE of the document as a formatted string.
     * @private
     * @function
     * @param {DOMNode} node A document node.
     * @returns {String} The formatted doctype or null.
     */
    function getDoctypeAsString(node) {
        var doctype,
            doctypeStr = null;

        // Sanity check
        if (!node || !node.doctype) {
            return null;
        }

        doctype = node.doctype;
        if (doctype) {
            doctypeStr = "<!DOCTYPE " + doctype.name +
                         (doctype.publicId ? ' PUBLIC "' + doctype.publicId + '"' : "") +
                         (!doctype.publicId && doctype.systemId ? ' SYSTEM' : "") +
                         (doctype.systemId ? ' "' + doctype.systemId + '"' : "") +
                         ">";
        }

        return doctypeStr;
    }

    /**
     * Fix child input nodes and set attributes such as value & checked.
     * @private
     * @function
     * @param {DOMNode} target The root or parent DOM Node element
     */
    function fixInputs(target) {
        var i,
            j,
            inputElement,
            inputList,
            len,
            radio,
            radioButtons,
            radioLen;

        // Sanity check
        if (!target) {
            return;
        }

        inputList = target.getElementsByTagName("input");
        if (inputList) {
            for (i = 0, len = inputList.length; i < len; i += 1) {
                inputElement = inputList[i];
                switch (inputElement.type) {
                case "checkbox":
                case "radio":
                    if (inputElement.checked) {
                        inputElement.setAttribute("checked", "checked");
                    } else {
                        inputElement.removeAttribute("checked");
                    }
                    break;
                default:
                    inputElement.setAttribute("value", inputElement.value);
                    break;
                }
            }
        }
    }

    /**
     * Fix the child select lists by setting the selected attribute on the option elements of
     * the lists in the target node.
     * @private
     * @function
     * @param {DOMNode} source The root or parent DOM Node element
     * @param {DOMNode} target The target DOM Node element that is a copy of the source
     */
    function fixSelectLists(source, target) {
        var sourceElem,
            sourceList,
            targetElem,
            targetList,
            i,
            j,
            len;

        // Sanity check
        if (!source || !source.getElementsByTagName || !target || !target.getElementsByTagName) {
            return;
        }

        sourceList = source.getElementsByTagName("select");
        targetList = target.getElementsByTagName("select");

        // TODO: ASSERT source and target nodes have same order of select elements

        if (sourceList) {
            for (i = 0, len = sourceList.length; i < len; i += 1) {
                sourceElem = sourceList[i];
                targetElem = targetList[i];
                for (j = 0; j < sourceElem.options.length; j += 1) {
                    if (j === sourceElem.selectedIndex || sourceElem.options[j].selected) {
                        targetElem.options[j].setAttribute("selected", "selected");
                    } else {
                        targetElem.options[j].removeAttribute("selected");
                    }
                }
            }
        }
    }

    /**
     * Return the outer HTML of the document or element.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element
     * @returns {String} The HTML text of the document or element. If the node is not
     * a document or element type then return null.
     */
    function getHTMLText(node) {
        var nodeType,
            htmlText = null;

        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
                // DOCUMENT_NODE
                htmlText = node.documentElement.outerHTML;
                break;
            case 1:
                // ELEMENT_NODE
                htmlText = node.outerHTML;
                break;
            default:
                htmlText = null;
                break;
            }
        }
        return htmlText;
    }

    /**
     * Checks if the DOM node is allowed for capture. Only document and element
     * node types are allowed for capture.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element to be checked
     * @returns {Boolean} Returns true if the node is document or element type.
     */
    function isNodeValidForCapture(node) {
        var nodeType,
            valid = false;
        // Only DOCUMENT (9) & ELEMENT (1) nodes are valid for capturing
        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
            case 1:
                valid = true;
                break;
            default:
                valid = false;
                break;
            }
        }
        return valid;
    }

    /**
     * Capture the frames from the source and add the unique token to the frame element
     * in the target.
     * @private
     * @function
     * @param {DOMNode} source The source element
     * @param {DOMNode} target The target element duplicated from the source.
     * @param {Object}  options The capture options object
     * @returns {Object} Returns the captured frames & canvas elements as per the enabled options.
     */
    function getIframes(source, target, options) {
        var i, j,
            len,
            frameTag,
            frameTags = [ "iframe", "frame" ],
            sourceIframe,
            iframeWindow,
            iframeDoc,
            iframeCapture,
            iframeID,
            returnObject = {
                frames: [],
                canvas: []
            },
            sourceIframeList,
            targetIframeList;

        for (j = 0; j < frameTags.length; j += 1) {
            frameTag = frameTags[j];
            // Get the frames in the original DOM
            sourceIframeList = source.getElementsByTagName(frameTag);

            // Get the cloned frames - the content is not copied here - these will be
            // used to add an attribute to specify which item in the frames collection
            // contains the content for this frame
            targetIframeList = target.getElementsByTagName(frameTag);

            if (sourceIframeList) {
                for (i = 0, len = sourceIframeList.length; i < len; i += 1) {
                    try {
                        sourceIframe = sourceIframeList[i];
                        iframeWindow = core.utils.getIFrameWindow(sourceIframe);
                        if (iframeWindow && iframeWindow.document) {
                            iframeDoc = iframeWindow.document;

                            iframeCapture = getDOMCapture(iframeDoc, iframeDoc, options);
                            iframeID = getUniqueID();
                            // Set the tltid for this frame in the target DOM
                            targetIframeList[i].setAttribute("tltid", iframeID);

                            // Merge this frame's captured DOM into the return object
                            returnObject.frames.push({
                                root: iframeCapture.root,
                                charset: iframeDoc.characterSet || iframeDoc.charset,
                                tltid: iframeID
                            });
                            returnObject.frames = returnObject.frames.concat(iframeCapture.frames);
                            returnObject.canvas = returnObject.canvas.concat(iframeCapture.canvas);
                        }
                    } catch (e) {
                        // Do nothing!
                    }
                }
            }
        }
        return returnObject;
    }

    /**
     * Calculate the total length of the HTML in the captured object.
     * @private
     * @function
     * @param {Object} captureObj The DOM capture object containing the serialized HTML.
     * @returns {Number} Returns the total length of the serialized object.
     */
    function getCapturedLength(captureObj) {
        var i,
            len,
            totalLength = 0;

        if (!captureObj || !captureObj.root) {
            return totalLength;
        }

        totalLength = captureObj.root.length;
        for (i = 0, len = captureObj.frames.length; i < len; i += 1) {
            if (captureObj.frames[i].root) {
                totalLength += captureObj.frames[i].root.length;
            }
        }

        return totalLength;
    }

    /**
     * Clone the provided document or element node.
     * @private
     * @function
     * @param {DOMNode} node The element to be duplicated.
     * @returns {DOMNode} Returns the duplicated node.
     */
    dupNode = function (node) {
        var dup = null;

        if (isNodeValidForCapture(node)) {
            dup = node.cloneNode(true);
            if (!dup && node.documentElement) {
                // Fix for Android and Safari bug which returns null when cloneNode is called on the document element.
                dup = node.documentElement.cloneNode(true);
            }
        }

        return dup;
    };

    /**
     * Capture the DOM starting at the root element as per the provided configuration options.
     * @private
     * @function
     * @param {DOMNode} doc The document element.
     * @param {DOMNode} root The root element that needs to be captured.
     * @param {Object}  options The capture options object.
     * @returns {Object} Returns the object containing the captured and serialized DOM.
     */
    getDOMCapture = function (doc, root, options) {
        var new_doc = null,
            canvasCaptureList,
            frameCaptureObj,
            captureObj = {};

        // Sanity check
        if (!doc || !root) {
            return captureObj;
        }

        new_doc = dupNode(root, doc);

        // Remove script tags
        if (options.removeScripts) {
            removeTags(new_doc, "script");
        }

        // Set "selected" attribute on select list elements
        fixSelectLists(root, new_doc);

        // Set attributes on input elements.
        fixInputs(new_doc);

        // Apply privacy
        new_doc = messageService.applyPrivacyToDocument(new_doc);

        if (options.captureCanvas) {
            // TODO: Get the canvas elements
            canvasCaptureList = null;
        }

        if (options.captureFrames) {
            // Get the iframes
            frameCaptureObj = getIframes(root, new_doc, options);
        }

        // Add all the captured data to the capture object
        if (frameCaptureObj) {
            captureObj = core.utils.mixin(captureObj, frameCaptureObj);
        }
        if (canvasCaptureList) {
            if (!captureObj.canvas) {
                captureObj.canvas = [];
            }
            captureObj.canvas = captureObj.canvas.concat(canvasCaptureList);
        }
        captureObj.root = (getDoctypeAsString(root) || "") + getHTMLText(new_doc);
        captureObj.charset = doc.characterSet || doc.charset;

        return captureObj;
    };

    /**
     * Callback function which receives notification from config service when
     * the configuration is updated.
     * @private
     * @function
     */
    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
    };

    /**
     * @scope domCaptureService
     */
    return {
        /**
         * Callback function invoked by the core to initialize the DOM Capture service.
         * @private
         * @function
         */
        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
            } else {
            }
        },

        /**
         * Callback function invoked by the core to destroy the DOM Capture service.
         * @private
         * @function
         */
        destroy: function () {
            destroyDOMCaptureService();
        },

        /**
         * API function exposed by the DOM Capture service. Accepts the root element and
         * DOM capture options object.
         * @param  {DOMNode} root The root element for the DOM capture.
         * @param  {Object}  options The configuration options for performing the DOM capture.
         * @return {Object} An object containing the captured DOM.
         */
        captureDOM: function (root, options) {
            var captureObj = null,
                totalLength = 0;

            // Sanity check - DOM Capture is not supported on IE 8 and below
            if (!isInitialized || core.utils.isLegacyIE) {
                return captureObj;
            }

            if (!options || typeof options !== "object") {
                options = {};
            }
            root = root || window.document;

            captureObj = getDOMCapture(window.document, root, options);

            // Check if the capture meets the length threshold (if any)
            if (options.maxLength) {
                totalLength = getCapturedLength(captureObj);
                if (totalLength > options.maxLength) {
                    captureObj = {
                        errorCode: 101,
                        error: "Captured length (" + totalLength + ") exceeded limit (" + options.maxLength + ")."
                    };
                }
            }

            return captureObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The EncoderService provides the ability to extend the library with various data encodings.
 * @exports encoderService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name encoderService
 * @namespace
 */
TLT.addService("encoder", function (core) {
    "use strict";

    var encoderServiceConfig = {},
        configService = null,
        handleConfigUpdated = null,
        isInitialized = false;

    /**
     * Returns the encoder object for the specified encoder type.
     * @private
     * @function
     * @param {String} type The type of encoder object. e.g. "gzip"
     * @returns {Object} The encoder object or null if not found.
     */
    function getEncoder(type) {
        var encoder = null;

        // Sanity check
        if (!type) {
            return encoder;
        }
        encoder = encoderServiceConfig[type];
        if (encoder && typeof encoder.encode === "string") {
            encoder.encode = core.utils.access(encoder.encode);
        }

        return encoder;
    }

    /**
     * Initializes the encoder service.
     * @private
     * @function
     * @param {Object} config The configuration object for this service
     */
    function initEncoderService(config) {
        encoderServiceConfig = config;

        configService.subscribe("configupdated", handleConfigUpdated);
        isInitialized = true;
    }

    /**
     * Destroys the encoder service.
     * @private
     * @function
     */
    function destroy() {
        configService.unsubscribe("configupdated", handleConfigUpdated);

        isInitialized = false;
    }

    /**
     * Callback handler for the configupdated event. Refreshes the service configuration to the latest.
     * @private
     * @function
     */
    handleConfigUpdated = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initEncoderService(configService.getServiceConfig("encoder") || {});
    };

    /**
     * @scope serializerService
     */
    return {

        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initEncoderService(configService.getServiceConfig("encoder") || {});
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Encodes data using specified encoder.
         * @param  {String} data The data to encode.
         * @param  {String} type The name of the encoder to use.
         * @return {Object} An object containing the encoded data or error message.
         */
        encode: function (data, type) {
            var encoder,
                result,
                returnObj = {
                    data: null,
                    encoding: null,
                    error: null
                };

            // Sanity check
            if ((typeof data !== "string" && !data) || !type) {
                returnObj.error = "Invalid " + (!data ? "data" : "type") + " parameter.";
                return returnObj;
            }

            // Get the specified encoder
            encoder = getEncoder(type);
            if (!encoder) {
                returnObj.error = "Specified encoder (" + type + ") not found.";
                return returnObj;
            }

            // Sanity check
            if (typeof encoder.encode !== "function") {
                returnObj.error = "Configured encoder (" + type + ") encode method is not a function.";
                return returnObj;
            }

            // Invoke the encode method of the encoder and return the result.
            result = encoder.encode(data);
            if (!result || core.utils.getValue(result, "buffer", null) === null) {
                returnObj.error = "Encoder (" + type + ") returned an invalid result.";
                return returnObj;
            }

            returnObj.data = result.buffer;
            returnObj.encoding = encoder.defaultEncoding;

            return returnObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The MessageService creates messages in the correct format to be transmitted to the server.
 * @exports messageService
 */

/*global TLT:true */

/**
 * @name messageService
 * @namespace
 */
TLT.addService("message", function (core) {
    "use strict";

    var screenviewOffsetTime = null,
        count             = 0,
        messageCount      = 0,
        sessionStart      = new Date(),
        tlStartLoad       = new Date(),
        browserBaseService = core.getService("browserBase"),
        browserService    = core.getService("browser"),
        configService     = core.getService("config"),
        config            = configService.getServiceConfig("message") || {},
        windowHref        = window.location.href,
        windowId          = "TODO",
        pageId            = "ID" + tlStartLoad.getHours() + "H" +
                            tlStartLoad.getMinutes() + "M" +
                            tlStartLoad.getSeconds() + "S" +
                            tlStartLoad.getMilliseconds() + "R" +
                            Math.random(),
        privacy           = config.hasOwnProperty("privacy") ? config.privacy : [],
        privacyMasks      = {},
        maskingCharacters = {
            lower: "x",
            upper: "X",
            numeric: "9",
            symbol: "@"
        },

        //TODO move these to a global section due to they might be used elsewhere
        isApple = navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPod") > -1 || navigator.userAgent.indexOf("iPad") > -1,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Android") > -1,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = window.screen ? window.screen.width : 0,
        deviceOriginalHeight = window.screen ? window.screen.height : 0,
        deviceOrientation = window.orientation || 0,
        deviceWidth = isApple || isAndroidChrome ? deviceOriginalWidth : deviceOriginalWidth <= 320 ? deviceOriginalWidth : deviceOriginalWidth / devicePixelRatio,
        deviceHeight = isApple || isAndroidChrome ? deviceOriginalHeight : deviceOriginalWidth <= 320 ? deviceOriginalHeight : deviceOriginalHeight / devicePixelRatio,
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        startWidth = window.innerWidth || document.documentElement.clientWidth,
        startHeight = window.innerHeight || document.documentElement.clientHeight,
        isInitialized = false;


    /**
     * Base structure for a message object.
     * @constructor
     * @private
     * @name messageService-Message
     * @param {Object} event The QueueEvent to transform into a message object.
     */
    function Message(event) {
        var key = '';

        /**
         * The message type.
         * @type {Number}
         * @see browserService-Message.TYPES
         */
        this.type          = event.type;
        /**
         * The offset from the beginning of the session.
         * @type {Number}
         */
        this.offset        = (new Date()).getTime() - sessionStart.getTime();
        /**
         * The offset from the most recent application context message.
         * @type {Number}
         */
        if ((event.type === 2) || (screenviewOffsetTime === null)) {
            screenviewOffsetTime = new Date();
        }
        this.screenviewOffset = (new Date()).getTime() - screenviewOffsetTime.getTime();

        /**
         * The count of the overall messages until now.
         * @type {Number}
         */
        this.count         = (messageCount += 1);

        /**
         * To indicate that user action came from the web.
         * @type {Boolean}
         */
        this.fromWeb       = true;

        // iterate over the properties in the queueEvent and add all the objects to the message.
        for (key in event) {
            if (event.hasOwnProperty(key)) {
                this[key] = event[key];
            }
        }
    }

    /**
     * Empty filter. Returns an empty string which would be used as value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns an empty string.
     */
    privacyMasks.PVC_MASK_EMPTY = function (value) {
        return "";
    };

    /**
     * Basic filter. Returns a predefined string for every value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a predefined mask/string.
     */
    privacyMasks.PVC_MASK_BASIC = function (value) {
        var retMask = "XXXXX";

        // Sanity check
        if (typeof value !== "string") {
            return "";
        }
        return (value.length ? retMask : "");
    };

    /**
     * Type filter. Returns predefined values for uppercase/lowercase
     *                         and numeric values.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a string/mask which uses predefined
     *                        characters to mask the value.
     */
    privacyMasks.PVC_MASK_TYPE = function (value) {
        var characters,
            i = 0,
            len = 0,
            retMask = "";

        // Sanity check
        if (typeof value !== "string") {
            return retMask;
        }

        characters = value.split("");

        for (i = 0, len = characters.length; i < len; i += 1) {
            if (core.utils.isNumeric(characters[i])) {
                retMask += maskingCharacters.numeric;
            } else if (core.utils.isUpperCase(characters[i])) {
                retMask += maskingCharacters.upper;
            } else if (core.utils.isLowerCase(characters[i])) {
                retMask += maskingCharacters.lower;
            } else {
                retMask += maskingCharacters.symbol;
            }
        }
        return retMask;
    };

    privacyMasks.PVC_MASK_EMPTY.maskType = 1; // reported value is empty string.
    privacyMasks.PVC_MASK_BASIC.maskType = 2; // reported value is fixed string "XXXXX".
    privacyMasks.PVC_MASK_TYPE.maskType = 3;  // reported value is a mask according to character type
                                              // as per configuration, e.g. "HelloWorld123" becomes "XxxxxXxxxx999".
    privacyMasks.PVC_MASK_CUSTOM = {
        maskType: 4 // reported value is return value of custom function provided by config.
    };

    /**
     * Checks which mask should be used to replace the value and applies
     * it to the string. If an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask The privacy object.
     * @param  {String} str  The string to be masked.
     */
    function maskStr(mask, str) {
        var filter = privacyMasks.PVC_MASK_BASIC;

        // Sanity check
        if (typeof str !== "string") {
            return str;
        }

        if (!mask) {
            // Default
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_EMPTY.maskType) {
            filter = privacyMasks.PVC_MASK_EMPTY;
        } else if (mask.maskType === privacyMasks.PVC_MASK_BASIC.maskType) {
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_TYPE.maskType) {
            filter = privacyMasks.PVC_MASK_TYPE;
        } else if (mask.maskType === privacyMasks.PVC_MASK_CUSTOM.maskType) {
            if (typeof mask.maskFunction === "string") {
                filter = core.utils.access(mask.maskFunction);
            } else {
                filter = mask.maskFunction;
            }
            if (typeof filter !== "function") {
                // Reset to default
                filter = privacyMasks.PVC_MASK_BASIC;
            }
        }
        return filter(str);
    }

    /**
     * Checks which mask should be used to replace the value and applies
     * it on the message object. By default, if an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask    The privacy object.
     * @param  {Object} message The entire message object.
     */
    function applyMask(mask, message) {
        // Sanity check
        if (!message || !message.target) {
            return;
        }

        if (typeof message.target.prevState !== "undefined" && message.target.prevState.hasOwnProperty("value")) {
            message.target.prevState.value = maskStr(mask, message.target.prevState.value);
        }
        if (typeof message.target.currState !== "undefined" && message.target.currState.hasOwnProperty("value")) {
            message.target.currState.value = maskStr(mask, message.target.currState.value);
        }
    }

    /**
     * Checks whether one of the privacy targets matches the target
     *                          of the current mesage.
     * TODO: There are several places in the library where the same type
     * of matching result is required based on id or selector. This should
     * be consolidated into a single helper function.
     * @param  {Array} targets An array of objects as defined in the
     *                         privacy configuration.
     * @param  {Object} target  The target object of the message.
     * @return {Boolean}         Returns true if one of the targets match.
     *                           Otherwise false.
     */
    function matchesTarget(targets, target) {
        var i,
            j,
            element,
            qr,
            qrLen,
            qrTarget,
            regex,
            len,
            tmpTarget;

        // Sanity check
        if (!targets || !target || !target.id) {
            return false;
        }

        for (i = 0, len = targets.length; i < len; i += 1) {
            tmpTarget = targets[i];

            // Check if target in config is a selector string.
            if (typeof tmpTarget === "string") {
                qr = browserService.queryAll(tmpTarget);
                for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                    if (qr[j]) {
                        qrTarget = browserBaseService.ElementData.prototype.examineID(qr[j]);
                        if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                            return true;
                        }
                    }
                }
            } else if (tmpTarget.id && tmpTarget.idType && target.idType.toString() === tmpTarget.idType.toString()) {
                // Note: idType provided by wizard is a string so convert both to strings before comparing.

                // An id in the configuration could be a direct match, in which case it will be a string OR
                // it could be a regular expression in which case it would be an object like this:
                // {regex: ".+private$", flags: "i"}
                switch (typeof tmpTarget.id) {
                case "string":
                    if (tmpTarget.id === target.id) {
                        return true;
                    }
                    break;
                case "object":
                    regex = new RegExp(tmpTarget.id.regex, tmpTarget.id.flags);
                    if (regex.test(target.id)) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    /**
     * Runs through all privacy configurations and checks if it matches
     * the current message object.
     * @param  {Object} message The message object.
     * @return {Object}         The message, either with replaced values
     *                          if a target of the privacy configuration
     *                          matched or the original message if the
     *                          configuration didn't match.
     */
    function privacyFilter(message) {
        var i,
            len,
            mask;

        if (!message || !message.hasOwnProperty("target")) {
            return message;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            if (matchesTarget(mask.targets, message.target)) {
                applyMask(mask, message);
                break;
            }
        }
        return message;
    }

    /**
     * Applies the privacy configuration to all the matching elements
     * of the specified document object.
     * @param  {DOMDocument} doc The document object to which the privacy rules
     *                      need to be applied.
     * @return {DOMDocument}     The document object to which the privacy rules
     *                      have been applied.
     */
    function applyPrivacyToDocument(doc) {
        var i, j, k,
            element,
            len,
            mask,
            qr,
            qrLen,
            target,
            targets,
            targetsLen;

        // Sanity check
        if (!doc) {
            return doc;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            targets = mask.targets;
            for (j = 0, targetsLen = targets.length; j < targetsLen; j += 1) {
                target = targets[j];
                if (typeof target === "string") {
                    // CSS selector
                    qr = browserService.queryAll(target, doc);
                    for (k = 0, qrLen = qr.length; k < qrLen; k += 1) {
                        element = qr[k];
                        if (element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                } else {
                    if (typeof target.id === "string") {
                        element = browserBaseService.getNodeFromID(target.id, target.idType, doc);
                        if (element && element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                    // TODO: Handle the case where the target.id is a regex.
                    /*
                     * 1. Save all the regex rules into 3 arrays depending on the idType
                     * {
                     *     htmlID: [ {regex, mask} ],
                     *     xpathID: [],
                     *     customID: []
                     * }
                     * 2. Outside this for loop, get all the input elements in the document
                     * 3. Get element id, idType
                     */
                }
            }
        }

        return doc;
    }

    /**
     * Gets called when the configserver fires configupdated event.
     */
    function updateConfig() {
        configService = core.getService("config");
        config = configService.getServiceConfig("message") || {};
        privacy = config.hasOwnProperty("privacy") ? config.privacy : [];
    }

    function initMessageService() {
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }


    /**
     * @scope messageService
     */
    return {

        init: function () {
            if (!isInitialized) {
                initMessageService();
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        applyPrivacyToDocument: applyPrivacyToDocument,

        /**
         * Accepts a simple queue event  and wraps it into a complete message that the server can understand.
         * @param  {Object} event The simple event information
         * @return {Object}       A complete message that is ready for transmission to the server.
         */
        createMessage: function (event) {
            if (typeof event.type === "undefined") {
                throw new TypeError("Invalid queueEvent given!");
            }
            return privacyFilter(new Message(event));
        },

        /**
         * Mock function to create a JSON structure around messages before sending to server.
         * @param  {Array} messages An array of messages
         * @return {Object}          Returns a JavaScript object which can be serialized to JSON
         *      and send to the server.
         *  @todo rewrite functionality
         */
        wrapMessages: function (messages) {
            var messagePackage = {
                messageVersion: "4.0.0.0",
                serialNumber: (count += 1),
                sessions: [{
                    id: pageId,
                    startTime: tlStartLoad.getTime(),
                    timezoneOffset: tlStartLoad.getTimezoneOffset(),
                    messages: messages,
                    clientEnvironment: {
                        webEnvironment: {
                            libVersion: "4.0.0.1607",
                            page: windowHref,
                            windowId: windowId,
                            screen: {
                                devicePixelRatio: devicePixelRatio,
                                deviceOriginalWidth: isApple || isAndroidChrome ? deviceOriginalWidth * devicePixelRatio : deviceOriginalWidth,
                                deviceOriginalHeight: isApple || isAndroidChrome ? deviceOriginalHeight * devicePixelRatio : deviceOriginalHeight,
                                deviceWidth: deviceWidth,
                                deviceHeight: deviceHeight,
                                deviceToolbarHeight: deviceToolbarHeight,
                                width: startWidth,
                                height: startHeight,
                                orientation: deviceOrientation
                            }
                        }
                    }
                }]
            },
                webEnvScreen = messagePackage.sessions[0].clientEnvironment.webEnvironment.screen;

            webEnvScreen.orientationMode = core.utils.getOrientationMode(webEnvScreen.orientation);
            /*
            if (true) { // Add usability to config settings
                //messagePackage.domainId = "<<TODO domainId>>"; This was used to send to correct posting url, no longer needed. Followup with Chris. Checked with Joe.
                //messagePackage.samplingRate = "<<TODO samplingRate>>"; This is no longer needed. We will not focus on sampling for this release of 8.6.
            }
            */
            return messagePackage;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SerializerService provides the ability to serialize
 * data into one or more string formats.
 * @exports serializerService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name serializerService
 * @namespace
 */
TLT.addService("serializer", function (core) {
    "use strict";

    /**
     * JSON serializer. If possible it uses JSON.stringify method, but
     * for older browsers it provides minimalistic implementaction of
     * custom serializer (limitations: does not detect circular
     * dependencies, does not serialize date objects and does not
     * validate names of object fields).
     * @private
     * @function
     * @name serializerService-serializeToJSON
     * @param {Any} obj - any value
     * @returns {string} serialized string
     */
    function serializeToJSON(obj) {
        var str,
            key,
            len = 0;
        if (typeof obj !== "object" || obj === null) {
            switch (typeof obj) {
            case "function":
            case "undefined":
                return "null";
            case "string":
                return '"' + obj.replace(/\"/g, '\\"') + '"';
            default:
                return String(obj);
            }
        } else if (Object.prototype.toString.call(obj) === "[object Array]") {
            str = "[";
            for (key = 0, len = obj.length; key < len; key += 1) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str += serializeToJSON(obj[key]) + ",";
                }
            }
        } else {
            str = "{";
            for (key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str = str.concat('"', key, '":', serializeToJSON(obj[key]), ",");
                    len += 1;
                }
            }
        }
        if (len > 0) {
            str = str.substring(0, str.length - 1);
        }
        str += String.fromCharCode(str.charCodeAt(0) + 2);
        return str;
    }


    /**
     * Serializer / Parser implementations
     * @type {Object}
     */
    var configService = core.getService("config"),
        serialize = {},
        parse = {},
        defaultSerializers = {
            json: (function () {
                if (typeof window.JSON !== "undefined") {
                    return {
                        serialize: window.JSON.stringify,
                        parse: window.JSON.parse
                    };
                }

                return {
                    serialize: serializeToJSON,
                    // TODO: find a better way than using eval
                    parse: function (data) {
                        return eval("(" + data + ")");
                    }
                };
            }())
        },
        updateConfig = null,
        isInitialized = false;

    function addObjectIfExist(paths, rootObj, propertyName) {
        var i,
            len,
            obj;

        paths = paths || [];
        for (i = 0, len = paths.length; i < len; i += 1) {
            obj = paths[i];
            if (typeof obj === "string") {
                obj = core.utils.access(obj);
            }
            if (typeof obj === "function") {
                rootObj[propertyName] = obj;
                break;
            }
        }
    }
	function checkParserAndSerializer() {
		var isParserAndSerializerInvalid;
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
			isParserAndSerializerInvalid = true;
        } else {
			if (typeof parse.json('{"foo": "bar"}') === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = parse.json('{"foo": "bar"}').foo !== "bar";
			}
			if (typeof parse.json("[1, 2]") === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1, 2]")[0] !== 1;
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1,2]")[1] !== 2;
			}
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json({"foo": "bar"}) !== '{"foo":"bar"}';
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json([1, 2]) !== "[1,2]";
		}
		return isParserAndSerializerInvalid;
	}
    function initSerializerService(config) {
        var format;
        for (format in config) {
            if (config.hasOwnProperty(format)) {
                addObjectIfExist(config[format].stringifiers, serialize, format);
                addObjectIfExist(config[format].parsers, parse, format);
            }
        }

        // use default JSON parser/serializer if possible
        if (!(config.json && config.json.hasOwnProperty("defaultToBuiltin")) || config.json.defaultToBuiltin === true) {
            serialize.json = serialize.json || defaultSerializers.json.serialize;
            parse.json = parse.json || defaultSerializers.json.parse;
        }

        //sanity check
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
            core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.");
        }
		if (checkParserAndSerializer()) {
			core.fail("JSON stringification and parsing are not working as expected");
		}
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }


    function destroy() {
        serialize = {};
        parse = {};

        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed. Verify initSerializerService is idempotent
        initSerializerService(configService.getServiceConfig("serializer") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        init: function () {
            if (!isInitialized) {
                initSerializerService(configService.getServiceConfig("serializer") || {});
            } else {
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Parses a string into a JavaScript object.
         * @param  {String} data The string to parse.
         * @param  {String} [type="json"] The format of the data.
         * @return {Object}      An object representing the string data.
         */
        parse: function (data, type) {
            type = type || "json";
            return parse[type](data);
        },

        /**
         * Serializes object data into a string using the format specified.
         * @param  {Object} data The data to serialize.
         * @param  {String} [type="json"] The format to serialize the data into.
         * @return {String}      A string containing the serialization of the data.
         */
        serialize: function (data, type) {
            type = type || "json";
            return serialize[type](data);
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Overstat module implements the logic for collecting
 * data for cxOverstat. The current uses are for the Hover Event and
 * Hover To Click event.
 * @exports overstat
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name overstat
     * @namespace
     */
    TLT.addModule("overstat", function (context) {
        "use strict";

        var tlTypes = {
            "input:radio": "radioButton",
            "input:checkbox": "checkBox",
            "input:text": "textBox",
            "input:password": "textBox",
            "input:file": "fileInput",
            "input:button": "button",
            "input:submit": "submitButton",
            "input:reset": "resetButton",
            "input:image": "image",
            "input:color": "color",
            "input:date": "date",
            "input:datetime": "datetime",
            "input:datetime-local": "datetime-local",
            "input:number": "number",
            "input:email": "email",
            "input:tel": "tel",
            "input:search": "search",
            "input:url": "url",
            "input:time": "time",
            "input:week": "week",
            "input:month": "month",
            "textarea:": "textBox",
            "select:": "selectList",
            "button:": "button",
            "a:": "link"
        },

            eventMap = {},
            configDefaults = { "UPDATE_INTERVAL" : 250,
                                "HOVER_THRESHOLD_MIN" : 1000,
                                "HOVER_THRESHOLD_MAX" : 2 * 60 * 1000,
                                "GRIDCELL_MAX_X" : 10,
                                "GRIDCELL_MAX_Y" : 10,
                                "GRIDCELL_MIN_WIDTH" : 20,
                                "GRIDCELL_MIN_HEIGHT" : 20
                };

        /**
         * Used to test and get value from an object.
         * @private
         * @function
         * @name replay-getValue
         * @param {object} parentObj An object you want to get a value from.
         * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
         * @return {object} If object is found, if not then null will be returned.
         */
        function getValue(parentObj, propertyAsStr) {
            var i,
                properties;

            // Sanity check
            if (!parentObj || typeof parentObj !== "object") {
                return null;
            }

            properties = propertyAsStr.split(".");
            for (i = 0; i < properties.length; i += 1) {
                if ((typeof parentObj === "undefined") || (parentObj[properties[i]] === null)) {
                    return null;
                }
                parentObj = parentObj[properties[i]];
            }
            return parentObj;
        }

        function getConfigValue(key) {
            var overstatConfig = context.getConfig() || {},
                value = overstatConfig[key];
            return typeof value === "number" ? value : configDefaults[key];
        }

        function postUIEvent(hoverEvent, options) {
            var tagName = getValue(hoverEvent, "webEvent.target.element.tagName") || "",
                type = tagName.toLowerCase() === "input" ? getValue(hoverEvent, "webEvent.target.element.type") : "",
                tlType = tlTypes[tagName.toLowerCase() + ":" + type] || tagName,

                uiEvent = {
                    type: 9,
                    event: {
                        hoverDuration: hoverEvent.hoverDuration,
                        hoverToClick: getValue(options, "hoverToClick")
                    },
                    target: {
                        id: getValue(hoverEvent, "webEvent.target.id") || "",
                        idType: getValue(hoverEvent, "webEvent.target.idType") || "",
                        name: getValue(hoverEvent, "webEvent.target.name") || "",
                        tlType: tlType,
                        type: tagName,
                        subType: type,
                        position: {
                            width: getValue(hoverEvent, "webEvent.target.element.offsetWidth") || 0,
                            height: getValue(hoverEvent, "webEvent.target.element.offsetHeight") || 0,
                            relXY: hoverEvent.gridX + "," + hoverEvent.gridY
                        }
                    }
                };

                // if id is null or empty, what are we firing on? it can't be replayed anyway
            if ((typeof uiEvent.target.id) === undefined || uiEvent.target.id === "") {
                return;
            }

            context.post(uiEvent);
        }

        function stopNode(node) {
            if (node && node.element) { node = node.element; }
            return !node || node === document.body || node === document.html || node === document;
        }

        function getParent(node) {
            if (!node) { return null; }
            return node.element ? node.element.parentNode : node.parentNode;
        }

        function getOffsetParent(node) {
            if (!node) { return null; }
            var parent = node.element ? node.element.offsetParent : node.offsetParent;
            return parent || getParent(node);
        }

        /*
         * for when mouseout is called - if you have moved over a child element, mouseout is fired for the parent element
         * @private
         * @function
         * @name overstat-isChildOf
         * @return {boolean} Returns whether node is a child of root
         */
        function isChildOf(root, node) {
            if (!node || node === root) { return false; }
            node = getParent(node);

            while (!stopNode(node)) {
                if (node === root) { return true; }
                node = getParent(node);
            }

            return false;
        }

        function getNativeEvent(e) {
            if (e.nativeEvent) { e = e.nativeEvent; }
            return e;
        }

        function getNativeTarget(e) {
            return getNativeEvent(e).target;
        }

        function getNativeNode(node) {
            if (!node) { return null; }
            return node.element || node;
        }

        function getNodeType(node) {
            if (!node) { return -1; }
            if (node.element) { node = node.element; }
            return node.nodeType || -1;
        }

        function getNodeTagName(node) {
            if (!node) { return ""; }
            if (node.element) { node = node.element; }
            return node.tagName ? node.tagName.toUpperCase() : "";
        }

        function getNodeElement(node) {
            if (node && node.element) { node = node.element; }
            return node;
        }

        function stopEventPropagation(e) {
            if (!e) { return; }
            if (e.nativeEvent) { e = e.nativeEvent; }

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.cancelBubble) {
                e.cancelBubble();
            }
        }

        function ignoreNode(node) {
            var tagName = getNodeTagName(node);
            return getNodeType(node) !== 1 || tagName === "TR" || tagName === "TBODY" || tagName === "THEAD";
        }

        /**
         * Generates an XPath for a given node, stub method until the real one is available
         * @function
         */
        function getXPathFromNode(node) {
            if (!node) { return ""; }
            if (node.xPath) { return node.xPath; }
            node = getNativeNode(node);
            return context.getXPathFromNode(node);
        }

        /*
         * replacement for lang.hitch(), setTimeout loses all scope
         * @private
         * @function
         * @name overstat-callHoverEventMethod
         * @return {object} Returns the value of the called method
         */
        function callHoverEventMethod(key, methodName) {
            var hEvent = eventMap[key];
            if (hEvent && hEvent[methodName]) { return hEvent[methodName](); }
        }

        function HoverEvent(dm, gx, gy, webEvent) {
            this.xPath = dm !== null ? getXPathFromNode(dm) : "";
            this.domNode = dm;
            this.hoverDuration = 0;
            this.hoverUpdateTime = 0;
            this.gridX = Math.max(gx, 0);
            this.gridY = Math.max(gy, 0);
            this.parentKey = "";
            this.updateTimer = -1;
            this.disposed = false;
            this.childKeys = {};
            this.webEvent = webEvent;

            /*
             * @public
             * @function
             * @name overstat-HoverEvent.getKey
             * @return {string} Returns the string unique key of this event
             */
            this.getKey = function () {
                return this.xPath + ":" + this.gridX + "," + this.gridY;
            };

            /*
             * update hoverTime, set timer to update again
             * @public
             * @function
             * @name overstat-HoverEvent.update
             */
            this.update = function () {
                var curTime = new Date().getTime(),
                    key = this.getKey();

                if (this.hoverUpdateTime !== 0) {
                    this.hoverDuration += curTime - this.hoverUpdateTime;
                }

                this.hoverUpdateTime = curTime;

                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(function () { callHoverEventMethod(key, "update"); }, getConfigValue("UPDATE_INTERVAL"));
            };

            /*
             * leaveClone is true if you want to get rid of an event but leave a new one in it's place.
             * usually this will happen due to a click, where the hover ends, but you want a new hover to
             * begin in the same place
             * @public
             * @function
             * @name overstat-HoverEvent.dispose
             */
            this.dispose = function (leaveClone) {
                clearTimeout(this.updateTimer);
                delete eventMap[this.getKey()];
                this.disposed = true;

                if (leaveClone) {
                    var cloneEvt = this.clone();
                    eventMap[cloneEvt.getKey()] = cloneEvt;
                    cloneEvt.update();
                }
            };

            /*
             * clear update timer, add to hover events queue if threshold is reached, dispose in any case
             * @public
             * @function
             * @name overstat-HoverEvent.process
             * @return {boolean} Returns whether or not the event met the threshold requirements and was added to the queue
             */
            this.process = function (wasClicked) {
                clearTimeout(this.updateTimer);
                if (this.disposed) { return false; }

                var addedToQueue = false,
                    hEvent = this,
                    key = null;
                if (this.hoverDuration >= getConfigValue("HOVER_THRESHOLD_MIN")) {
                    this.hoverDuration = Math.min(this.hoverDuration, getConfigValue("HOVER_THRESHOLD_MAX"));
                    // add to ui event queue here
                    addedToQueue = true;
                    postUIEvent(this, { hoverToClick : !!wasClicked });

                    while (typeof hEvent !== "undefined") {
                        hEvent.dispose(wasClicked);
                        hEvent = eventMap[hEvent.parentKey];
                    }
                } else {
                    this.dispose(wasClicked);
                }

                return addedToQueue;
            };

            /*
             * return a fresh copy of this event
             * @public
             * @function
             * @name overstat-HoverEvent.clone
             * @return {HoverTest} Returns a copy of this event with a reset hover time
             */
            this.clone = function () {
                var cloneEvent = new HoverEvent(this.domNode, this.gridX, this.gridY);
                cloneEvent.parentKey = this.parentKey;

                return cloneEvent;
            };
        }

        function createHoverEvent(node, x, y, webEvt) {
            return new HoverEvent(node, x, y, webEvt);
        }

        /*
         * get element offset according to the top left of the document
         * @private
         * @function
         * @name overstat-calculateNodeOffset
         * @return {object} Returns an object with x and y offsets
         */
        function calculateNodeOffset(node) {
            if (node && node.position) { return { x: node.position.x, y: node.position.y }; }
            node = getNodeElement(node);
            var offsetX = node.offsetLeft,
                offsetY = node.offsetTop,
                lastOffsetX = offsetX,
                lastOffsetY = offsetY,
                offsetDiffX = 0,
                offsetDiffY = 0,
                curNode = getOffsetParent(node);

            while (curNode) {
                if (stopNode(curNode)) { break; }

                offsetDiffX = curNode.offsetLeft - (curNode.scrollLeft || 0);
                offsetDiffY = curNode.offsetTop - (curNode.scrollTop || 0);

                if (offsetDiffX !== lastOffsetX || offsetDiffY !== lastOffsetY) {
                    offsetX += offsetDiffX;
                    offsetY += offsetDiffY;

                    lastOffsetX = offsetDiffX;
                    lastOffsetY = offsetDiffY;
                }

                curNode = getOffsetParent(curNode);
            }

            if (isNaN(offsetX)) { offsetX = 0; }
            if (isNaN(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * calculate position relative to top left corner of element
         * @private
         * @function
         * @name overstat-calculateRelativeCursorPos
         * @return {object} Returns an object with x and y offsets
         */
        function calculateRelativeCursorPos(node, cursorX, cursorY) {
            node = getNodeElement(node);
            var nodeOffset = calculateNodeOffset(node),
                offsetX = cursorX - nodeOffset.x,
                offsetY = cursorY - nodeOffset.y;

            if (!isFinite(offsetX)) { offsetX = 0; }
            if (!isFinite(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * determine grid cell dimensions based on the constants
         * @private
         * @function
         * @name overstat-calculateGridCell
         * @return {object} Returns the x and y grid location
         */
        function calculateGridCell(node, offsetX, offsetY) {
            node = getNodeElement(node);
            var cellWidth = node.offsetWidth > 0 ? Math.max(node.offsetWidth / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_WIDTH")) : getConfigValue("GRIDCELL_MIN_WIDTH"),
                cellHeight = node.offsetHeight > 0 ? Math.max(node.offsetHeight / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_HEIGHT")) : getConfigValue("GRIDCELL_MIN_HEIGHT"),

                cellX = Math.floor(offsetX / cellWidth),
                cellY = Math.floor(offsetY / cellHeight);

            if (!isFinite(cellX)) { cellX = 0; }
            if (!isFinite(cellY)) { cellY = 0; }
            return { x: cellX, y: cellY };
        }

        /*
         * called when a hover event fires - processes all unrelated hover events from the queue.
         * events are related if they are the calling event, or any parent events
         * @private
         * @function
         * @name overstat-cleanupHoverEvents
         */
        function cleanupHoverEvents(curEvent) {
            var hEvent = curEvent,
                curKey = curEvent.getKey(),
                allowedKeyMap = {},
                key = null,
                childKey = null;

            allowedKeyMap[curKey] = true;

            while (typeof hEvent !== "undefined") {
                allowedKeyMap[hEvent.parentKey] = true;
                if (hEvent.parentKey === "" || hEvent.parentKey === hEvent.getKey()) {
                    break;
                }

                hEvent = eventMap[hEvent.parentKey];
            }

            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key) && !allowedKeyMap[key]) {
                    hEvent = eventMap[key];
                    if (hEvent) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * similar to cleanupHoverEvents, this will process all events within a domNode (fired on mouseout)
         * @private
         * @function
         * @name overstat-processEventsByDomNode
         */
        function processEventsByDomNode(eventNode, keyToIgnore) {
            var hEvent = null,
                key = null;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    if (hEvent.domNode === eventNode && hEvent.getKey() !== keyToIgnore) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * 1) determine element and grid position for event
         * 2) find existing matching event if possible
         * 3) update event hover time
         * 4) bubble to parent node, for linking purposes
         * within the UI SDK framework, this should be called for each node in the heirarchy (box model)
         * going top down. so the parent (if the calculation is correct) should already exist, and have
         * it's own parent link, which helps during cleanupHoverEvents
         * @private
         * @function
         * @name overstat-hoverHandler
         * @return {HoverEvent} Returns the relevant HoverEvent object (either found or created)
         */
        function hoverHandler(e, node, isParent) {
            if (!node) { node = e.target; }
            if (stopNode(node)) { return null; }
            if (context.utils.isiOS || context.utils.isAndroid) { return null; }

            var rPos, gPos, hEvent, key, parentKey, parentEvent, offsetParent;

            if (!ignoreNode(node)) {
                rPos = calculateRelativeCursorPos(node, e.position.x, e.position.y);
                gPos = calculateGridCell(node, rPos.x, rPos.y);
                hEvent = new HoverEvent(node, gPos.x, gPos.y, e);
                key = hEvent.getKey();

                if (eventMap[key]) {
                    hEvent = eventMap[key];
                } else {
                    eventMap[key] = hEvent;
                }

                hEvent.update();

                // link parent, but in the case that it refers to itself (sometimes with frames) make sure the parentKey
                // is not the same as the current key
                if (!isParent) {
                    offsetParent = getOffsetParent(node);
                    if (offsetParent) {
                        parentEvent = hoverHandler(e, offsetParent, true);
                        if (parentEvent !== null) {
                            parentKey = parentEvent.getKey();
                            key = hEvent.getKey();
                            if (key !== parentKey) {
                                hEvent.parentKey = parentKey;
                            }
                        }
                    }

                    cleanupHoverEvents(hEvent);
                }
            } else {
                hEvent = hoverHandler(e, getOffsetParent(node), isParent);
            }

            return hEvent;
        }

        /*
         * process all events related to the event target, as hovering stops when leaving the element
         * @private
         * @function
         * @name overstat-leaveHandler
         */
        function leaveHandler(e) {
            e = getNativeEvent(e);
            if (isChildOf(e.target, e.relatedTarget)) {
                return;
            }

            processEventsByDomNode(e.target);
        }

        /*
         * on click, resolve current hover events, and reset hover count
         * @private
         * @function
         * @name overstat-clickHandler
         */
        function clickHandler(e) {
            var hEvent = null, key;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    hEvent.process(true);
                }
            }
        }

        /*
         * switches on window event type and routes it appropriately
         * @private
         * @function
         * @name overstat-handleEvent
         */
        function handleEvent(e) {
            var targetId = getValue(e, "target.id");

            // Sanity check
            if (!targetId) {
                return;
            }

            switch (e.type) {
            case "mousemove":
                hoverHandler(e);
                break;
            case "mouseout":
                leaveHandler(e);
                break;
            case "click":
                clickHandler(e);
                break;
            }
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {


            /**
             * Initialize the overstat module.
             */
            init: function () {
            },

            /**
             * Terminate the overstat module.
             */
            destroy: function () {
                var key, i;
                for (key in eventMap) {
                    if (eventMap.hasOwnProperty(key)) {
                        eventMap[key].dispose();
                        delete eventMap[key];
                    }
                }
            },

            /**
             * Handle events subscribed by the overstat module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                handleEvent(event);
            },

            /**
             * Handle system messages subscribed by the overstat module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            },

			createHoverEvent: createHoverEvent,
			cleanupHoverEvents: cleanupHoverEvents,
            eventMap: eventMap
        };
    });  // End of TLT.addModule
} else {


}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Performance module implements the logic for monitoring and
 * reporting performance data such as the W3C Navigation Timing.
 * @exports performance
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name performance
     * @namespace
     */
    TLT.addModule("performance", function (context) {
        "use strict";

        var moduleState = {
                loadReceived: false,
                unloadReceived: false,
                perfEventSent: false
            },
            calculatedRenderTime = 0;


        /**
         * Returns true if the property is filtered out. The property is considered
         * to be filtered out if it exists in the filter object with a value of true.
         * @private
         * @function
         * @name performance-isFiltered
         * @param {string} prop The property name to be tested.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {boolean} true if the property is filtered out, false otherwise.
         */
        function isFiltered(prop, filter) {
            // Sanity check
            if (typeof prop !== "string") {
                return false;
            }

            // If there is no filter object then the property is not filtered out.
            if (!filter || typeof filter !== "object") {
                return false;
            }

            return (filter[prop] === true);
        }

        /**
         * Returns the normalized timing object. Normalized values are offsets measured
         * from the "navigationStart" timestamp which serves as the epoch. Also applies
         * the filter.
         * @private
         * @function
         * @name performance-parseTiming
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {object} The normalized timing properties.
         */
        function parseTiming(timing, filter) {
            var epoch = 0,
                normalizedTiming = {},
                prop = "",
                value = 0;

            // Sanity checks
            if (!timing || typeof timing !== "object" || !timing.navigationStart) {
                return {};
            }

            epoch = timing.navigationStart;
            for (prop in timing) {
                // IE_COMPAT, FF_COMPAT: timing.hasOwnProperty(prop) returns false for
                // performance timing members in IE 9 and Firefox 14.0.1.

                // IE_COMPAT: timing.hasOwnProperty does not exist in IE8 and lower for
                // host objects. Legacy IE does not support hasOwnProperty on hosted objects.
                if (Object.prototype.hasOwnProperty.call(timing, prop) || typeof timing[prop] === "number") {
                    if (!isFiltered(prop, filter)) {
                        value = timing[prop];
                        if (typeof value === "number" && value && prop !== "navigationStart") {
                            normalizedTiming[prop] = value - epoch;
                        } else {
                            normalizedTiming[prop] = value;
                        }
                    }
                }
            }

            return normalizedTiming;
        }

        /**
         * Calculates the render time from the given timing object.
         * @private
         * @function
         * @name performance-getRenderTime
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @return {integer} The calculated render time or 0.
         */
        function getRenderTime(timing) {
            var renderTime = 0,
                startTime,
                endTime,
                utils = context.utils;

            if (timing) {
                // Use the lesser of domLoading or responseEnd as the start of render, see data in CS-8915
                startTime = (timing.responseEnd > 0 && timing.responseEnd < timing.domLoading) ? timing.responseEnd : timing.domLoading;
                endTime = timing.loadEventStart;
                if (utils.isNumeric(startTime) && utils.isNumeric(endTime) && endTime > startTime) {
                    renderTime = endTime - startTime;
                }
            }

            return renderTime;
        }

        /**
         * Calculates the render time by measuring the difference between when the
         * library core was loaded and when the page load event occurs.
         * @private
         * @function
         * @name performance-processLoadEvent
         * @param  {Object} event The normalized data extracted from a browser event object.
         */
        function processLoadEvent(event) {
            var startTime = context.getStartTime();
            if (event.timestamp > startTime && !calculatedRenderTime) {
                // Calculate the render time
                calculatedRenderTime = event.timestamp - startTime;
            }
        }

        /**
         * Posts the performance event.
         * @private
         * @function
         * @name performance-postPerformanceEvent
         * @param {object} window The DOM window
         */
        function postPerformanceEvent(window) {
            var config = context.getConfig() || {},
                navType = "UNKNOWN",
                queueEvent = {
                    type: 7,
                    performance: {}
                },
                navigation,
                performance,
                timing;

            // Sanity checks
            if (!window || moduleState.perfEventSent) {
                return;
            }

            performance = window.performance || {};
            timing = performance.timing;
            navigation = performance.navigation;

            if (timing) {
                queueEvent.performance.timing = parseTiming(timing, config.filter);
                queueEvent.performance.timing.renderTime = getRenderTime(timing);
            } else if (config.calculateRenderTime) {
                queueEvent.performance.timing = {
                    renderTime: calculatedRenderTime,
                    calculated: true
                };
            } else {
                // Nothing to report.
                return;
            }

            // Do not include renderTime if it is over the threshold.
            if (config.renderTimeThreshold && queueEvent.performance.timing.renderTime > config.renderTimeThreshold) {
                queueEvent.performance.timing.invalidRenderTime = queueEvent.performance.timing.renderTime;
                delete queueEvent.performance.timing.renderTime;
            }

            if (navigation) {
                switch (navigation.type) {
                case 0:
                    navType = "NAVIGATE";
                    break;
                case 1:
                    navType = "RELOAD";
                    break;
                case 2:
                    navType = "BACKFORWARD";
                    break;
                default:
                    navType = "UNKNOWN";
                    break;
                }
                queueEvent.performance.navigation = {
                    type: navType,
                    redirectCount: navigation.redirectCount
                };
            }

            // Invoke the context API to post this event
            context.post(queueEvent);
            // TODO: Remove all instances of perfEventSent flag from this method and localize it's use in the caller?
            moduleState.perfEventSent = true;
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {


            /**
             * Initialize the performance module.
             */
            init: function () {
                // TODO: Possibly add check to see if navigation timing interface is supported. If not, short circuit the implementation below.
            },

            /**
             * Terminate the performance module.
             */
            destroy: function () {

            },

            /**
             * Handle events subscribed by the performance module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                switch (event.type) {
                case "load":
                    moduleState.loadReceived = true;
                    processLoadEvent(event);
                    break;
                case "unload":
                    moduleState.unloadReceived = true;
                    // Force the performance data to be posted (if it hasn't been done already.)
                    if (!moduleState.perfEventSent) {
                        // TODO: Directly referencing the global window but may want to sandbox this.
                        postPerformanceEvent(window);
                    }
                    break;
                default:
                    break;
                }
            },

            /**
             * Handle system messages subscribed by the performance module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            }
        };
    });  // End of TLT.addModule
} else {


}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Replay module implements the logic for monitoring and
 * reporting user interaction data used for replay and usability.
 * @exports replay
 */

/*global TLT:true */

// Sanity check
TLT.addModule("replay", function (context) {
    "use strict";

    var tlTypes = {
    // Keep these sorted for readability.
            "a:": "link",
            "button:button": "button",
            "button:submit": "button",
            "input:button": "button",
            "input:checkbox": "checkBox",
            "input:color": "colorPicker",
            "input:date": "datePicker",
            "input:datetime": "datetimePicker",
            "input:datetime-local": "datetime-local",
            "input:email": "emailInput",
            "input:file": "fileInput",
            "input:image": "image",
            "input:month": "month",
            "input:number": "numberPicker",
            "input:password": "textBox",
            "input:radio": "radioButton",
            "input:range": "slider",
            "input:reset": "resetButton",
            "input:search": "searchBox",
            "input:submit": "submitButton",
            "input:tel": "tel",
            "input:text": "textBox",
            "input:time": "timePicker",
            "input:url": "urlBox",
            "input:week": "week",
            "select:": "selectList",
            "select:select-one": "selectList",
            "textarea:": "textBox",
            "textarea:textarea": "textBox"
        },
        utils = context.utils,
        currOrientation = window.orientation || 0,
        savedTouch = {
            scale: 0,
            timestamp: 0
        },
        pastEvents = {},
        prevHash = window.location.hash,
        lastEventId = null,
        tmpQueue = [],
        eventCounter = 0,
        curClientState = null,
        pastClientState = null,
        errorCount = 0,
        visitOrder = "",
        lastVisit = "",
        pageLoadTime = (new Date()).getTime(),
        pageDwellTime = 0,
        prevWebEvent = null,
        viewEventStart = null,
        viewTimeStart = null,
        scrollViewStart = null,
        scrollViewEnd = null,
        nextScrollViewStart = null,
        viewPortXStart = 0,
        viewPortYStart = 0,
        inBetweenEvtsTimer = null,
        lastFocusEvent = { inFocus: false },
        lastClickEvent = null,
        //TODO move these to a global section due to they might be used elsewhere
        isApple = utils.isiOS,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && utils.isAndroid,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = (window.screen ? window.screen.width : 0),
        deviceOriginalHeight = (window.screen ? window.screen.height : 0),
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        config = context.getConfig(),
        deviceScale = 1,
        previousDeviceScale = 1,
        extendGetItem;

    /**
     * Returns true if the click event changes the target state or is otherwise
     * relevant for the target.
     * @private
     * @param {WebEvent.target} target Webevent target
     * @return {boolean} true if the click event is relevant for the target, false otherwise.
     */
    function isTargetClickable(target) {
        var clickable = false,
            clickableInputTypes = "|button|image|submit|reset|checkbox|radio|",
            subType = null;

        if (typeof target !== "object" || !target.type) {
            return clickable;
        }

        switch (target.type) {
        case "INPUT":
            // Clicks are relevant for button type inputs only.
            subType = "|" + (target.subType || "") + "|";
            if (clickableInputTypes.indexOf(subType.toLowerCase()) === -1) {
                clickable = false;
            } else {
                clickable = true;
            }
            break;
        case "SELECT":
        case "TEXTAREA":
            clickable = false;
            break;
        default:
            // By default, clicks are relevant for all targets.
            clickable = true;
            break;
        }

        return clickable;
    }

    function parentElements(node) {
        var parents = [];
        node = node.parentNode;
        while (node) {
            parents.push(node);
            node = node.parentNode;
        }
        return parents;
    }

    function getParentLink(parents) {
        return context.utils.some(parents, function (node) {
            // Either links or buttons could have content
            if (node.tagName === "A" || node.tagName === "BUTTON") {
                return node;
            }
            return null;
        });
    }

    /**
     * Get the normalized tlEvent from the underlying DOM event and target.
     * @private
     * @param {object} webEvent The normalized webEvent with event and target (control.)
     * @return {string} The normalized value for the tlEvent as per the JSON Logging Data Format.
     */
    function getTlEvent(webEvent) {
        var tlEvent = webEvent.type,
            target = webEvent.target;

        if (typeof tlEvent === "string") {
            tlEvent = tlEvent.toLowerCase();
        } else {
            tlEvent = "unknown";
        }

        if (tlEvent === "blur") {
            tlEvent = "focusout";
        }

        if (tlEvent === "change") {
            if (target.type === "INPUT") {
                switch (target.subType) {
                case "text":
                case "date":
                case "time":
                    // tlEvent is textChange, dateChange or timeChange respectively.
                    tlEvent = target.subType + "Change";
                    break;
                default:
                    // For all other input fields the tlEvent is valueChange.
                    tlEvent = "valueChange";
                    break;
                }
            } else if (target.type === "TEXTAREA") {
                tlEvent = "textChange";
            } else {
                tlEvent = "valueChange";
            }
        }

        return tlEvent;
    }

    /**
     * Invoke the core API to take the DOM capture. If a delay is specified, then
     * schedule a DOM capture.
     * @private
     * @param {DOMElement} root Root element from which the DOM capture snapshot should be taken.
     * @param {object} [config] Configuration options for the capture.
     * @param {Number} [delay] Milliseconds after which to take the DOM snapshot.
     * @return {string} Returns the unique DOM Capture id.
     */
    function scheduleDOMCapture(root, config, delay) {
        var dcid = null;
        // Sanity check
        if (!root) {
            return dcid;
        }
        config = config || {};
        if (delay) {
            dcid = "dcid-" + context.utils.getSerialNumber() + "." + (new Date()).getTime() + "s";
            window.setTimeout(function () {
                config.dcid = dcid;
                context.performDOMCapture(root, config);
            }, delay);
        } else {
            delete config.dcid;
            dcid = context.performDOMCapture(root, config);
        }
        return dcid;
    }

    /**
     * Check the DOM capture rules to see if DOM capture should be triggered for this combination
     * of event, target, screenview as applicable.
     * @private
     * @param {String} eventType Name of the event e.g. click, change, load, unload
     * @param {DOMElement} target The target element of the event. Some events (such as load/unload) may not
     * have a target in which case it would be null.
     * @param {String} [screenviewName] The screenview name for load and unload events.
     * @returns {String} Returns the unique DOM Capture id or null.
     */
    function addDOMCapture(eventType, target, screenviewName) {
        var i,
            capture = false,
            captureConfig,
            dcEnabled = false,
            dcTrigger,
            dcTriggerList,
            dcid = null,
            delay = 0,
            len,
            replayConfig;

        // Sanity check
        if (!eventType || (!target && !screenviewName)) {
            return dcid;
        }
        if (!target && !(eventType === "load" || eventType === "unload")) {
            return dcid;
        }

        replayConfig = context.getConfig() || {};
        dcEnabled = utils.getValue(replayConfig, "domCapture.enabled", false);
        if (!dcEnabled || context.utils.isLegacyIE) {
            // DOM Capture is not supported for IE8 and below
            return dcid;
        }

        dcTriggerList = utils.getValue(replayConfig, "domCapture.triggers") || [];
        for (i = 0, len = dcTriggerList.length; i < len; i += 1) {
            dcTrigger = dcTriggerList[i];
            if (dcTrigger.event === eventType) {
                if (eventType === "load" || eventType === "unload") {
                    if (dcTrigger.screenviews) {
                        capture = (-1 !== utils.indexOf(dcTrigger.screenviews, screenviewName));
                    } else {
                        capture = true;
                    }
                } else {
                    if (dcTrigger.targets) {
                        capture = (-1 !== utils.matchTarget(dcTrigger.targets, target));
                    } else {
                        capture = true;
                    }
                }
            }

            if (capture) {
                // Get the configuration (if any)
                captureConfig = utils.getValue(replayConfig, "domCapture.options", {});
                // Immediate or delayed?
                delay = dcTrigger.delay || 0;

                dcid = scheduleDOMCapture(window.document, captureConfig, delay);
                break;
            }
        }
        return dcid;
    }

    /**
     * Used to create control object from a webEvent.
     * TODO: Move tlType and similar normalization to message service.
     * XXX - Requires review and clean-up.
     * @private
     * @function
     * @name replay-createQueueEvent
     * @param {object} options An object with the following properties:
     *                 webEvent A webEvent that will created into a control.
     *                 id Id of the object.
     *                 prevState Previous state of the object.
     *                 currState Current state of the object.
     *                 visitedCount Visited count of the object.
     *                 dwell Dwell time on the object.
     *                 focusInOffset When you first focused on the object.
     * @return {object} Control object.
     */
    function createQueueEvent(options) {
        var control,
            dcid,
            target        = utils.getValue(options, "webEvent.target", {}),
            targetType    = target.type,
            targetSubtype = target.subType || null,
            tlType        = tlTypes[targetType.toLowerCase() + ":" + targetSubtype] || targetType,
            parents       = parentElements(utils.getValue(target, "element")),
            parentLinkNode = null,
            relXY         = utils.getValue(target, "position.relXY"),
            eventSubtype  = utils.getValue(options, "webEvent.subType", null);

        control = {
            type: 4,
            target: {
                id: target.id || "",
                idType: target.idType,
                name: target.name,
                tlType: tlType,
                type: targetType,
                position: {
                    width: utils.getValue(target, "element.offsetWidth"),
                    height: utils.getValue(target, "element.offsetHeight")
                },
                currState: options.currState || null
            },
            event: {
                tlEvent: getTlEvent(utils.getValue(options, "webEvent")),
                type: utils.getValue(options, "webEvent.type", "UNKNOWN")
            }
        };

        if (targetSubtype) {
            control.target.subType = targetSubtype;
        }

        if (relXY) {
            control.target.position.relXY = relXY;
        }

        if (typeof options.dwell === "number" && options.dwell > 0) {
            control.target.dwell = options.dwell;
        }

        if (typeof options.visitedCount === "number") {
            control.target.visitedCount = options.visitedCount;
        }

        if (typeof options.prevState !== "undefined") {
            control.prevState = options.prevState;
        }

        if (eventSubtype) {
            control.event.subType = eventSubtype;
        }

        // Add usability to config settings
        parentLinkNode = getParentLink(parents);
        control.target.isParentLink = !!parentLinkNode;
        if (parentLinkNode) {
            // Add the parent's href, value and innerText if the actual target doesn't
            // support these properties
            if (parentLinkNode.href) {
                control.target.currState = control.target.currState || {};
                control.target.currState.href = control.target.currState.href || parentLinkNode.href;
            }
            if (parentLinkNode.value) {
                control.target.currState = control.target.currState || {};
                control.target.currState.value = control.target.currState.value || parentLinkNode.value;
            }
            if (parentLinkNode.innerText || parentLinkNode.textContent) {
                control.target.currState = control.target.currState || {};
                control.target.currState.innerText = utils.trim(control.target.currState.innerText || parentLinkNode.innerText || parentLinkNode.textContent);
            }
        }

        if (utils.isUndefOrNull(control.target.currState)) {
            delete control.target.currState;
        }
        if (utils.isUndefOrNull(control.target.name)) {
            delete control.target.name;
        }

        // Check if DOM Capture needs to be triggered for this message.
        // If the event is click then DOM capture is only allowed if the target is click-able
        if (control.event.type !== "click" || isTargetClickable(target)) {
            // Check and add DOM Capture
            dcid = addDOMCapture(control.event.type, target);
            if (dcid) {
                control.dcid = dcid;
            }
        }

        return control;
    }

    function postUIEvent(queueEvent) {
        context.post(queueEvent);
    }


    /**
     * Posts all events from given array to the message service. The input
     * array is cleared on exit from the function.
     * Function additionally consolidates events fired on the same DOM element
     * TODO: Explain the consolidation process. Needs to be refactored!
     * @private
     * @param {Array} queue An array of QueueEvents
     * @return void
     */
    function postEventQueue(queue) {
        var i = 0,
            j,
            len = queue.length,
            e1,
            e2,
            tmp,
            ignoredEvents = {
                mouseout: true,
                mouseover: true
            },
            results = [];

        for (i = 0; i < len; i += 1) {
            e1 = queue[i];
            if (!e1) {
                continue;
            }
            if (ignoredEvents[e1.event.type]) {
                results.push(e1);
            } else {
                for (j = i + 1; j < len && queue[j]; j += 1) {
                    if (!ignoredEvents[queue[j].event.type]) {
                        break;
                    }
                }
                if (j < len) {
                    e2 = queue[j];
                    if (e2 && e1.target.id === e2.target.id && e1.event.type !== e2.event.type) {
                        if (e1.event.type === "click") {
                            tmp = e1;
                            e1 = e2;
                            e2 = tmp;
                        }
                        if (e2.event.type === "click") {
                            e1.target.position = e2.target.position;
                            i += 1;
                        } else if (e2.event.type === "blur") {
                            e1.target.dwell = e2.target.dwell;
                            e1.target.visitedCount = e2.target.visitedCount;
                            e1.focusInOffset = e2.focusInOffset;
                            e1.target.position = e2.target.position;
                            i += 1;
                        }
                        queue[j] = null;
                        queue[i] = e1;
                    }
                }
                results.push(queue[i]);
            }
        }

        for (e1 = results.shift(); e1; e1 = results.shift()) {
            context.post(e1);
        }
        queue.splice(0, queue.length);
    }


    if (typeof window.onerror !== "function") {
        window.onerror = function (msg, url, line) {
            var errorMessage = null;

            if (typeof msg !== "string") {
                return;
            }
            line = line || -1;
            errorMessage = {
                type: 6,
                exception: {
                    description: msg,
                    url: url,
                    line: line
                }
            };

            errorCount += 1;
            context.post(errorMessage);
        };
    }

    /**
     * Handles the focus events. It is fired either when the real focus event take place
     * or right after the click event on an element (only when browser focus event was not fired)
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleFocus(id, webEvent) {
        lastFocusEvent = webEvent;
        lastFocusEvent.inFocus = true;
        if (typeof pastEvents[id] === "undefined") {
            pastEvents[id] = {};
        }

        pastEvents[id].focus = lastFocusEvent.dwellStart = Number(new Date());
        pastEvents[id].focusInOffset = viewTimeStart ? lastFocusEvent.dwellStart - Number(viewTimeStart) : -1;
        pastEvents[id].prevState = utils.getValue(webEvent, "target.state");
        pastEvents[id].visitedCount = pastEvents[id].visitedCount + 1 || 1;
    }

    /**
     * Create and add value that will be posted to queue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function addToTmpQueue(webEvent, id) {
        tmpQueue.push(createQueueEvent({
            webEvent: webEvent,
            id: id,
            currState: utils.getValue(webEvent, "target.state")
        }));
    }

    /**
     * Handles blur events. It is invoked when browser blur events fires or from the
     * handleFocus method (only when browser 'blur' event didn't take place).
     * In the first case it's called with current event details, in the second one -
     * with lastFocusEvent. Method posts the tmpQueue of events. If during the same
     * focus time change event was fired the focus data will be combined together with
     * the last change event from the tmpQueue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleBlur(id, webEvent) {
        var convertToBlur = false,
            dcid,
            lastQueueEvent,
            i = 0;

        if (typeof id === "undefined" || id === null || typeof webEvent === "undefined" || webEvent === null) {
            return;
        }

        lastFocusEvent.inFocus = false;

        if (typeof pastEvents[id] !== "undefined" && pastEvents[id].hasOwnProperty("focus")) {
            pastEvents[id].dwell =  Number(new Date()) - pastEvents[id].focus;
        } else {
            // Blur without any prior event on this control.
            pastEvents[id] = {};
            pastEvents[id].dwell = 0;
        }

        if (tmpQueue.length === 0) {
            // Orphaned blur without any prior event.
            addToTmpQueue(webEvent, id);
        }

        // Visited count is missing 
        if (tmpQueue[tmpQueue.length - 1]) {
            for (i = tmpQueue.length - 1; i >= 0; i--) {
                tmpQueue[i].target.visitedCount = pastEvents[id].visitedCount;
            }
        }

        lastQueueEvent = tmpQueue[tmpQueue.length - 1];
        if (lastQueueEvent) {
            lastQueueEvent.target.dwell = pastEvents[id].dwell;
            lastQueueEvent.focusInOffset = pastEvents[id].focusInOffset;
            lastQueueEvent.target.visitedCount = pastEvents[id].visitedCount;

            // if the click (without generating change event) fires on an
            // input element for which it's not relevant - report event as a blur and update the currState
            if (lastQueueEvent.event.type === "click") {
                if (!isTargetClickable(lastQueueEvent.target)) {
                    lastQueueEvent.target.currState = utils.getValue(webEvent, "target.state");
                    convertToBlur = true;
                }
            } else if (lastQueueEvent.event.type === "focus") {
                convertToBlur = true;
            }

            if (convertToBlur) {
                lastQueueEvent.event.type = "blur";
                lastQueueEvent.event.tlEvent = "focusout";
                // Check if DOM Capture needs to be triggered for this message.
                dcid = addDOMCapture(lastQueueEvent.event.type, webEvent.target);
                if (dcid) {
                    lastQueueEvent.dcid = dcid;
                }
            }
        }

        postEventQueue(tmpQueue);
    }

    /**
     * Checks to see in tmpQueue there is an older control that needs to be posted to server.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return Whether it has been sent to server.
     */
    function checkQueue(id, webEvent) {
        var hasInQueue = false;

        // TODO: Optimize the index by storing tmpQueue.length - 1 into a variable?
        if (tmpQueue.length > 0 && tmpQueue[tmpQueue.length - 1] && tmpQueue[tmpQueue.length - 1].target.id !== id &&
                // iOS scrolls & Android resizes after selecting a textbox
                webEvent.type !== "scroll" && webEvent.type !== "resize" &&
                // mouseover should not affect handleBlur invocation
                webEvent.type !== "mouseout" && webEvent.type !== "mouseover" &&
                // Need focus and click values to complete consolidation of message for these types
                (tmpQueue[tmpQueue.length - 1].target.tlType !== "textBox" &&
                tmpQueue[tmpQueue.length - 1].target.tlType !== "selectList")) {
            handleBlur(tmpQueue[tmpQueue.length - 1].target.id, tmpQueue[tmpQueue.length - 1]);
            hasInQueue = true;
        }
        return hasInQueue;
    }

    /**
     * Handles change and click events. Its called when browser 'change' event fires
     * or together with click event (from 'handleClick' method).
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleChange(id, webEvent) {
        if (typeof pastEvents[id] !== "undefined" && !pastEvents[id].hasOwnProperty("focus")) {
            handleFocus(id, webEvent);
        }

        addToTmpQueue(webEvent, id);

        if (typeof pastEvents[id] !== "undefined" && typeof pastEvents[id].prevState !== "undefined") {
            // TODO: Optimize the index by storing tmpQueue.length - 1 to a variable.
            if (tmpQueue[tmpQueue.length - 1].target.tlType === "textBox" ||
                    tmpQueue[tmpQueue.length - 1].target.tlType === "selectList") {
                tmpQueue[tmpQueue.length - 1].target.prevState = pastEvents[id].prevState;
            }
        }
    }

    /**
     * Sets the relative X & Y values to a webEvent.
     * TODO: Explain how relative X & Y should be calculated (in other words, define relative X & Y)
     * XXX - Shouldn't this be named "get" instead of "set"?
     * @private
     * @param {WebEvent} webEvent Normalized browser event
     * @return String value of relative X & Y
     */
    function setRelativeXY(webEvent) {
        var x = webEvent.target.position.x,
            y = webEvent.target.position.y,
            width = webEvent.target.size.width,
            height = webEvent.target.size.height,
            relX = Math.abs(x / width).toFixed(1),
            relY = Math.abs(y / height).toFixed(1);

        relX = relX > 1 || relX < 0 ? 0.5 : relX;
        relY = relY > 1 || relY < 0 ? 0.5 : relY;

        return relX + "," + relY;
    }

    /**
     * Handles click events. Additionally it recognizes situations when browser didn't
     * fire the focus event and in such case it invokes 'handleFocus' method.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleClick(id, webEvent) {
        var relXY,
            addRelXY = true,
            tmpQueueLength = 0;

        if (webEvent.target.element.tagName === "SELECT" && lastClickEvent && lastClickEvent.target.id === id) {
            lastClickEvent = null;
            return;
        }

        if (!lastFocusEvent.inFocus) {
            handleFocus(id, webEvent);
        }

        // Sometimes the change triggers before the click (observed in Chrome and Android)
        // XXX - Not sure I fully understand this logic - MP
        tmpQueueLength = tmpQueue.length;
        if (tmpQueueLength && utils.getValue(tmpQueue[tmpQueueLength - 1], "event.type") !== "change") {
            handleChange(id, webEvent);
        }

        relXY = setRelativeXY(webEvent);

        // During use of arrow keys to select a radio option, it throws a click event after change event
        // which is incorrect for usability data. We only capture user clicks and not framework clicks.
        tmpQueueLength = tmpQueue.length;

        if (webEvent.position.x === 0 && webEvent.position.y === 0 && tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.tlType") === "radioButton") {
            addRelXY = false;
        } else {
            // For all other cases, record the relXY in the target.position
            webEvent.target.position.relXY = relXY;
        }

        // Update the existing queue entry with relXY info. from the click event
        if (tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.id") === id) {
            if (addRelXY) {
                tmpQueue[tmpQueueLength - 1].target.position.relXY = relXY;
            }
        } else {
            // Else add the click event to the queue
            addToTmpQueue(webEvent, id);
        }

        // XXX - What is lastClickEvent being used for? - MP
        lastClickEvent = webEvent;
    }

    /**
     * Returns the normalized orientation in degrees. Normalized values are measured
     * from the default portrait position which has an orientation of 0. From this
     * position the respective values are as follows:
     * 0   - Portrait orientation. Default
     * -90 - Landscape orientation with screen turned clockwise.
     * 90  - Landscape orientation with screen turned counterclockwise.
     * 180 - Portrait orientation with screen turned upside down.
     * @private
     * @function
     * @name replay-getNormalizedOrientation
     * @param {object} webEvent A normalized event object per the WebEvent
     * @return {integer} The normalized orientation value.
     */
    function getNormalizedOrientation(webEvent) {
        var orientation = 0;
        if (window.orientation) {
            orientation = window.orientation;
        } else if (webEvent !== undefined && webEvent.orientation) {
            orientation = webEvent.orientation;
        }

        // XXX - This functionality should probably be moved into the browser service.
        // TODO: Normalize for Android
        return orientation;
    }


    /**
     * Handles the "orientationchange" event and posts the appropriate message
     * to the replay module's queue.
     * @private
     * @function
     * @name replay-handleOrientationChange
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleOrientationChange(webEvent) {
        var newOrientation = getNormalizedOrientation(webEvent),
            orientationChangeEvent = {
                type: 4,
                event: {
                    type: "orientationchange"
                },
                target: {
                    prevState: {
                        orientation: currOrientation,
                        orientationMode: utils.getOrientationMode(currOrientation)
                    },
                    currState: {
                        orientation: newOrientation,
                        orientationMode: utils.getOrientationMode(newOrientation)
                    }
                }
            };

        postUIEvent(orientationChangeEvent);
        currOrientation = newOrientation;
    }

    /* TODO: Refactor this to use a well-defined touchState object */
    function isDuplicateTouch(touchState) {
        var result = false;

        if (!touchState) {
            return result;
        }

        result = (savedTouch.scale === touchState.scale &&
                Math.abs((new Date()).getTime() - savedTouch.timestamp) < 500);

        return result;
    }

    function saveTouchState(touchState) {
        savedTouch.scale = touchState.scale;
        savedTouch.rotation = touchState.rotation;
        savedTouch.timestamp = (new Date()).getTime();
    }

    /**
     * Takes the scale factor and returns the pinch mode as a text string.
     * Values less than 1 correspond to a pinch close gesture. Values greater
     * than 1 correspond to a pinch open gesture.
     * @private
     * @function
     * @name replay-getPinchType
     * @return {String} "CLOSE", "OPEN" or "NONE" for valid scale values.
     * "INVALID" in case of error.
     */
    function getPinchType() {
        var s,
            pinchType;

        s = deviceScale - previousDeviceScale;
        if (isNaN(s)) {
            pinchType = "INVALID";
        } else if (s < 0) {
            pinchType = "CLOSE";
        } else if (s > 0) {
            pinchType = "OPEN";
        } else {
            pinchType = "NONE";
        }

        return pinchType;
    }


    /**
     * Used to create the client state message from a webEvent.
     * @private
     * @function
     * @name replay-getClientStateMessage
     * @param {object} webEvent A webEvent that will be used to create the clientState.
     * @return {object} Client state message object.
     */
    function getClientStateMessage(webEvent) {
        var documentElement = document.documentElement,
            documentBody = document.body,
            msg = {
                type: 1,
                clientState: {
                    pageWidth: document.width || (!documentElement ? 0 : documentElement.offsetWidth),
                    pageHeight: Math.max((!document.height ? 0 : document.height), (!documentElement ? 0 : documentElement.offsetHeight), (!documentElement ? 0 : documentElement.scrollHeight)),
                    viewPortWidth: window.innerWidth || documentElement.clientWidth,
                    viewPortHeight: window.innerHeight || documentElement.clientHeight,
                    viewPortX: window.pageXOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollLeft) : documentElement.scrollLeft || 0),
                    viewPortY: window.pageYOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollTop) : documentElement.scrollTop || 0),
                    deviceOrientation: window.orientation || 0,
                    event: utils.getValue(webEvent, "type")
                }
            },
            deviceWidth = 1,
            scaleWidth = 1;

        pastClientState = pastClientState || msg;

        if (Math.abs(msg.clientState.deviceOrientation) === 90) {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalHeight - deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalHeight - deviceToolbarHeight : ((deviceOriginalHeight / devicePixelRatio) - deviceToolbarHeight);
            }
        } else {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalWidth + deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalWidth - deviceToolbarHeight : ((deviceOriginalWidth / devicePixelRatio) - deviceToolbarHeight);
            }
        }

        scaleWidth = (msg.clientState.viewPortWidth === 0 ? 1 : deviceWidth / msg.clientState.viewPortWidth);

        // Made scale a bit smaller to adjust for scroll bars that appear on top of content on certain browsers.
        msg.clientState.deviceScale = (scaleWidth - 0.02).toFixed(3);

        // Set the viewTime for this client state
        msg.clientState.viewTime = 0;
        if (scrollViewStart && scrollViewEnd) {
            msg.clientState.viewTime = scrollViewEnd.getTime() - scrollViewStart.getTime();
        }

        if (webEvent.type === "scroll") {
            msg.clientState.viewPortXStart = pastClientState.clientState.viewPortX;
            msg.clientState.viewPortYStart = pastClientState.clientState.viewPortY;
        }

        return msg;
    }

    /**
     * Post the current client state and also record it as pastClientState.
     * Reset the scrollViewStart/End values.
     * @private
     * @function
     * @name replay-sendClientState
     */
    function sendClientState() {
        if (curClientState) {
            postUIEvent(curClientState);
            pastClientState = curClientState;
            curClientState = null;
            scrollViewStart = nextScrollViewStart || scrollViewStart;
            scrollViewEnd = null;
        }
    }

    /**
     * Used to create client state from a webEvent.
     * @private
     * @function
     * @name replay-handleClientState
     * @param {object} webEvent A webEvent that will created into a clientState and saved for previous and current client state.
     * @return {object} Client state object.
     */
    function handleClientState(webEvent) {
        var attentionMsg = null;

        curClientState = getClientStateMessage(webEvent);

        // TODO: Change these if-else to a switch statement
        if (webEvent.type === "scroll" || webEvent.type === "resize") {
            // Set the interval timeout so we can collect related scroll / resize events in one batch
            if (sendClientState.timeoutId) {
                window.clearTimeout(sendClientState.timeoutId);
                sendClientState.timeoutId = 0;
            }
            sendClientState.timeoutId = window.setTimeout(sendClientState, utils.getValue(config, "scrollTimeout", 2000));
        } else if (webEvent.type === "touchstart" || webEvent.type === "load") {
            if (curClientState) {
                // set the initial device scale which is used to determine what type of pinch happened
                previousDeviceScale = parseFloat(curClientState.clientState.deviceScale);
            }
        } else if (webEvent.type === "touchend") {
            if (curClientState) {
                // used to determine what type of pinch happened
                deviceScale = parseFloat(curClientState.clientState.deviceScale);
                // Send client state on touchend
                sendClientState();
            }
        }

        if (webEvent.type === "load" || webEvent.type === "unload") {
            // The "Attention" event is deprecated
            if (webEvent.type === "unload" && pageLoadTime) {
                // Save the "attention" event which is essentially a dup of the unload with viewTime starting from page load.
                attentionMsg = utils.clone(curClientState);
                attentionMsg.clientState.event = "attention";
                attentionMsg.clientState.viewTime = (new Date()).getTime() - pageLoadTime;
            }

            sendClientState();

            if (attentionMsg) {
                // send the attentionMsg
                curClientState = attentionMsg;
                sendClientState();
            }
        }

        return curClientState;
    }

    /**
     * Handles the "touchstart" event, which is only used to get the deviceScale before a pinch
     * @private
     * @function
     * @name replay-handleTouchStart
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchStart(webEvent) {
        var fingerCount = utils.getValue(webEvent, "nativeEvent.touches.length", 0);

        if (fingerCount === 2) {
            handleClientState(webEvent);
        }
    }

    /**
     * Handles the "touchend" event and posts the appropriate message to the
     * replay module's queue.
     * @private
     * @function
     * @name replay-handleTouchEnd
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchEnd(webEvent) {
        var fingerCount,
            prevTouchState = {},
            // Rotation angle for android devices does not work for all devices/browsers
            rotation = utils.getValue(webEvent, "nativeEvent.rotation", 0) || utils.getValue(webEvent, "nativeEvent.touches[0].webkitRotationAngle", 0),
            scale = utils.getValue(webEvent, "nativeEvent.scale", 1),
            touchState = null,
            touchEndEvent = {
                type: 4,
                event: {
                    type: "touchend"
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        // count the number of fingers placed on the screen
        fingerCount = utils.getValue(webEvent, "nativeEvent.changedTouches.length", 0) + utils.getValue(webEvent, "nativeEvent.touches.length", 0);
        if (fingerCount !== 2) {
            return;
        }

        // 1st handle the client state change. This will update the device scale information.
        handleClientState(webEvent);

        // Only post when there are two fingers reported by the touchend event object
        // create the current touchstate
        touchState = {
            rotation: rotation ? rotation.toFixed(2) : 0,
            scale: deviceScale ? deviceScale.toFixed(2) : 1
        };
        touchState.pinch = getPinchType();

        // create the prev touch state
        prevTouchState.scale = previousDeviceScale ? previousDeviceScale.toFixed(2) : 1;

        // Set the curr and prev states
        touchEndEvent.target.prevState = prevTouchState;
        touchEndEvent.target.currState = touchState;

        postUIEvent(touchEndEvent);
    }

    /**
     * Compares two WebEvent's to determine if they are duplicates. Examines
     * the event type, target id and the timestamp to make this determination.
     * XXX - Push this into the browser service or core?!?
     * @private
     * @function
     * @name replay-isDuplicateEvent
     * @param {object} curr A WebEvent object
     * @param {object} prev A WebEvent object
     * @return {boolean} Returns true if the WebEvents are duplicates.
     */
    function isDuplicateEvent(curr, prev) {
        var propsToCompare = ["type", "target.id"],
            prop = null,
            i,
            len,
            duplicate = true,
            DUPLICATE_EVENT_THRESHOLD_TIME = 10,
            timeDiff = 0,
            currTimeStamp = 0,
            prevTimeStamp = 0;

        // Sanity check
        if (!curr || !prev || typeof curr !== "object" || typeof prev !== "object") {
            duplicate = false;
        }

        // Compare WebEvent properties
        for (i = 0, len = propsToCompare.length; duplicate && i < len; i += 1) {
            prop = propsToCompare[i];
            if (utils.getValue(curr, prop) !== utils.getValue(prev, prop)) {
                duplicate = false;
                break;
            }
        }

        if (duplicate) {
            currTimeStamp = utils.getValue(curr, "timestamp");
            prevTimeStamp = utils.getValue(prev, "timestamp");
            // Don't compare if neither objects have a timestamp
            if (!(isNaN(currTimeStamp) && isNaN(prevTimeStamp))) {
                // Check if the event timestamps are within the predefined threshold
                timeDiff = Math.abs(utils.getValue(curr, "timestamp") - utils.getValue(prev, "timestamp"));
                if (isNaN(timeDiff) || timeDiff > DUPLICATE_EVENT_THRESHOLD_TIME) {
                    duplicate = false;
                }
            }
        }

        return duplicate;
    }

    /**
     * Keeps track of the location.hash and logs the appropriate screenview messages
     * when a hash change is detected.
     * @private
     * @function
     * @name replay-trackHashchange
     */
    function trackHashchange() {
        var currHash = window.location.hash;

        if (currHash === prevHash) {
            return;
        }

        // TODO: Expose logScreenview on context so we don't reference TLT
        if (prevHash) {
            // Send the screenview unload
            TLT.logScreenviewUnload(prevHash);
        }

        if (currHash) {
            // Send the screenview load
            TLT.logScreenviewLoad(currHash);
        }

        // Save the current hash value
        prevHash = currHash;
    }


    /**
     * Default handler for event types that are not being processed by the module.
     * @private
     * @function
     * @param {object} webEvent A WebEvent object
     * @name replay-defaultEventHandler
     */
    function defaultEventHandler(webEvent) {
        var msg = {
                type: 4,
                event: {
                    type: webEvent.type
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        postUIEvent(msg);
    }

    return {
        init: function () {
            tmpQueue = [];
        },
        destroy: function () {
            handleBlur(lastEventId);
            tmpQueue = [];
        },
        onevent: function (webEvent) {
            var id = null,
                returnObj = null;

            // Sanity checks
            if (typeof webEvent !== "object" || !webEvent.type) {
                return;
            }

            if (isDuplicateEvent(webEvent, prevWebEvent)) {
                prevWebEvent = webEvent;
                return;
            }

            prevWebEvent = webEvent;


            id = utils.getValue(webEvent, "target.id");

            if (Object.prototype.toString.call(pastEvents[id]) !== "[object Object]") {
                pastEvents[id] = {};
            }

            checkQueue(id, webEvent);
            inBetweenEvtsTimer = new Date();

            switch (webEvent.type) {
            case "hashchange":
                trackHashchange();
                break;
            case "focus":
                returnObj = handleFocus(id, webEvent);
                break;
            case "blur":
                returnObj = handleBlur(id, webEvent);
                break;
            case "click":
                // Normal click processing
                returnObj = handleClick(id, webEvent);
                break;
            case "change":
                returnObj = handleChange(id, webEvent);
                break;
            case "orientationchange":
                returnObj = handleOrientationChange(webEvent);
                break;
			case "touchstart":
				handleTouchStart(webEvent);
				break;
            case "touchend":
                returnObj = handleTouchEnd(webEvent);
                break;
            case "load":
                // initialize the start time for the scrolled view
                scrollViewStart = new Date();

                // send initial clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewLoad("root");

                break;
            case "screenview_load":
                // starts screenview time used for calculating the offset
                viewTimeStart = new Date();

                // Check and add DOM Capture
                returnObj = addDOMCapture("load", null, webEvent.name);

                break;
            case "screenview_unload":
                // Check and add DOM Capture
                returnObj = addDOMCapture("unload", null, webEvent.name);

                break;
            case "resize":
            case "scroll":
                if (!scrollViewEnd) {
                    scrollViewEnd = new Date();
                }
                nextScrollViewStart = new Date();

                handleClientState(webEvent);

                break;
            case "unload":
                // Flush any saved control
                if (tmpQueue !== null) {
                    postEventQueue(tmpQueue);
                }

                // set the final timestamp of this scrolled view.
                scrollViewEnd = new Date();

                // send final clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewUnload("root");

                break;
            default:
                // Call the default handler for all other DOM events
                defaultEventHandler(webEvent);
                break;
            }

            lastEventId = id;
            return returnObj;
        },
        onmessage: function () {
        }
    };
});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SaaS module implements the logic for using Tealeaf in the cloud.
 * @exports saas
 */

/*global TLT:true */

// Sanity check
TLT.addModule("saas", function (context) {
    "use strict";

    /**
     * Sets the SaaS data object to the configuration specified by the user in the config.
     * @private
     */
    var SaasData = function () {
			if (typeof TLT.getCoreConfig().modules.saas !== "undefined") {
				var key;

				for (key in TLT.getCoreConfig().modules.saas) {
					if (TLT.getCoreConfig().modules.saas.hasOwnProperty(key) && typeof key === "string" && typeof TLT.getCoreConfig().modules.saas[key] === "string") {
						this[key] = TLT.getCoreConfig().modules.saas[key];
						document.cookie = key + "=" + this[key];
					}
				}

				/**
				* Gets Tealeaf SaaS session data
				* @function
				* @name saas-saasData.get
				* @param {string} key SaaS session key to get.
				* @return {string} Value associated with the SaaS session key or error description.
				*/
				this.get = function (key) {
					if (typeof key !== "string" || typeof this === "undefined") {
						return "SaaS Data undefined or key is not a string";
					}
					if (typeof this[key] === "undefined") {
						return "Key does not exist within saasData";
					}
					return this[key];
				};

				/**
				* Sets Tealeaf SaaS session data.
				* @function
				* @name saas-saasData.set
				* @param {string} key SaaS session key to be changed or created.
				* @param {string} value SaaS session value to be set.
				* @return {boolean} True if the cookie was set, false if not.
				*/
				this.set = function (key, value) {
					if (typeof key !== "string" || typeof value !== "string" || typeof this === "undefined" || key === "get" || key === "set" || key === "toSaasString" || key === "clear" || key === "remove") {
						return false;
					}
					this[key] = value;
					document.cookie = key + "=" + value;
					return true;
				};

				/**
				* Clears Tealeaf SaaS data.
				* @function
				* @name saas-saasData.clear
				* @returns {void}
				*/
				this.clear = function () {
					var key;
					for (key in this) {
						if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
							document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
							delete this[key];
						}
					}
					return;
				};

				/**
				* Removes a key/value pair from Tealeaf SaaS data.
				* @function
				* @name saas-saasData.remove
				* @returns {void}
				*/
				this.remove = function (key) {
					if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
						document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
						delete this[key];
					}
					return;
				};

				/**
				* Converts Tealeaf SaaS session key/value pairs into a semi-colon separated string
				* @function
				* @name saas-saasData.toString
				* @return {string} Key/value pairs in a semi-colon separated string like "key1=value1;key2=value2..."
				*/
				this.toSaasString = function () {
					var saasDataString = "",
						key;
					for (key in this) {
						if (this.hasOwnProperty(key) && typeof this.get(key) === "string") {
							saasDataString += key + "=" + this.get(key) + ";";
						}
					}
					return saasDataString;
				};
			}
		},
		_saasData = new SaasData();

    // Return the module's interface object. This contains callback functions which
    // will be invoked by the UIC core.
    return {
        init: function () {
            // Attach any custom event handlers here
			TLT.saasData = _saasData;
        },
        destroy: function () {
            // Detach any custom event handlers here
        },
        onevent: function (webEvent) {
            // Process DOM events that you registered in the configuration as
            // per your customized requirements
        }
    };

});
</script>
<script type="text/tljs" id="UIC-SDK-FILE-jQuery-dev">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags jQuery,DEBUG,SUPPORT_LEGACY_HEADERS,ENABLE_LOCALSTORAGE_CAPTURE
 */

/**
 * @fileOverview Defines the core of the system, namely the TLT object.
 * @exports TLT
 */
/*global window*/
/*jshint loopfunc:true*/
/**
 * TLT (short for Tealeaf Technology) is the top-level object for the system. All
 * objects and functions live under TLT to prevent polluting the global
 * scope. This object also manages the modules and services on the page,
 * controlling their lifecycle, manages inter-module communication.
 * @namespace
 */
// Sanity check
if (window.TLT) {
    throw "Attempting to recreate TLT. Library may be included more than once on the page.";
}
var TLT = (function () {

    "use strict";

    /* Create and add a screenview message to the default queue. Also
     * notifies any listeners of the screenview load/unload event.
     * @param {Enum} type "LOAD" or "UNLOAD" indicating the type
     * of screenview event.
     * @param {string} name User friendly name of the screenview.
     * @param {string} [referrerName] Name of the previous screenview that
     * is being replaced.
     * @param {object} [root] DOMNode which represents the root or
     * parent of this screenview. Usually this is a div container.
     * @returns {void}
     */
    function logScreenview(type, name, referrerName, root) {
        var dcid = null,
            screenviewMsg = null,
            queue = TLT.getService("queue"),
            replay = TLT.getModule("replay"),
            webEvent = null,
            winLocation = window.location,
            host = winLocation.origin || null,
            url = winLocation.pathname;

        // Sanity checks
        if (!name || typeof name !== "string") {
            return;
        }
        if (!referrerName || typeof referrerName !== "string") {
            referrerName = "";
        }

        if (!host) {
            host = (winLocation.protocol || "") + "//" + (winLocation.host || "");
        }

        // This is needed for Native hybrid replay to get file path of webview assets used.
        if (host.indexOf("file://") > -1) {
            url = url.replace(/(.*?)(?=\/[^.\/]*\.app)/g, '').replace('.app//', '.app/');
        }

        screenviewMsg = {
            type: 2,
            screenview: {
                type: type,
                name: name,
                url: url,
                host: host,
                referrer: referrerName
            }
        };

        // XXX: Fix this hack. At least send a fully populated WebEvent object.
        // Ideally, want to use the publishEvent to route this to the correct modules.
        if (type === "LOAD") {
            webEvent = {
                type: "screenview_load",
                name: name
            };
        } else if (type === "UNLOAD") {
            webEvent = {
                type: "screenview_unload",
                name: name
            };
        }

        if (webEvent && replay) {
            dcid = replay.onevent(webEvent);
        }

        // If DOM Capture was triggered for this add it to the screenview message.
        if (dcid) {
            screenviewMsg.dcid = dcid;
        }

        if (type === "LOAD" || type === "UNLOAD") {
            queue.post("", screenviewMsg, "DEFAULT");
        }
    }


    var tltStartTime = (new Date()).getTime(),

        /**
         * A collection of module information. The keys in this object are the
         * module names and the values are an object consisting of three pieces
         * of information: the creator function, the instance, and context object
         * for that module.
         * @private
         */
        modules = {},

        /**
         * A collection of service information. The keys in this object are the
         * service names and the values are an object consisting of two pieces
         * of information: the creator function and the service object.
         * @private
         */
        services = {},

        /**
         * Indicates if the core has been initialized or not.
         * @private
         */
        initialized = false,
        state = null,

        /**
         * Checks whether given frame is blacklisted (in the config) or not.
         * @function
         * @private
         * @param {DOMElement} iframe an element to examine
         * @return {boolean} true if given iframe is blacklisted, false otherwise
         */
        isFrameBlacklisted = (function () {
            var blacklistedFrames,
                checkedFrames = [];

            function prepareBlacklistedFrames(scope) {
                var browserService = core.getService("browser"),
                    blacklist = core.getCoreConfig().framesBlacklist,
                    foundFrames,
                    i;
                blacklistedFrames = blacklistedFrames || [];
                scope = scope || null;
                if (typeof blacklist !== "undefined" && blacklist.length > 0) {
                    for (i = 0; i < blacklist.length; i += 1) {
                        foundFrames = browserService.queryAll(blacklist[i], scope);
                        if (foundFrames && foundFrames.length > 0) {
                            blacklistedFrames = blacklistedFrames.concat(foundFrames);
                        }
                    }
                    checkedFrames = checkedFrames.concat(browserService.queryAll('iframe', scope));
                }
            }

            function isFrameBlacklisted(iframe) {
                if (core.utils.indexOf(checkedFrames, iframe) < 0) {
                    prepareBlacklistedFrames(iframe.ownerDocument);
                }
                return core.utils.indexOf(blacklistedFrames, iframe) > -1;
            }

            isFrameBlacklisted.clearCache = function () {
                blacklistedFrames = null;
            };

            return isFrameBlacklisted;
        }()),

        /**
         * Last clicked element, needed for IE and 'beforeunload'
         * @private
         */
        lastClickedElement = null,

        /**
         * List of service passthroughs. These are methods that are called
         * from TLT and simply pass through to the given service without
         * changing the arguments. Doing this dynamically keeps the code
         * smaller and easier to update.
         * @private
         */
        servicePassthroughs = {

            "config": [

                /**
                 * Returns the global configuration object (the one passed to init()).
                 * @name getConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The global configuration object.
                 */
                "getConfig",

                /**
                 * Updates the global configuration object (the one passed to init()).
                 * @name updateConfig
                 * @memberOf TLT
                 * @function
                 * @returns {void}
                 */
                "updateConfig",

                /**
                 * Returns the core configuration object.
                 * @name getCoreConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The core configuration object.
                 */
                "getCoreConfig",

                /**
                 * Updates the core configuration object.
                 * @name updateCoreConfig
                 * @memberOf TLT
                 * @function
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateCoreConfig",

                /**
                 * Returns the configuration object for a module.
                 * @name getModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getModuleConfig",

                /**
                 * Updates a configuration object for a module.
                 * @name updateModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateModuleConfig",

                /**
                 * Returns a configuration object for a service.
                 * @name getServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getServiceConfig",

                /**
                 * Updates a configuration object for a service.
                 * @name updateServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateServiceConfig"

            ],

            "queue": [
                /**
                 * Add HTTP header information to the module's default queue.
                 * This doesn't force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name addHeader
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName  The name of the module saving the header.
                 * @param  {String} headerName  The name of the header.
                 * @param  {String} headerValue The value of the header.
                 * @param  {String} [queueId]   Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "addHeader",
                /**
                 * Send event information to the module's default queue.
                 * This doesn't necessarily force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name post
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName The name of the module saving the event.
                 * @param  {Object} queueEvent The event information to be saved to the queue.
                 * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "post",
                /**
                 * Enable/disable the automatic flushing of all queues.
                 * Either periodically by a timer or whenever the queue threshold is reached.
                 * @name setAutoFlush
                 * @memberOf TLT
                 * @function
                 * @param {Boolean} flag Set this to false to disable flushing
                 *                 or set it to true to enable automatic flushing (default)
                 * @returns {void}
                 */
                "setAutoFlush",
                /**
                 * Forces all queues to send their data to the server.
                 * @name flushAll
                 * @memberOf TLT
                 * @function
                 */
                "flushAll"

            ],

            "browserBase": [
                /**
                 * Calculates the xpath of the given DOM Node.
                 * @name getXPathFromNode
                 * @memberOf TLT
                 * @function
                 * @param {DOMElement} node The DOM node who's xpath is to be calculated.
                 * @returns {String} The calculated xpath.
                 */
                "getXPathFromNode",

                /**
                 * Let the UIC library process a DOM event, which was prevented
                 * from bubbling by the application.
                 * @name processDOMEvent
                 * @memberOf TLT
                 * @function
                 * @param {Object} event The browsers event object which was prevented.
                 */
                "processDOMEvent"
            ]
        },

        /**
         * Provides methods for handling load/unload events to make sure that this
         * kind of events will be handled independently to browser caching mechanism
         * @namespace
         * @private
         */
        loadUnloadHandler = (function () {
            var status = {};

            return {

                /**
                 * Normalizes the events specified in the configuration in the following ways:
                 * - For each load/unload module event adds corresponding pageshow/pagehide event.
                 * - Adds beforeunload
                 * - Adds propertychange if W3C service is being used for correct operation on legacy IE.
                 * @param {String} moduleName Name of the module
                 * @param {Array} moduleEvents An array of module event configs
                 * @param {object} [localTop] Local window element
                 * @param {object} [documentScope] document element
                 */
                normalizeModuleEvents: function (moduleName, moduleEvents, localTop, documentScope) {
                    var load = false,
                        unload = false,
                        browserService = core.getService("browser");

                    localTop = localTop || core._getLocalTop();
                    documentScope = documentScope || localTop.document;

                    status[moduleName] = {
                        loadFired: false,
                        pageHideFired: false
                    };

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        switch (eventConfig.name) {
                        case "load":
                            load = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pageshow"
                            }));
                            break;

                        case "unload":
                            unload = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pagehide"
                            }));
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "beforeunload"
                            }));
                            break;

                        // IE6, IE7 and IE8 - catching 'onpropertychange' event to
                        // simulate correct 'change' events on radio and checkbox.
                        // required for W3C only as jQuery normalizes it.
                        case "change":
                            if (core.utils.isLegacyIE && core.getFlavor() === "w3c") {
                                moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                    name: "propertychange"
                                }));
                            }
                            break;
                        }
                    });
                    if (!load && !unload) {
                        delete status[moduleName];
                        return;
                    }
                    status[moduleName].silentLoad = !load;
                    status[moduleName].silentUnload = !unload;
                    if (!load) {
                        moduleEvents.push({name: "load", target: localTop});
                    }
                    if (!unload) {
                        moduleEvents.push({name: "unload", target: localTop});
                    }
                },

                /**
                 * Checks if event can be published for the module(s) or not.
                 * The negative case can take place for load/unload events only, to avoid
                 * redundancy in handler execution. If as example load event was handled
                 * properly, the pageshow event will be ignored.
                 * @param {string} moduleName Name of the module
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                canPublish: function (moduleName, event) {
                    var mod;
                    if (status.hasOwnProperty(moduleName) === false) {
                        return true;
                    }
                    mod = status[moduleName];
                    switch (event.type) {
                    case "load":
                        mod.pageHideFired = false;
                        mod.loadFired = true;
                        return !mod.silentLoad;
                    case "pageshow":
                        mod.pageHideFired = false;
                        event.type = "load";
                        return !mod.loadFired && !mod.silentLoad;
                    case "pagehide":
                        event.type = "unload";
                        mod.loadFired = false;
                        mod.pageHideFired = true;
                        return !mod.silentUnload;
                    case "unload":
                    case "beforeunload":
                        event.type = "unload";
                        mod.loadFired = false;
                        return !mod.pageHideFired && !mod.silentUnload;
                    }
                    return true;
                },

                /**
                 * Checks if event indicates the core context is unloading.
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                isUnload: function (event) {
                    return typeof event === "object" ?
                            (event.type === "unload" || event.type === "beforeunload" || event.type === "pagehide") :
                            false;
                }
            };

        }()),

        /**
         * Keeps track of the events being handled.
         * @private
         */
        events = {},

        /**
         * Keeps track of callback functions registered by the iOS and Android native libraries.
         * These are used for communication with the native library.
         */
        bridgeCallbacks = {},

        /**
         * init implementation (defined later)
         * @private
         */
        _init = function () {},
        _callback = null,

        /**
         * Flag to track if TLT.init API can been called.
         * @private
         */
        okToCallInit = true,

        // Tracks the inactivity timeout in publishEvent
        inactivityTimerId = null,
        // Placeholder for the inactivity timeout handler, defined after core.
        inactivityTimeoutHandler = function () {},

        // main interface for the core
        core = /**@lends TLT*/ {

            /**
             * Flag for debug builds
             */
            debugMode: true,

            /**
             * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
             */
            getStartTime: function () {
                return tltStartTime;
            },

            //---------------------------------------------------------------------
            // Core Lifecycle
            //---------------------------------------------------------------------

            /**
             * Initializes the system. The configuration information is passed to the
             * config service to management it. All modules are started (unless their
             * configuration information indicates they should be disabled), and web events
             * are hooked up.
             * @param {Object} config The global configuration object.
             * @param {function} [callback] function executed after initialization and destroy
                    the callback function takes one parameter which describes UIC state;
                    its value can be set to "initialized" or "destroyed"
             * @returns {void}
             */
            init: function (config, callback) {
                var timeoutCallback;
                _callback = callback;
                if (!okToCallInit) {
                    throw "init must only be called once!";
                }
                okToCallInit = false;
                timeoutCallback = function (event) {
                    event = event || window.event || {};
                    if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
                        if (document.removeEventListener) {
                            document.removeEventListener("DOMContentLoaded", timeoutCallback, false);
                            window.removeEventListener("load", timeoutCallback, false);
                        } else {
                            document.detachEvent("onreadystatechange", timeoutCallback);
                            window.detachEvent("onload", timeoutCallback);
                        }
                        _init(config, callback);
                    }
                };

                // case when DOM already loaded (lazy-loaded UIC)
                if (document.readyState === "complete") {
                    // Lets the current browser cycle to complete before calling init
                    setTimeout(timeoutCallback);
                } else if (document.addEventListener) {
                    document.addEventListener("DOMContentLoaded", timeoutCallback, false);
                    // A fallback in case DOMContentLoaded is not supported
                    window.addEventListener("load", timeoutCallback, false);
                } else {
                    document.attachEvent("onreadystatechange", timeoutCallback);
                    // A fallback in case onreadystatechange is not supported
                    window.attachEvent("onload", timeoutCallback);
                }
            },

            /**
             * Indicates if the system has been initialized.
             * @returns {Boolean} True if init() has been called, false if not.
             */
            isInitialized: function () {
                return initialized;
            },

            getState: function () {
                return state;
            },

            /**
             * Shuts down the system. All modules are stopped and all web events
             * are unsubscribed.
             * @returns {void}
             */
            // destroy: function (skipEvents, callback) {
            destroy: function (skipEvents) {

                var token = "",
                    eventName = "",
                    target = null,
                    serviceName = null,
                    service = null,
                    browser = null,
                    delegateTarget = false;

                if (okToCallInit) { //nothing to do
                    return false;
                }

                this.stopAll();

                if (!skipEvents) {
                    browser = this.getService("browser");
                    // Unregister events
                    for (token in events) {
                        if (events.hasOwnProperty(token) && browser !== null) {
                            eventName = token.split("|")[0];
                            target = events[token].target;
                            delegateTarget = events[token].delegateTarget || undefined;
                            browser.unsubscribe(eventName, target, this._publishEvent, delegateTarget);
                        }
                    }
                }

                // call destroy on services that have it
                for (serviceName in services) {
                    if (services.hasOwnProperty(serviceName)) {
                        service = services[serviceName].instance;

                        if (service && typeof service.destroy === "function") {
                            service.destroy();
                        }

                        services[serviceName].instance = null;
                    }
                }

                isFrameBlacklisted.clearCache();
                events = {};
                initialized = false;

                // Reset to allow re-initialization.
                okToCallInit = true;

                state = "destroyed";

                if (typeof _callback === "function") {
                    // Protect against unexpected exceptions since _callback is 3rd party code.
                    try {
                        _callback("destroyed");
                    } catch (e) {
                        // Do nothing!
                    }
                }
            },

            /**
             * Iterates over each module and starts or stops it according to
             * configuration information.
             * @returns {void}
             * @private
             */
            _updateModules: function (scope) {

                var config = this.getCoreConfig(),
                    browser = this.getService("browser"),
                    moduleConfig = null,
                    moduleName = null;

                if (config && browser && config.modules) {
                    try {
                        for (moduleName in config.modules) {
                            if (config.modules.hasOwnProperty(moduleName)) {
                                moduleConfig = config.modules[moduleName];

                                if (modules.hasOwnProperty(moduleName)) {
                                    if (moduleConfig.enabled === false) {
                                        this.stop(moduleName);
                                        continue;
                                    }

                                    this.start(moduleName);

                                    // If the module has specified events in the configuration
                                    // register event handlers for them.
                                    if (moduleConfig.events) {
                                        this._registerModuleEvents(moduleName, moduleConfig.events, scope);
                                    }
                                } else {    // it needs to be loaded
                                    if (browser.loadScript) {
                                        browser.loadScript(config.moduleBase + moduleName + ".js");
                                        // no callback needed because the module will start automatically
                                    }
                                }
                            }
                        }
                        this._registerModuleEvents.clearCache();
                    } catch (e) {
                        core.destroy();
                        return false;
                    }
                } else {
                    return false;
                }
                return true;
            },

            /**
             * Registers event handlers for all modules in a specific scope.
             * E.g. if the application changed the DOM via ajax and want to let
             * us rebind event handlers in this scope.
             * @param  {Object} scope A DOM element as a scope.
             */
            rebind: function (scope) {
                core._updateModules(scope);
            },

            /* Public API which returns the Tealeaf session data that has been
             * configured to be shared with 3rd party scripts.
             * @returns {object} JSON object containing the session data as
             * name-value pairs. If no data is available then returns null.
             */
            getSessionData: function () {

                if (!core.isInitialized()) {
                    throw "getSessionData API was called before UIC is initialized.";
                }

                var rv = null,
                    sessionData = null,
                    scName,
                    scValue,
                    config = core.getCoreConfig();

                if (!config || !config.sessionDataEnabled) {
                    return null;
                }

                sessionData = config.sessionData || {};

                // Add any session ID data
                scName = sessionData.sessionQueryName;
                if (scName) {
                    scValue = core.utils.getQueryStringValue(scName, sessionData.sessionQueryDelim);
                } else {
                    // Either the cookie name is configured or the default is assumed.
                    scName = sessionData.sessionCookieName || "TLTSID";
                    scValue = core.utils.getCookieValue(scName);
                }

                if (scName && scValue) {
                    rv = rv || {};
                    rv.tltSCN = scName;
                    rv.tltSCV = scValue;
                    rv.tltSCVNeedsHashing = !!sessionData.sessionValueNeedsHashing;
                }

                return rv;
            },

            /* Public API to create and add a custom event message to the default
             * queue.
             * @param {string} name Name of the custom event.
             * @param {object} customObj Custom object which will be serialized
             * to JSON and included with the custom message.
             * @returns {void}
             */
            logCustomEvent: function (name, customMsgObj) {

                if (!core.isInitialized()) {
                    throw "logCustomEvent API was called before UIC is initialized.";
                }

                var customMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!name || typeof name !== "string") {
                    name = "CUSTOM";
                }
                customMsgObj = customMsgObj || {};

                customMsg = {
                    type: 5,
                    customEvent: {
                        name: name,
                        data: customMsgObj
                    }
                };
                queue.post("", customMsg, "DEFAULT");
            },

            /* Public API to create and add an exception event message to the
             * default queue.
             * @param {string} msg Description of the error or exception.
             * @param {string} [url] URL related to the error or exception.
             * @param {integer} [line] Line number associated with the error or exception.
             * @returns {void}
             */
            logExceptionEvent: function (msg, url, line) {

                if (!core.isInitialized()) {
                    throw "logExceptionEvent API was called before UIC is initialized.";
                }

                var exceptionMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!msg || typeof msg !== "string") {
                    return;
                }
                url = url || "";
                line = line || "";

                exceptionMsg = {
                    type: 6,
                    exception: {
                        description: msg,
                        url: url,
                        line: line
                    }
                };

                queue.post("", exceptionMsg, "DEFAULT");
            },

            /* Public API to create and add a screenview LOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * being loaded. Note: The same name must be used when the screenview
             * UNLOAD API is called.
             * @param {string} [referrerName] Name of the previous screenview that
             * is being replaced.
             * @param {object} [root] DOMNode which represents the root or
             * parent of this screenview. Usually this is a div container.
             * @returns {void}
             */
            logScreenviewLoad: function (name, referrerName, root) {

                if (!core.isInitialized()) {
                    throw "logScreenviewLoad API was called before UIC is initialized.";
                }

                logScreenview("LOAD", name, referrerName, root);
            },

            /* Public API to create and add a screenview UNLOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * unloaded. Note: This should be the same name used in the screenview
             * LOAD API.
             * @returns {void}
             */
            logScreenviewUnload: function (name) {

                if (!core.isInitialized()) {
                    throw "logScreenviewUnload API was called before UIC is initialized.";
                }

                logScreenview("UNLOAD", name);
            },

            /* Public API to log a DOM Capture message to the default queue.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            logDOMCapture: function (root, config) {
                var dcid = null,
                    domCaptureData,
                    domCaptureService,
                    msg,
                    queue;

                if (!this.isInitialized()) {
                    throw "logDOMCapture API was called before UIC is initialized.";
                }

                // DOM Capture is not supported on IE 8 and below
                if (core.utils.isLegacyIE) {
                    return dcid;
                }

                domCaptureService = this.getService("domCapture");
                if (domCaptureService) {
                    root = root || window.document;
                    config = config || {};
                    domCaptureData = domCaptureService.captureDOM(root, config);
                    if (domCaptureData) {
                        // Add the unique id for this DOM Capture message
                        dcid = config.dcid || ("dcid-" + this.utils.getSerialNumber() + "." + (new Date()).getTime());
                        domCaptureData.dcid = dcid;
                        // Create the message
                        msg = {
                            "type": 12,
                            "domCapture": domCaptureData
                        };
                        // POST it to the queue
                        queue = this.getService("queue");
                        queue.post("", msg, "DEFAULT");
                    } else {
                        dcid = null;
                    }
                }
                return dcid;
            },

            /* Function invoked by modules to log a DOM Capture message to the default queue.
             * @param {String} moduleName Name of the module which invoked this function.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            performDOMCapture: function (moduleName, root, config) {
                return this.logDOMCapture(root, config);
            },

            /**
             * Helper function for registerBridgeCallbacks
             * It checks if the call back type is valid and enabled.
             * @function
             * @private
             * @param {String}
             * @returns {boolean} Whether callback type is enabled.
             */
            _bridgeCallback: function (cbType) {
                var callBackType = bridgeCallbacks[cbType];

                if (callBackType && callBackType.enabled) {
                    return callBackType;
                }
                return null;
            },

            /**
             * Public API to add a screenshot capture. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            logScreenCapture: function () {
                if (!core.isInitialized()) {
                    throw "logScreenCapture API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("screenCapture");
                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to enable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            enableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    throw "enableTealeafFramework API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("enableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to disable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            disableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    throw "disableTealeafFramework API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("disableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start a new Tealeaf session. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            startNewTLFSession: function () {
                if (!core.isInitialized()) {
                    throw "startNewTLFSession API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("startNewTLFSession");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start get current Tealeaf session Id. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {String} Current session Id
             */
            currentSessionId: function () {
                if (!core.isInitialized()) {
                    throw "currentSessionId API was called before UIC is initialized.";
                }
                var sessionId,
                    bridgeCallback = core._bridgeCallback("currentSessionId");

                if (bridgeCallback !== null) {
                    sessionId = bridgeCallback.cbFunction();
                }
                return sessionId;
            },

            /**
             * Public API to get default value of a configurable item in
             * TLFConfigurableItems.properties file.  This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            defaultValueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    throw "defaultValueForConfigurableItem API was called before UIC is initialized.";
                }
                var value,
                    bridgeCallback = core._bridgeCallback("defaultValueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to get the value of a configurable item either from TLFConfigurableItems.properties file
             * or in memory data structure. This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            valueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    throw "valueForConfigurableItem API was called before UIC is initialized.";
                }
                var value,
                    bridgeCallback = core._bridgeCallback("valueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to set the value of a configurable item in TLFConfigurableItems.properties file.
             * This updates only in the memory value. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            setConfigurableItem: function (configItem, value) {
                if (!core.isInitialized()) {
                    throw "setConfigurableItem API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("setConfigurableItem");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(configItem, value);
                }
                return result;
            },

            /**
             * Public API to add additional http header.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} key This is the key of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            addAdditionalHttpHeader: function (key, value) {
                if (!core.isInitialized()) {
                    throw "addAdditionalHttpHeader API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("addAdditionalHttpHeader");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(key, value);
                }
                return result;
            },

            /**
             * Public API to log custom event.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} eventName A custom event name.
             * @param {String} jsonData JSON data string.
             * @param {int} logLevel Tealeaf library logging level for the event.
             * @returns {boolean} Wether item was set.
             */
            logCustomEventBridge: function (eventName, jsonData, logLevel) {
                if (!core.isInitialized()) {
                    throw "logCustomEventBridge API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("logCustomEventBridge");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(eventName, jsonData, logLevel);
                }
                return result;
            },

            /**
             * Public API to allow registration of callback functions
             * These callback types are supported currently:
             * 1. screenCapture: Registering this type enables ability to
             *    take screenshots from script.
             * 2. messageRedirect: Registering this type will allow the
             *    callback function to process (and consume) the message
             *    instead of being handled by the default queue.
             * 3. addRequestHeaders: Registering this type will allow the
             *    callback function to return an array of HTTP request headers
             *    that will be set by the UIC in it's requests to the target.
             * @param {Array} callbacks Array of callback objects. Each object
             *                is of the format: {
             *                    {boolean}  enabled
             *                    {string}   cbType
             *                    {function} cbFunction
             *                }
             *                If the callbacks array is empty then any previously
             *                registered callbacks would be removed.
             * @returns {boolean} true if callbacks were registered. false otherwise.
             */
            registerBridgeCallbacks: function (callbacks) {
                var i = 0,
                    len = 0,
                    cb = null;

                // Sanity check
                if (!callbacks) {
                    return false;
                }
                if (callbacks.length === 0) {
                    // Reset any previously registered callbacks.
                    bridgeCallbacks = {};
                    return false;
                }
                try {
                    for (i = 0, len = callbacks.length; i < len; i += 1) {
                        cb = callbacks[i];
                        if (typeof cb === "object" && cb.cbType && cb.cbFunction) {
                            bridgeCallbacks[cb.cbType] = {
                                enabled: cb.enabled,
                                cbFunction: cb.cbFunction
                            };
                        }
                    }
                } catch (e) {
                    return false;
                }
                return true;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the queue to be redirected if a messageRedirect callback
             * has been registered. (see registerBridgeCallbacks)
             * @param {array} queue The queue array containing the individual
             *                message objects.
             * @returns {array} The array that should replace the previously
             *                  passed queue.
             */
            redirectQueue: function (queue) {
                var i,
                    len,
                    cb,
                    retval,
                    sS;

                // Sanity check
                if (!queue || !queue.length) {
                    return queue;
                }

                cb = bridgeCallbacks.messageRedirect;
                if (cb && cb.enabled) {
                    sS = core.getService("serializer");
                    for (i = 0, len = queue.length; i < len; i += 1) {
                        retval = cb.cbFunction(sS.serialize(queue[i]), queue[i]);
                        if (retval && typeof retval === "object") {
                            queue[i] = retval;
                        } else {
                            queue.splice(i, 1);
                            i -= 1;
                            len = queue.length;
                        }
                    }
                }
                return queue;
            },

            _hasSameOrigin: function (iframe) {
                try {
                    return iframe.document.location.host === document.location.host && iframe.document.location.protocol === document.location.protocol;
                } catch (e) {
                    // to be ignored. Error when iframe from different domain
                    //#ifdef DEBUG
                    //TODO add debug log
                    //#endif
                }
                return false;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the addRequestHeaders callback (if registered) to be invoked.
             * (see registerBridgeCallbacks)
             * @returns {array} The array of request headers to be set. Each
             *                  object is of the format:
             *                  {
             *                      name: "header name",
             *                      value: "header value",
             *                      recurring: true
             *                  }
             */
            provideRequestHeaders: function () {
                var headers = null,
                    addHeadersCB = bridgeCallbacks.addRequestHeaders;

                if (addHeadersCB && addHeadersCB.enabled) {
                    headers = addHeadersCB.cbFunction();
                }

                return headers;
            },

            /**
             * Utility function used by core._updateModules.
             * It registers event listners according to module configuration.
             * @name core._registerModuleEvents
             * @function
             * @param {string} moduleName name of the module
             * @param {Array} moduleEvents an array of all module-specific events (from UIC configuration)
             * @param {object} scope DOM element where event will be registered; points either to a main window
             *                 object or to IFrame's content window
             */
            _registerModuleEvents: (function () {

                /**
                 * An instance of core.utils.WeakMap us as a cache for mapping DOM elements with their IDs.
                 * Introduced to reduce number of expensive browserBase.ElementData.prototype.examineID calls.
                 * Object initialization in _registerModuleEvents function
                 * @private
                 * @type {object}
                 */
                var idCache,
                    /**
                     * Helper function that returns the localTop or documentScope object if the
                     * specified prop is "window" or "document" respectively.
                     * @private
                     * @function
                     * @param {string|object} prop
                     * @param {object} localTop
                     * @param {object} documentScope
                     * @returns {string|object} localTop if prop value is "window",
                     *                          documentScope if prop value is "document" else
                     *                          returns the prop value itself
                     */
                    normalizeToObject = function (prop, localTop, documentScope) {
                        if (prop === "window") {
                            return localTop;
                        }
                        if (prop === "document") {
                            return documentScope;
                        }
                        return prop;
                    };

                /**
                 * Helper function for core._registerModuleEvents
                 * It does actual event listeners registration, while the main function managesthe scopes.
                 * @function
                 * @private
                 */
                function _registerModuleEventsOnScope(moduleName, moduleEvents, scope) {
                    var browserBase = core.getService("browserBase"),
                        browser = core.getService("browser"),
                        documentScope = core.utils.getDocument(scope),
                        localTop = core._getLocalTop(),
                        isFrame = core.utils.isIFrameDescendant(scope),
                        frameId,
                        e,
                        i;

                    scope = scope || documentScope;
                    loadUnloadHandler.normalizeModuleEvents(moduleName, moduleEvents, localTop, documentScope);

                    if (isFrame) {
                        frameId = browserBase.ElementData.prototype.examineID(scope).id;
                        // remove one closing ']'
                        if (typeof frameId === "string") {
                            frameId = frameId.slice(0, frameId.length - 1);
                            for (e in events) {
                                if (events.hasOwnProperty(e)) {
                                    for (i = 0; i < events[e].length; i += 1) {
                                        if (moduleName === events[e][i]) {
                                            if (e.indexOf(frameId) !== -1) {
                                                delete events[e];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        var target = normalizeToObject(eventConfig.target, localTop, documentScope) || documentScope,
                            delegateTarget = normalizeToObject(eventConfig.delegateTarget, localTop, documentScope),
                            token = "";

                        if (eventConfig.recurseFrames !== true && isFrame) {
                            return;
                        }

                        // If the target is a string it is a CSS query selector, specified in the config.
                        if (typeof target === "string") {
                            if (eventConfig.delegateTarget && core.getFlavor() === "jQuery") {
                                token = core._buildToken4delegateTarget(eventConfig.name, target, eventConfig.delegateTarget);

                                if (!events.hasOwnProperty(token)) {
                                    events[token] = [moduleName];
                                    events[token].target = target;
                                    events[token].delegateTarget = delegateTarget;
                                    browser.subscribe(eventConfig.name, target, core._publishEvent, delegateTarget, token);
                                } else {
                                    events[token].push(moduleName);
                                }
                            } else {
                                core.utils.forEach(browser.queryAll(target, scope), function (element) {
                                    var idData = idCache.get(element);
                                    if (!idData) {
                                        idData = browserBase.ElementData.prototype.examineID(element);
                                        idCache.set(element, idData);
                                    }
                                    token = eventConfig.name + "|" + idData.id + idData.type;
                                    // If the token already exists, do nothing
                                    if (core.utils.indexOf(events[token], moduleName) !== -1) {
                                        return;
                                    }
                                    events[token] = events[token] || [];
                                    events[token].push(moduleName);
                                    // Save a reference to the tokens target to be able to unregister it later.
                                    events[token].target = element;
                                    browser.subscribe(eventConfig.name, element, core._publishEvent);
                                });
                            }
                        // Else: The target, specified in the config, is an object or empty
                        // (defaults to document), generate a token for events which bubble up
                        // (to the window or document object).
                        } else {
                            token = core._buildToken4bubbleTarget(eventConfig.name, target, typeof eventConfig.target === "undefined");
                            if (!events.hasOwnProperty(token)) {
                                events[token] = [moduleName];
                                browser.subscribe(eventConfig.name, target, core._publishEvent);
                            } else {
                                /* XXX: Only add if module entry doesn't exist. */
                                if (core.utils.indexOf(events[token], moduleName) === -1) {
                                    events[token].push(moduleName);
                                }
                            }
                        }

                        if (token !== "") {
                            if (typeof target !== "string") {
                                events[token].target = target;
                            }
                        }
                    });
                }

                /**
                 * Helper function for core._registerModuleEvents. Checks load status of iframes.
                 * @function
                 * @private
                 * @returns {boolean} true when given frame is completely loaded; false otherwise
                 */
                function _isFrameLoaded(hIFrame) {
                    var iFrameWindow = core.utils.getIFrameWindow(hIFrame);
                    return (iFrameWindow !== null) &&
                            core._hasSameOrigin(iFrameWindow) &&
                            (iFrameWindow.document !== null) &&
                            iFrameWindow.document.readyState === "complete";
                }

                // actual implementation of core._registerModuleEvents
                function registerModuleEvents(moduleName, moduleEvents, scope) {
                    scope = scope || core._getLocalTop().document;
                    idCache = idCache || new core.utils.WeakMap();

                    _registerModuleEventsOnScope(moduleName, moduleEvents, scope);
                    if (moduleName !== "performance") {
                        var hIFrame = null,
                            hIFrameWindow = null,
                            browserService = core.getService("browser"),
                            cIFrames = browserService.queryAll("iframe, frame", scope),
                            i,
                            iLength;

                        for (i = 0, iLength = cIFrames.length; i < iLength; i += 1) {
                            hIFrame = cIFrames[i];
                            if (isFrameBlacklisted(hIFrame)) {
                                continue;
                            }
                            if (_isFrameLoaded(hIFrame)) {
                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                            }

                            (function (moduleName, moduleEvents, hIFrame) {
                                var hIFrameWindow = null,
                                    _iframeContext = {
                                        moduleName: moduleName,
                                        moduleEvents: moduleEvents,
                                        hIFrame: hIFrame,

                                        _registerModuleEventsDelayed: function () {
                                            var hIFrameWindow = null;

                                            if (!isFrameBlacklisted(hIFrame)) {
                                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                                if (core._hasSameOrigin(hIFrameWindow)) {
                                                    core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                                                }
                                            }
                                        }
                                    };

                                core.utils.addEventListener(hIFrame, "load", function () {
                                    _iframeContext._registerModuleEventsDelayed();
                                });

                                if (core.utils.isLegacyIE && _isFrameLoaded(hIFrame)) {
                                    hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                    core.utils.addEventListener(hIFrameWindow.document, "readystatechange", function () {
                                        _iframeContext._registerModuleEventsDelayed();
                                    });
                                }

                            }(moduleName, moduleEvents, hIFrame));
                        }
                    }
                }

                registerModuleEvents.clearCache = function () {
                    if (idCache) {
                        idCache.clear();
                        idCache = null;
                    }
                };

                return registerModuleEvents;
            }()), // end of _registerModuleEvents factory


            /**
             * Build the token for an event using the currentTarget of the event
             * (only if the current browser supports currenTarget) Otherwise uses
             * the event.target
             * @param  {Object} event The WebEvent
             * @return {String}       Returns the token as a string, consist of:
             *         eventType | target id target idtype
             */
            _buildToken4currentTarget: function (event) {
                var target = event.nativeEvent ? event.nativeEvent.currentTarget : null,
                    idData = target ? this.getService("browserBase").ElementData.prototype.examineID(target) :
                            {
                                id: event.target.id,
                                type: event.target.idType
                            };
                return event.type + "|" + idData.id + idData.type;
            },

            /**
             * Build the token for delegate targets
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | target | delegateTarget
             */
            _buildToken4delegateTarget: function (eventType, target, delegateTarget) {
                return eventType + "|" + target + "|" + delegateTarget;
            },

            /**
             * Build the token for bubble targets (either window or document)
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | null-2 | window or document
             */
            _buildToken4bubbleTarget: function (eventType, target, checkIframe, delegateTarget) {
                var localTop = core._getLocalTop(),
                    localWindow,
                    browserService = core.getService("browser"),
                    _getIframeElement = function (documentScope) {
                        var retVal = null;

                        if (core._hasSameOrigin(localWindow.parent)) {
                            core.utils.forEach(browserService.queryAll("iframe, frame", localWindow.parent.document), function (iframe) {
                                var iFrameWindow = null;

                                if (!isFrameBlacklisted(iframe)) {
                                    iFrameWindow = core.utils.getIFrameWindow(iframe);
                                    if (core._hasSameOrigin(iFrameWindow) && iFrameWindow.document === documentScope) {
                                        retVal = iframe;
                                    }
                                }
                            });
                        }
                        return retVal;
                    },
                    documentScope = core.utils.getDocument(target),
                    browserBase = this.getService("browserBase"),
                    iframeElement = null,
                    tmpTarget,
                    retVal = eventType,
                    idData;

                if (documentScope) {
                    localWindow = documentScope.defaultView || documentScope.parentWindow;
                }

                if (target === window || target === window.window) {
                    retVal += "|null-2|window";
                } else {
                    if (checkIframe && localWindow && core._hasSameOrigin(localWindow.parent) && typeof documentScope !== "undefined" && localTop.document !== documentScope) {
                        iframeElement = _getIframeElement(documentScope);
                        if (iframeElement) {
                            tmpTarget = browserBase.ElementData.prototype.examineID(iframeElement);
                            retVal += "|" + tmpTarget.xPath + "-2";
                        }
                    } else if (delegateTarget && delegateTarget !== document && core.getFlavor() === "jQuery") {
                        // NOTE: elegateTarget !== document  --- because simple jQuery.on has delegateTarget set to document
                        // for event defined without target e.g. { name: "click", recurseFrame: true }
                        retVal += "|null-2|" + core.utils.getTagName(target) + "|" + core.utils.getTagName(delegateTarget);
                    } else {
                        retVal += "|null-2|document";
                    }
                }

                return retVal;
            },

            /**
             * Event handler for when configuration gets updated.
             * @returns {void}
             * @private
             */
            _reinitConfig: function () {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.
                core._updateModules();
            },

            /**
             * Iterates over each module delivers the event object if the module
             * is interested in that event.
             * @param {Event} event An event object published by the browser service.
             * @returns {void}
             * @private
             */
            _publishEvent: function (event) {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.

                var moduleName = null,
                    module = null,
                    // generate the explicit token for the element which received the event
                    // if event is delegated it will have event.data set to the token
                    token = (event.delegateTarget && event.data) ? event.data : core._buildToken4currentTarget(event),
                    modules = null,
                    i,
                    len,
                    target,
                    modEvent = null,
                    canIgnore = false,
                    canPublish = false,
                    coreConfig = core.getCoreConfig(),
                    browserService = core.getService("browser"),
                    delegateTarget = event.delegateTarget || null;

                // Reset the inactivity timer
                if (inactivityTimerId) {
                    clearTimeout(inactivityTimerId);
                }
                // Set inactivity timeout with default of 10 minutes.
                inactivityTimerId = setTimeout(inactivityTimeoutHandler, core.utils.getValue(coreConfig, "inactivityTimeout", 600000));

                // ignore native browser 'load' events
                if ((event.type === "load" || event.type === "pageshow") && !event.nativeEvent.customLoad) {
                    return;
                }

                // IE only: ignore 'beforeunload' fired by link placed in blacklist of excluded links
                if (core.utils.isIE) {
                    if (event.type === "click") {
                        lastClickedElement = event.target.element;
                    }
                    if (event.type === "beforeunload") {
                        canIgnore = false;
                        core.utils.forEach(coreConfig.ieExcludedLinks, function (selector) {
                            var i,
                                len,
                                el = browserService.queryAll(selector);

                            for (i = 0, len = el ? el.length : 0; i < len; i += 1) {
                                if (typeof el[i] !== undefined && el[i] === lastClickedElement) {
                                    // Last clicked element was in the blacklist. Set the ignore flag.
                                    canIgnore = true;
                                    return;
                                }
                            }
                        });

                        if (canIgnore) {
                            // The beforeunload can be ignored.
                            return;
                        }
                    }
                }

                // if an unload event is triggered update the core's internal state to "unloading"
                if (loadUnloadHandler.isUnload(event)) {
                    state = "unloading";
                }

                // ignore native browser 'change' events on IE<9/W3C for radio buttons and checkboxes
                if (event.type === "change" && core.utils.isLegacyIE && core.getFlavor() === "w3c" &&
                        (event.target.element.type === "checkbox" || event.target.element.type === "radio")) {
                    return;
                }

                // use 'propertychange' event in IE<9 to simulate 'change' event on radio and checkbox
                if (event.type === "propertychange") {
                    if (event.nativeEvent.propertyName === "checked" && (event.target.element.type === "checkbox" || (event.target.element.type === "radio" && event.target.element.checked))) {
                        event.type = "change";
                        event.target.type = "INPUT";
                    } else {
                        return;
                    }
                }

                // No module has registered the event for the currentTarget,
                // build token for bubble target (document or window)
                if (!events.hasOwnProperty(token)) {
                    if (event.hasOwnProperty("nativeEvent")) {
                        target = event.nativeEvent.currentTarget || event.nativeEvent.target;
                    }
                    token = core._buildToken4bubbleTarget(event.type, target, true, delegateTarget);
                }

                if (events.hasOwnProperty(token)) {
                    modules = events[token];
                    for (i = 0, len = modules.length; i < len; i += 1) {
                        moduleName = modules[i];
                        module = core.getModule(moduleName);
                        modEvent = core.utils.mixin({}, event);
                        if (module && core.isStarted(moduleName) && typeof module.onevent === "function") {
                            canPublish = loadUnloadHandler.canPublish(moduleName, modEvent);
                            if (canPublish) {
                                module.onevent(modEvent);
                            }
                        }
                    }
                }

                if (modEvent && modEvent.type === "unload" && canPublish) {
                    core.destroy();
                }

            },

            _getLocalTop: function () {
                // Return window.window instead of window due to an IE quirk where (window == top) is true but (window === top) is false
                // In such cases, (window.window == top) is true and so is (window.window === top)  Hence window.window is more reliable
                // to compare to see if the library is included in the top window.
                return window.window;
            },

            //---------------------------------------------------------------------
            // Module Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a module creator with TLT.
             * @param {String} moduleName The name of the module that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the module.
             * @returns {void}
             */
            addModule: function (moduleName, creator) {

                if (modules.hasOwnProperty(moduleName)) {
                    throw new Error("Attempting to add duplicate module '" + moduleName +
                            "' on TLT.");
                }

                modules[moduleName] = {
                    creator: creator,
                    instance: null,
                    context: null,
                    messages: []
                };

                // If the core is initialized, then this module has been dynamically loaded. Start it.
                if (this.isInitialized()) {
                    this.start(moduleName);
                }
            },

            /**
             * Returns the module instance of the given module.
             * @param {String} moduleName The name of the module to retrieve.
             * @returns {Object} The module instance if it exists, null otherwise.
             */
            getModule: function (moduleName) {
                if (modules[moduleName] && modules[moduleName].instance) {
                    return modules[moduleName].instance;
                }
                return null;
            },

            /**
             * Unregisters a module and stops and destroys its instance.
             * @param {String} moduleName The name of the module to remove.
             * @returns {void}
             */
            removeModule: function (moduleName) {

                this.stop(moduleName);
                delete modules[moduleName];
            },

            /**
             * Determines if a module is started by looking for the instance.
             * @param {String} moduleName The name of the module to check.
             * @returns {void}
             */
            isStarted: function (moduleName) {
                return modules.hasOwnProperty(moduleName) && modules[moduleName].instance !== null;
            },

            /**
             * Creates a new module instance and calls it's init() method.
             * @param {String} moduleName The name of the module to start.
             * @returns {void}
             */
            start: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                if (!modules.hasOwnProperty(moduleName)) {
                    throw new Error("Attempting to start nonexistent module '" + moduleName +
                            "' on TLT.");
                }

                // Only continue if the module data exists and there's not already an instance
                if (moduleData && moduleData.instance === null) {

                    // create the context and instance
                    moduleData.context = new TLT.ModuleContext(moduleName, this);
                    instance = moduleData.instance = moduleData.creator(moduleData.context);

                    // allow module to initialize itself
                    if (typeof instance.init === "function") {
                        instance.init();
                    }

                }
            },

            /**
             * Starts all registered modules, creating an instance and calling their
             * init() methods.
             * @returns {void}
             */
            startAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.start(moduleName);
                    }
                }
            },

            /**
             * Stops a module, calls it's destroy() method, and deletes the instance.
             * @param {String} moduleName The name of the module to stop.
             * @returns {void}
             */
            stop: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                // Only continue if the module instance exists
                if (moduleData && moduleData.instance !== null) {

                    instance = moduleData.instance;

                    // allow module to clean up after itself
                    if (typeof instance.destroy === "function") {
                        instance.destroy();
                    }

                    moduleData.instance = moduleData.context = null;

                }
            },

            /**
             * Stops all registered modules, calling their destroy() methods,
             * and removing their instances.
             * @returns {void}
             */
            stopAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.stop(moduleName);
                    }
                }
            },

            //---------------------------------------------------------------------
            // Service Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a service creator with TLT.
             * @param {String} serviceName The name of the service that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the service.
             * @returns {void}
             */
            addService: function (serviceName, creator) {

                if (services.hasOwnProperty(serviceName)) {
                    throw new Error("Attempting to add duplicate service '" + serviceName +
                            "' on TLT.");
                }

                services[serviceName] = {
                    creator: creator,
                    instance: null
                };
            },

            /**
             * Retrieves a service instance, creating it if one doesn't already exist.
             * @param {String} serviceName The name of the service to retrieve.
             * @returns {Object} The service object as returned from the service
             *      creator or null if the service doesn't exist.
             */
            getService: function (serviceName) {
               /* if (!services.hasOwnProperty(serviceName)) {
                    throw new Error("Attempting to request non-existent service '" + serviceName +
                            "' on TLT.");
                }*/
                if (services.hasOwnProperty(serviceName)) {
                    if (!services[serviceName].instance) {
                        // If you want to have a separate ServiceContext, pass it here instead of "this"
                        try {
                            services[serviceName].instance = services[serviceName].creator(this);
                            if (typeof services[serviceName].instance.init === "function") {
                                services[serviceName].instance.init();
                            }
                        } catch (e) {
                            // shut the library down if jQuery or sizzle is not found / not supported
                            if (e.code && (e.code === "JQUERYNOTSUPPORTED" || e.code === "NOQUERYSELECTOR")) {
                                // TODO: reset service instance to null. In light of this, does explicit init for services make sense?
                                // Services should implicitly initialize when created and if any problems are encountered then throw appropriate exception.
                                return null;
                            }
                            // otherwise rethrow the error
                            throw e;
                        }
                        if (typeof services[serviceName].instance.getServiceName !== "function") {
                            services[serviceName].instance.getServiceName = function () {
                                return serviceName;
                            };
                        }
                    }
                    return services[serviceName].instance;
                }
                return null;
            },

            /**
             * Unregisters a service and destroys its instance.
             * @param {String} serviceName The name of the service to remove.
             * @returns {void}
             */
            removeService: function (serviceName) {
                delete services[serviceName];
            },

            //---------------------------------------------------------------------
            // Intermodule Communication
            //---------------------------------------------------------------------

            /**
             * Broadcasts a message throughout the system to all modules who are
             * interested.
             * @param {Object} message An object containing at least a type property
             *      indicating the message type.
             * @returns {void}
             */
            broadcast: function (message) {
                var i = 0,
                    len = 0,
                    prop = null,
                    module = null;

                if (message && typeof message === "object") {

                    if (!message.hasOwnProperty("type")) {
                        throw new Error("Message is missing property 'type'.");
                    }

                    for (prop in modules) {
                        if (modules.hasOwnProperty(prop)) {
                            module = modules[prop];

                            if (core.utils.indexOf(module.messages, message.type) > -1) {
                                if (typeof module.instance.onmessage === "function") {
                                    module.instance.onmessage(message);
                                }
                            }
                        }
                    }
                }
            },

            /**
             * Instructs a module to listen for a particular type of message.
             * @param {String} moduleName The module that's interested in the message.
             * @param {String} messageType The type of message to listen for.
             * @returns {void}
             */
            listen: function (moduleName, messageType) {
                var module = null;

                if (this.isStarted(moduleName)) {
                    module = modules[moduleName];

                    if (core.utils.indexOf(module.messages, messageType) === -1) {
                        module.messages.push(messageType);
                    }
                }
            },
            /**
             * Returns all services
             */
            _getServices: function () {
                return services;
            },
            /**
             * Stops UIC and throws an error.
             * @function
             * @throws {UICError}
             */
            fail: function (message, failcode, skipEvents) {
                message = "UIC FAILED. " + message;
                try {
                    core.destroy(!!skipEvents);
                } finally {
                    core.utils.clog(message);
                    throw new core.UICError(message, failcode);
                }
            },

            /**
             * @constructor
             */
            UICError: (function () {
                function UICError(message, errorCode) {
                    this.message = message;
                    this.code = errorCode;
                }
                UICError.prototype = new Error();
                UICError.prototype.name = "UICError";
                UICError.prototype.constructor = UICError;
                return UICError;
            }()),


            /**
             * Return the name of UIC flavor ("w3c" or "jQuery")
             * @function
             */
            getFlavor: function () {
                // TODO: Use the existing browserService method here
                return "jQuery";
            }
        };

    /**
     * Inactivity timeout handler function. When the timer expires,
     * log an exception message indicating the timeout and shutdown.
     * @private
     */
    inactivityTimeoutHandler = function () {
        core.logExceptionEvent("Inactivity timeout.");
        core.destroy();
    }

    /**
     * Actual init function called from TLT.init when the DOM is ready.
     * @private
     * @see TLT.init
     */
    _init = function (config, callback) {
        var configService,
            event,
            webEvent,
            baseBrowser,
            browserService;

        if (initialized) {
            core.utils.clog("TLT.init() called more than once. Ignoring.");
            return;
        }

        // Do not initialize if replay is enabled.
        if (TLT && TLT.replay) {
            return;
        }

        configService = core.getService("config");
        configService.updateConfig(config);

        if (!core._updateModules()) {
            if (state !== "destroyed") {
                core.destroy();
            }
            return;
        }

        if (configService.subscribe) {
            configService.subscribe("configupdated", core._reinitConfig);
        }

        initialized = true;
        state = "loaded";

        //generate fake load event to send for modules
        event = {
            type: 'load',
            target: window.window,
            srcElement: window.window,
            currentTarget: window.window,
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            timeStamp: +new Date(),
            customLoad: true
        };

        baseBrowser = core.getService("browserBase");
        webEvent = new baseBrowser.WebEvent(event);
        core._publishEvent(webEvent);

        if (typeof _callback === "function") {
            // Protect against unexpected exceptions since _callback is 3rd party code.
            try {
                _callback("initialized");
            } catch (e) {
                // Do nothing!
            }
        }
    };

    // Add methods that passthrough to services
    (function () {

        var name = null,
            i,
            len;

        for (name in servicePassthroughs) {
            if (servicePassthroughs.hasOwnProperty(name)) {
                for (i = 0, len = servicePassthroughs[name].length; i < len; i += 1) {
                    (function (serviceName, methodName) {
                        core[methodName] = function () {
                            var service = this.getService(serviceName);
                            if (service) {
                                return service[methodName].apply(service, arguments);
                            }
                        };
                    }(name, servicePassthroughs[name][i]));

                }
            }
        }

    }());

    return core;
}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines utility functions available to all modules via context object or as TLT.utils
 * @exports TLT.utils
 */

/*global TLT, window*/
/*jshint loopfunc:true*/

(function () {

    "use strict";

    var ua = window.navigator.userAgent.toLowerCase(),

        _isIE = (ua.indexOf("msie") !== -1),

        _isLegacyIE = (function () {
            // W3 Navigation timing spec. supported from IE 9 onwards.
            var isNavTimingSupported = !!window.performance;
            return (_isIE && (!isNavTimingSupported || document.documentMode < 9));
        }()),

        _isAndroid = (ua.indexOf("android") !== -1),

        _isiOS = /(ipad|iphone|ipod)/.test(ua),

        tltUniqueIndex = 1,

        utils = {
            /**
             * Indicates if browser is IE.
             */
            isIE: _isIE,

            /**
             * Indicates if browser is IE<9 or IE 9+ running in
             * compatibility mode.
             */
            isLegacyIE: _isLegacyIE,

            /**
             * Indicates if the browser is based on an Android platform device.
             */
            isAndroid: _isAndroid,

            /**
             * Indicates if the browser is based on an iOS platform device.
             */
            isiOS: _isiOS,

            /**
             * Checks whether given parameter is null or undefined
             * @param {*} obj Any value
             * @returns {boolean} True if obj is null or undefined; false otherwise
             */
            isUndefOrNull: function (obj) {
                return typeof obj === "undefined" || obj === null;
            },

            /**
             * Returns a unique serial number
             * @returns {int} A number that can be used as a unique identifier.
             */
            getSerialNumber: function () {
                var id;

                id = tltUniqueIndex;
                tltUniqueIndex += 1;

                return id;
            },

            /**
             * Used to test and get value from an object.
             * @private
             * @function
             * @name core.utils.getValue
             * @param {object} parentObj An object you want to get a value from.
             * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
             * @param {object|String|Number} [defaultValue] The default value to be returned if the property is not found.
             * @return {object} If object is found, if not then default value will be returned. If the default value is
             * not defined then null will be returned.
             */
            getValue: function (parentObj, propertyAsStr, defaultValue) {
                var i,
                    len,
                    properties;

                defaultValue = defaultValue || null;

                // Sanity check
                if (!parentObj || typeof parentObj !== "object" || typeof propertyAsStr !== "string") {
                    return defaultValue;
                }

                properties = propertyAsStr.split(".");
                for (i = 0, len = properties.length; i < len; i += 1) {
                    if (this.isUndefOrNull(parentObj) || typeof parentObj[properties[i]] === "undefined") {
                        return defaultValue;
                    }
                    parentObj = parentObj[properties[i]];
                }
                return parentObj;
            },

            /**
             * Helper function to find an item in an array.
             * @param {Array} array The array to search.
             * @param {String} item The item to search for.
             * @returns {int} The index of the item if found, -1 if not.
             */
            indexOf: function (array, item) {
                var i,
                    len;

                if (array && array instanceof Array) {
                    for (i = 0, len = array.length; i < len; i += 1) {
                        if (array[i] === item) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            /**
             * Invokes callback for each element of an array.
             * @param {Array} array The array (or any indexable object) to walk through
             * @param {function} callback Callback function
             * @param {object} [context] context object; if not provided global object will be considered
             */
            forEach: function (array, callback, context) {
                var i,
                    len;

                // Sanity checks
                if (!array || !array.length || !callback || !callback.call) {
                    return;
                }

                for (i = 0, len = array.length; i < len; i += 1) {
                    callback.call(context, array[i], i, array);
                }
            },

            /**
             * Returns true if callback returns true at least once. Callback is
             * called for each array element unless it reaches end of array or
             * returns true.
             * @param {object} array An Array or any indexable object to walk through
             * @param {function} callback A callback function
             * @returns {boolean} True if callback returned true at least once; false otherwise
             */
            some: function (array, callback) {
                var i,
                    len,
                    val = false;

                for (i = 0, len = array.length; i < len; i += 1) {
                    val = callback(array[i], i, array);
                    if (val) {
                        return val;
                    }
                }
                return val;
            },

            /**
             * Converts an arguments object into an array. This is used to augment
             * the arguments passed to the TLT methods used by the Module Context.
             * @param {Arguments} items An array-like collection.
             * @return {Array} An array containing the same items as the collection.
             */
            convertToArray: function (items) {
                var i = 0,
                    len = items.length,
                    result = [];

                while (i < len) {
                    result.push(items[i]);
                    i += 1;
                }

                return result;
            },

            mixin: function (dst) {
                var prop,
                    src,
                    srcId,
                    len;

                for (srcId = 1, len = arguments.length; srcId < len; srcId += 1) {
                    src = arguments[srcId];
                    for (prop in src) {
                        if (Object.prototype.hasOwnProperty.call(src, prop)) {
                            dst[prop] = src[prop];
                        }
                    }
                }
                return dst;
            },

            extend: function (deep, target, src) {
                var prop = "";

                for (prop in src) {
                    if (Object.prototype.hasOwnProperty.call(src, prop)) {
                        if (deep && Object.prototype.toString.call(src[prop]) === "[object Object]") {
                            if (typeof target[prop] === "undefined") {
                                target[prop] = {};
                            }
                            utils.extend(deep, target[prop], src[prop]);
                        } else {
                            target[prop] = src[prop];
                        }
                    }
                }
                return target;
            },

            /**
             * Makes copy of an object.
             * @function
             * @name core.utils.clone
             * @param {object} obj A object that will be cloned.
             * @return {object} Object cloned.
             */
            clone: function (obj) {
                var copy,
                    attr;

                if (null === obj || "object" !== typeof obj) {
                    return obj;
                }

                if (obj instanceof Object) {
                    copy = (Object.prototype.toString.call(obj) === "[object Array]") ? [] : {};
                    for (attr in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, attr)) {
                            copy[attr] = utils.clone(obj[attr]);
                        }
                    }
                    return copy;
                }
            },

            /**
             *
             */
            createObject: (function () {
                var fn = null,
                    F = null;
                if (typeof Object.create === "function") {
                    fn = Object.create;
                } else {
                    F = function () {};
                    fn = function (o) {
                        if (typeof o !== "object" && typeof o !== "function") {
                            throw new TypeError("Object prototype need to be an object!");
                        }
                        F.prototype = o;
                        return new F();
                    };
                }
                return fn;
            }()),

            /**
             * Method access the object element based on a string. By default it searches starting from window object.
             * @function
             * @example core.utils.access("document.getElementById");
             * @example core.utils.access("address.city", person);
             * @param {string} path Path to object element. Currently on dot separators are supported (no [] notation support)
             * @param {object} [rootObj=window] Root object where there search starts. window by default
             * @return {*} Object element or undefined if the path is not valid
             */
            access: function (path, rootObj) {
                var obj = rootObj || window,
                    arr,
                    i,
                    len;

                if (typeof path !== "string" || (typeof obj !== "object" && obj !== null)) {
                    return;
                }
                arr = path.split(".");
                for (i = 0, len = arr.length; i < len; i += 1) {
                    if (i === 0 && arr[i] === "window") {
                        continue;
                    }
                    if (!Object.prototype.hasOwnProperty.call(obj, arr[i])) {
                        return;
                    }
                    obj = obj[arr[i]];
                    if (i < (len - 1) && !(obj instanceof Object)) {
                        return;
                    }
                }
                return obj;
            },

            /**
             * Checks if a given character is numeric.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the given character is a number.
             */
            isNumeric: function (character) {
                return !isNaN(character + 1 - 1);
            },

            /**
             * Checks if a given character is uppercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is uppercase.
             *                        Otherwise false.
             */
            isUpperCase: function (character) {
                return character === character.toUpperCase() &&
                        character !== character.toLowerCase();
            },

            /**
             * Checks if a given character is lowercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is lowercase.
             *                        Otherwise false.
             */
            isLowerCase: function (character) {
                return character === character.toLowerCase() &&
                        character !== character.toUpperCase();
            },

            getDocument: function (node) {
                if (node.nodeType !== 9) {
                    return (!utils.isUndefOrNull(node.ownerDocument)) ? (node.ownerDocument) : (node.document);
                }
                return node;
            },

            getWindow: function (node) {
                if (node.self !== node) {
                    var ownerDocument = utils.getDocument(node);
                    return (!utils.isUndefOrNull(ownerDocument.defaultView)) ? (ownerDocument.defaultView) : (ownerDocument.parentWindow);
                }
                return node;
            },

            /**
             * Given a HTML frame element, returns the window object of the frame. Tries the contentWindow property
             * first. If contentWindow is not accessible, tries the contentDocument.parentWindow property instead.
             * @param {Object} iFrameElement The HTML frame element object.
             * @return {Object} Returns the window object of the frame element or null.
             */
            getIFrameWindow: function (iFrameElement) {
                var contentWindow = null;

                if (!iFrameElement) {
                    return contentWindow;
                }

                try {
                    contentWindow = iFrameElement.contentWindow ||
                        (iFrameElement.contentDocument ? iFrameElement.contentDocument.parentWindow : null);
                } catch (e) {
                    // Do nothing.
                }

                return contentWindow;
            },

            getTagName: function (node) {
                if (node === document) {
                    return "document";
                }
                if (node === window || node === window.window) {
                    return "window";
                }
                if (typeof node === "string") {
                    return node.toLowerCase();
                }
                if (typeof node === "object" && !utils.isUndefOrNull(node) && typeof node.tagName === "string") {
                    return node.tagName.toLowerCase();
                }
                return "";
            },

            /**
             * Returns true if given node is element from a frame
             * @private
             * @param {Element} node DOM element
             * @return {boolean} true if input element is element from a frame; false otherwise
             */
            isIFrameDescendant: function (node) {
                /*jshint eqeqeq:false, eqnull: false */
                /* The != operator below is on purpose due to legacy IE issues, where:
                   window === top returns false, but window == top returns true */
                return utils.getWindow(node) != TLT._getLocalTop();
            },

            /**
             * Takes the orientation in degrees and returns the orientation mode as a
             * text string. 0, 180 and 360 correspond to portrait mode while 90, -90
             * and 270 correspond to landscape.
             * @function
             * @name core.utils.getOrientationMode
             * @param {number} orientation A normalized orientation value such as
             *          0, -90, 90, 180, 270, 360.
             * @return {string} "PORTRAIT" or "LANDSCAPE" for known orientation values.
             * "UNKNOWN" for unrecognized values. "INVALID" in case of error.
             */
            getOrientationMode: function (orientation) {
                var mode = "INVALID";

                if (typeof orientation !== "number") {
                    return mode;
                }

                switch (orientation) {
                case 0:
                case 180:
                case 360:
                    mode = "PORTRAIT";
                    break;
                case 90:
                case -90:
                case 270:
                    mode = "LANDSCAPE";
                    break;
                default:
                    mode = "UNKNOWN";
                    break;
                }

                return mode;
            },

            clog: (function (window) {
                // Console logging should be only enabled in debug builds.
                if (typeof window.console === "object" && typeof window.console.log === "function" && typeof window.console.log.apply === "function") {
                    var c = window.console;
                    return function () {
                        c.log.apply(c, arguments);
                    };
                }
                return function () {
                    // Do nothing!
                };
            }(window)),

            /**
             * Trims any whitespace and returns the trimmed string.
             * @function
             * @name core.utils.trim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            trim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+|\s+$/g, "");
            },

            /**
             * Trims any whitespace at the beginning of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.ltrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            ltrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+/, "");
            },

            /**
             * Trims any whitespace at the end of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.rtrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            rtrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/\s+$/, "");
            },

            /**
             * Finds and returns the named cookie's value.
             * @function
             * @name core.utils.getCookieValue
             * @param {string} cookieName The name of the cookie.
             * @param {string} [cookieString] Optional cookie string in which to search for cookieName.
             * If none is specified, then document.cookie is used by default.
             * @return {string} The cookie value if a match is found or null.
             */
            getCookieValue: function (cookieName, cookieString) {
                var i,
                    len,
                    cookie,
                    cookies,
                    cookieValue = null,
                    cookieNameLen;

                try {
                    cookieString = cookieString || document.cookie;

                    // Sanity check.
                    if (!cookieName || !cookieName.toString) {
                        return null;
                    }

                    // Append an '=' to the cookie name
                    cookieName += "=";
                    cookieNameLen = cookieName.length;

                    // Get the individual cookies into an array and look for a match
                    cookies = cookieString.split(';');
                    for (i = 0, len = cookies.length; i < len; i += 1) {
                        cookie = cookies[i];
                        cookie = utils.ltrim(cookie);

                        // Check if cookieName matches the current cookie prefix.
                        if (cookie.indexOf(cookieName) === 0) {
                            // Match found! Get the value (i.e. RHS of "=" sign)
                            cookieValue = cookie.substring(cookieNameLen, cookie.length);
                            break;
                        }
                    }
                } catch (e) {
                    cookieValue = null;
                }

                return cookieValue;
            },

            /**
             * Finds and returns the query parameter's value.
             * @function
             * @name core.utils.getQueryStringValue
             * @param {string} paramName The name of the query parameter.
             * @param {string} [queryDelim] The query string delimiter. Either ";" or "&"
             * @param {string} [queryString] Optional query string in which to search for the query parameter.
             * If none is specified, then document.location.search is used by default.
             * @return {string} The query parameter value if a match is found or null.
             */
            getQueryStringValue: function (paramName, queryDelim, queryString) {
                var i,
                    j,
                    queryStringLen,
                    paramValue = null,
                    valueStartIndex;

                try {
                    queryString = queryString || window.location.search;
                    queryStringLen = queryString.length;

                    // Sanity check.
                    if (!paramName || !paramName.toString || !queryStringLen) {
                        return null;
                    }

                    // Default delimiter is &
                    queryDelim = queryDelim || "&";
                    // Normalize for easy searching by replacing initial '?' with the delimiter
                    queryString = queryDelim + queryString.substring(1);
                    // Modify the parameter name to prefix the delimiter and append an '='
                    paramName = queryDelim + paramName + "=";

                    i = queryString.indexOf(paramName);
                    if (i !== -1) {
                        valueStartIndex = i + paramName.length;
                        // Match found! Get the value (i.e. RHS of "=" sign upto the delim or end of string)
                        j = queryString.indexOf(queryDelim, valueStartIndex);
                        if (j === -1) {
                            j = queryStringLen;
                        }
                        paramValue = decodeURIComponent(queryString.substring(valueStartIndex, j));
                    }
                } catch (e) {
                    // Do nothing!
                }

                return paramValue;
            },

            /**
             * Quick wrapper for addEventL:istener/attachEvent. Mainly to be used for core, before UIC is fully
             * initialized
             * @function
             * @name core.util.addEventListener
             */
            addEventListener: (function () {
                if (window.addEventListener) {
                    return function (element, eventName, listener) {
                        element.addEventListener(eventName, listener, false);
                    };
                }
                return function (element, eventName, listener) {
                    element.attachEvent("on" + eventName, listener);
                };
            }()),

            /**
             * Returns the index of the rule that is matched by the target object.
             * @function
             * @name core.utils.matchTarget
             * @param {Array} rules An array of match rules containing objects such as
             * {id, idType} or { { regex }, idType } or a string representing "CSS Selectors"
             * @param {Object} target  The normalized target object of the message.
             * @return {int} Returns the index of the matching rule. If none of the rules match then returns -1.
             */
            matchTarget: function (rules, target) {
                var i,
                    j,
                    matchIndex = -1,
                    qr,
                    qrLen,
                    qrTarget,
                    regex,
                    len,
                    rule;

                // Sanity check
                if (!rules || !target) {
                    return matchIndex;
                }

                if (!this.browserService || !this.browserBaseService) {
                    this.browserService = TLT.getService("browser");
                    this.browserBaseService = TLT.getService("browserBase");
                }

                for (i = 0, len = rules.length; i < len && matchIndex === -1; i += 1) {
                    rule = rules[i];

                    // Check if rule is a selector string.
                    if (typeof rule === "string") {
                        qr = this.browserService.queryAll(rule);
                        for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                            if (qr[j]) {
                                qrTarget = this.browserBaseService.ElementData.prototype.examineID(qr[j]);
                                if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                                    matchIndex = i;
                                    break;
                                }
                            }
                        }
                    } else if (rule.id && rule.idType && target.idType.toString() === rule.idType.toString()) {
                        // Note: idType provided by wizard is a string so convert both to strings before comparing.

                        // An id in the rules list could be a direct match, in which case it will be a string OR
                        // it could be a regular expression in which case it would be an object like this:
                        // {regex: ".+private$", flags: "i"}
                        switch (typeof rule.id) {
                        case "string":
                            if (rule.id === target.id) {
                                matchIndex = i;
                            }
                            break;
                        case "object":
                            regex = new RegExp(rule.id.regex, rule.id.flags);
                            if (regex.test(target.id)) {
                                matchIndex = i;
                            }
                            break;
                        }
                    }
                }
                return matchIndex;
            },

            /**
             * Basic WeakMap implementation - a map which can be indexed with objects.
             * In comparison to the original API 'delete' method has been replaced with 'remove'
             * due to compatibility with legacy IE
             * @constructor
             * @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/WeakMap
             */
            WeakMap: (function () {
                function index(data, key) {
                    var i,
                        len;
                    data = data || [];
                    for (i = 0, len = data.length; i < len; i += 1) {
                        if (data[i][0] === key) {
                            return i;
                        }
                    }
                    return -1;
                }
                return function () {
                    var data = [];
                    this.set = function (key, val) {
                        var idx = index(data, key);
                        data[idx > -1 ? idx : data.length] = [key, val];
                    };
                    this.get = function (key) {
                        var arr = data[index(data, key)];
                        return (arr ? arr[1] : undefined);
                    };
                    this.clear = function () {
                        data = [];
                    };
                    this.has = function (key) {
                        return (index(data, key) >= 0);
                    };
                    this.remove = function (key) {
                        var idx = index(data, key);
                        if (idx >= 0) {
                            data.splice(idx, 1);
                        }
                    };
                    this["delete"] = this.remove;
                };
            }())
        };


    if (typeof TLT === "undefined" || !TLT) {
        window.TLT = {};
    }

    TLT.utils = utils;

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines a simple event target interface that can be inherited
 *      from by other parts of the system.
 * @exports TLT.EventTarget
 */
/*global TLT*/

(function () {

    "use strict";

    /**
     * Abstract type that implements basic event handling capabilities.
     * Other types may inherit from this in order to provide custom
     * events.
     * @constructor
     */
    TLT.EventTarget = function () {

        /**
         * Holds all registered event handlers. Each property represents
         * a specific event, each property value is an array containing
         * the event handlers for that event.
         * @type Object
         */
        this._handlers = {};

    };

    TLT.EventTarget.prototype = {

        /**
         * Restores the constructor to the correct value.
         * @private
         */
        constructor: TLT.EventTarget,

        /**
         * Publishes an event with the given name, which causes all
         * event handlers for that event to be called.
         * @param {String} name The name of the event to publish.
         * @param {Variant} [data] The data to provide for the event.
         * @returns {void}
         */
        publish: function (name, data) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name],
                event = {
                    type: name,
                    data: data
                };

            if (typeof handlers !== "undefined") {
                for (len = handlers.length; i < len; i += 1) {
                    handlers[i](event);
                }
            }

        },

        /**
         * Registers an event handler for the given event.
         * @param {String} name The name of the event to subscribe to.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
        subscribe: function (name, handler) {

            if (!this._handlers.hasOwnProperty(name)) {
                this._handlers[name] = [];
            }

            if (typeof handler !== "function") {
                throw new Error("Event handler for '" + name + "' isn't a function.");
            }

            this._handlers[name].push(handler);
        },

        /**
         * Unregisters an event handler for the given event.
         * @param {String} name The name of the event to unsubscribe from.
         * @param {Function} handler The event handler to remove.
         * @returns {void}
         */
        unsubscribe: function (name, handler) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name];

            if (handlers) {
                for (len = handlers.length; i < len; i += 1) {
                    if (handlers[i] === handler) {
                        handlers.splice(i, 1);
                        return;
                    }
                }
            }
        }

    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines ModuleContext, which is used by all modules.
 * @exports TLT.ModuleContext
 */

/*global TLT*/
/*jshint loopfunc:true*/

/**
 * A layer that abstracts core functionality for each modules. Modules interact
 * with a ModuleContext object to ensure that they're not doing anything
 * they're not allowed to do.
 * @class
 * @param {String} moduleName The name of the module that will use this context.
 * @param {TLT} core The core object. This must be passed in to enable easier
 *        testing.
 */
TLT.ModuleContext = (function () {

    "use strict";

    /**
     * Methods to be exposed from the Core to ModuleContext. ModuleContext
     * simply passes through these methods to the Core. By listing the
     * methods here, the ModuleContext object can be dynamically created
     * to keep the code as small as possible. You can easily add new methods
     * to ModuleContext by adding them to this array. Just make sure the
     * method also exists on TLT and that the first argument for the method
     * on TLT is always the module name.
     *
     * If the method name on ModuleContext is different than on TLT, you can
     * specify that via "contextMethodName:coreMethodName", where contextMethodName
     * is the name of the method on ModuleContext and coreMethodName is
     * the name of the method on TLT.
     *
     * Because the methods aren't actually defined in the traditional sense,
     * the documentation comments are included within the array for proper
     * context.
     * @private
     * @type String[]
     */
    var methodsToExpose = [

        /**
         * Broadcasts a message to the entire system.
         * @name broadcast
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to send.
         * @param {Variant} data The data to send along with the message.
         * @returns {void}
         */
        "broadcast",

        /**
         * Returns the configuration object for the module.
         * @name getConfig
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {Object} The configuration object for the module.
         */
        "getConfig:getModuleConfig",

        /**
         * Tells the system that the module wants to know when a particular
         * message occurs.
         * @name listen
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to listen for.
         * @returns {void}
         */
        "listen",

        /**
         * Add HTTP header information to the module's default queue.
         * @name addHeader
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} headerName The name of the header.
         * @param {String} headerValue The value of the header.
         * @param {String} [queueId] Specifies the ID of the queue to receive the event.
         * @returns {void}
         */
        "addHeader",

        /**
         * Posts an event to the module's queue.
         * @name post
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {Object} event The event to put into the queue.
         * @param {String} [queueId] The ID of the queue to add the event to.
         * @returns {void}
         */
        "post",

        /**
         * Calculates the xpath of the given DOM Node.
         * @name getXPathFromNode
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {DOMElement} node The DOM node who's xpath is to be calculated.
         * @returns {String} The calculated xpath.
         */
        "getXPathFromNode",

        /* Log a DOM Capture message to the default queue.
         * @name performDOMCapture
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} moduleName Name of the module which invoked this function.
         * @param {DOMElement} [root] Parent element from which to start the capture.
         * @param {Object} [config] DOM Capture configuration options.
         * @returns {String} The unique string representing the DOM Capture id.
         * null if DOM Capture failed.
         */
        "performDOMCapture",

        /**
         * @name getStartTime
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
         */
        "getStartTime"
    ];

    /**
     * Creates a new ModuleContext object. This function ends up at TLT.ModuleContext.
     * @private
     * @param {String} moduleName The name of the module that will use this context.
     * @param {TLT} core The core object. This must be passed in to enable easier
     *        testing.
     */
    return function (moduleName, core) {

        // If you want to add methods that aren't directly mapped from TLT, do it here
        var context = {},
            i = 0,
            len = methodsToExpose.length,
            parts = null,
            coreMethod = null,
            contextMethod = null;

        // Copy over all methods onto the context object
        for (i = 0; i < len; i += 1) {

            // Check to see if the method names are the same or not
            parts = methodsToExpose[i].split(":");
            if (parts.length > 1) {
                contextMethod = parts[0];
                coreMethod = parts[1];
            } else {
                contextMethod = parts[0];
                coreMethod = parts[0];
            }

            context[contextMethod] = (function (coreMethod) {

                return function () {

                    // Gather arguments and put moduleName as the first one
                    var args = core.utils.convertToArray(arguments);
                    args.unshift(moduleName);

                    if (!core.hasOwnProperty(coreMethod)) {
                        throw new Error("Attempting to access method '" + coreMethod +
                                "' on TLT, but it doesn't exist. There's a " +
                                "misconfigured passthru method.");
                    }

                    // Pass through to the Core
                    return core[coreMethod].apply(core, args);
                };

            }(coreMethod));
        }

        context.utils = core.utils;

        return context;
    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The ConfigService is responsible for managing global configuration settings.
 * This may include receiving dynamic configuration updates from the server at regular intervals.
 * The ConfigService fires a configupdated event when it receives updated configuration information.
 * @exports configService
 */

/*global TLT:true */

/**
 * @name configService
 * @namespace
 */
TLT.addService("config", function (core) {
    "use strict";

    /**
     * Merges a new configuration object/diff into the existing configuration by doing a deep copy.
     * @name configService-mergeConfig
     * @function
     * @private
     * @param  {Object} oldConf Existing configuration object.
     * @param  {Object} newConf New configuration object.
     */
    function mergeConfig(oldConf, newConf) {
        core.utils.extend(true, oldConf, newConf);
        configService.publish("configupdated", configService.getConfig());
    }



    /**
     * Holds the config for core and all services and modules.
     * @private
     * @name configService-config
     * @type {Object}
     */
    var config = {
            core: {},
            modules: {},
            services: {}
        },
        configService = core.utils.extend(false, core.utils.createObject(new TLT.EventTarget()), {
            /**
             * Returns the global configuration object.
             * @return {Object} The global configuration object.
             */
            getConfig: function () {
                return config;
            },
            /**
             * Assigns the global configuration for the system.
             * This is first called when Core.init() is called and also may be called later if new
             * configuration settings are returned from the server. After initial configuration is set,
             * all further calls are assumed to be diffs of settings that should be changed rather than
             * an entirely new configuration object.
             * @param  {Object} newConf The global configuration object.
             */
            updateConfig: function (newConf) {
                mergeConfig(config, newConf);
            },
            /**
             * Returns the configuration object for the core.
             * @return {Object} The core configuration object.
             */
            getCoreConfig: function () {
                return config.core;
            },
            /**
             * Assigns the configuration for the core. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {Object} newConf     A partial or complete core configuration object.
             */
            updateCoreConfig: function (newConf) {
                mergeConfig(config.core, newConf);
            },
            /**
             * Returns the configuration object for a given service.
             * @param {String} serviceName The name of the service to retrieve configuration information for.
             * @return {Object|null} The service configuration object or null if the named service doesn't exist.
             */
            getServiceConfig: function (serviceName) {
                // XXX - Return empty object {} instead of null and correct all places where this is being called.
                return config.services[serviceName] || null;
            },
            /**
             * Assigns the configuration for the named service. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} serviceName The name of the service to update configuration information for.
             * @param  {Object} newConf     A partial or complete service configuration object.
             */
            updateServiceConfig: function (serviceName, newConf) {
                if (typeof config.services[serviceName] === "undefined") {
                    config.services[serviceName] = {};
                }
                mergeConfig(config.services[serviceName], newConf);
            },
            /**
             * Returns the configuration object for a given module.
             * @param {String} moduleName The name of the module to retrieve configuration information for.
             * @return {Object|null} The module configuration object or null if the named module doesn't exist.
             */
            getModuleConfig: function (moduleName) {
                return config.modules[moduleName] || null;
            },
            /**
             * Assigns the configuration for the named module. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} moduleName The name of the module to update configuration information for.
             * @param  {Object} newConf     A partial or complete module configuration object.
             */
            updateModuleConfig: function (moduleName, newConf) {
                if (typeof config.modules[moduleName] === "undefined") {
                    config.modules[moduleName] = {};
                }
                mergeConfig(config.modules[moduleName], newConf);
            },
            destroy: function () {
                config = {
                    core: {},
                    modules: {},
                    services: {}
                };
            }
        });

    return configService;

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The QueueService manages all queues in the system.
 * @exports queueService
 */

/*global TLT:true */

/**
 * @name queueService
 * @namespace
 */
TLT.addService("queue", function (core) {
    "use strict";

    /**
     * queueMananger
     * @private
     * @static
     * @name queueService-queueManager
     * @namespace
     */
    var CONFIG       = null,    // queue configuration
        // TODO: replace these with long form names i.e. aS -> ajaxService
        aS           = core.getService("ajax"),          // ajaxService
        bS           = core.getService("browser"),       // browserService
        eS           = core.getService("encoder"),       // encoderService
        sS           = core.getService("serializer"),    // serializerService
        cS           = core.getService("config"),        // configService
        mS           = core.getService("message"),       // messageService
        defaultQueue = null,    // config object for default queue
        queueTimers  = {},      // timer id for the queueTick
        autoFlushing = true,    // Bool, indicates whether to flush queues when
                                // threshold is reached or let the application control flushing.
        isInitialized = false,
        queueManager = (function () {
            var queues = {};

            /**
             * Checks if the specified queue exists.
             * @function
             * @name queueService-queueManager.exists
             * @param  {String} queueId The id of the queue to check for existence.
             * @return {Boolean}         Returns true if the queue exists, otherwise false.
             */
            function queueExists(queueId) {
                return typeof queues[queueId] !== "undefined";
            }

            /**
             * Adds a queue to the system.
             * @function
             * @name queueService-queueManager.add
             * @param {String} queueId The id of the queue to add.
             * @param {Object} opts    Some additional configuration options for this queue.
             * @param {String} opts.url  The endpoint URL to which the queue should be flushed.
             * @param {Number} opts.threshold The maximal amount of messages to store
             * in the queue before it gets flushed.
             * @param {String} opts.serialzer The serializer which should be used to serialize
             * the data in the queue when sending it to the server.
             * @return {Object} Returns the newly created queue.
             */
            function addQueue(queueId, opts) {
                if (!queueExists(queueId)) {
                    /* TODO: Add prototype functions to access queue members */
                    queues[queueId] = {
                        data: [],
                        queueId: queueId,
                        url: opts.url,
                        threshold: opts.threshold,
                        serializer: opts.serializer,
                        encoder: opts.encoder,
                        crossDomainEnabled: !!opts.crossDomainEnabled,
                        crossDomainIFrame: opts.crossDomainIFrame
                    };
                }
                return queues[queueId];
            }

            /**
             * Removes a queue from the system.
             * @function
             * @name queueService-queueManager.remove
             * @param  {String} queueId The id of the queue which should be deleted.
             */
            function removeQueue(queueId) {
                if (queueExists(queueId)) {
                    delete queues[queueId];
                }
            }

            /**
             * Returns the queue object associated with the given queueId.
             * @function
             * @name queueService-queueManager.get
             * @param  {String} queueId The id of the queue to return.
             * @return {Object}         Returns the queue object for the given id.
             */
            function getQueue(queueId) {
                if (queueExists(queueId)) {
                    return queues[queueId];
                }
                return null;
            }

            /**
             * Clears all items in the queue specified by the queue id.
             * @function
             * @name queueService-queueManager.clear
             * @param  {String} queueId The id of the queue which should be cleared.
             */
            function clearQueue(queueId) {
                var queue = getQueue(queueId);
                if (queue !== null) {
                    queue.data = [];
                }
            }

            /**
             * Returns the queue data and clears the queue.
             * @function
             * @name queueService-queueManager.flush
             * @param  {String} queueId The id of the queue to be flushed.
             * @return {Array}         Returns all items which were stored in the queue.
             */
            function flushQueue(queueId) {
                var data = null;
                if (queueExists(queueId)) {
                    data = getQueue(queueId).data;
                    clearQueue(queueId);
                }
                return data;
            }

            /**
             * Adds an item to a specific queue.
             * @function
             * @name queueService-queueManager.push
             * @param  {String} queueId The id of the queue to which the item should be added.
             * @param  {Object} data    The message object which should be stored in the queue.
             * @return {Number}         Returns the current length of the queue.
             */
            function pushToQueue(queueId, data) {
                var queue = null,
                    jsonStr = null,
                    bridgeAndroid = window.tlBridge,
                    bridgeiOS = window.iOSJSONShuttle;

                // Send to Native Android Bridge
                if ((typeof bridgeAndroid !== "undefined") &&
                        (typeof bridgeAndroid.addMessage === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeAndroid.addMessage(jsonStr);
                // Send to Native iOS Bridge
                } else if ((typeof bridgeiOS !== "undefined") &&
                        (typeof bridgeiOS === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeiOS(jsonStr);
                // Send to normal library queue
                } else {
                    if (queueExists(queueId)) {
                        queue = getQueue(queueId);
/*jshint devel:true */
                        if (typeof console !== "undefined") {
                            console.log("Added to queueId: ", queueId, " data: ", data);
                        }
                        queue.data.push(data);
                        /* Redirect the queue so any registered callback function
                         * can optionally modify it.
                         */
                        queue.data = core.redirectQueue(queue.data);
                        return queue.data.length;
                    }
                }
                return 0;
            }

            /**
             * @scope queueManager
             */
            return {
                exists: queueExists,
                add: addQueue,
                remove: removeQueue,
                get: getQueue,
                clear: clearQueue,
                flush: flushQueue,
                push: pushToQueue
            };

        }());


    /**
     * Handles the xhr response of the server call.
     * @function
     * @private
     * @name queueService-handleXhrCallback
     */
    function handleXhrCallback() {
        // TODO
    }

    /**
    * Get the path relative to the host.
    * @addon
    */
    function getUrlPath() {
        return window.location.pathname;
    }

    /**
     * Adds a HTTP header (name,value) pair to the specified queue.
     * @function
     * @private
     * @name queueService-addHeaderToQueue
     * @param  {String} queueId The id of the queue which should be flushed.
     * @param  {String} headerName The name of the header to be added.
     * @param  {String} headerValue The value of the header to be added.
     * @param  {Boolean} [recurring] Flag specifying if header should be sent
     *                   once (false) or always (true). Default behavior is to
     *                   send the header once.
     */
    function addHeaderToQueue(queueId, headerName, headerValue, recurring) {
        var queue = queueManager.get(queueId),
            header = {
                name: headerName,
                value: headerValue
            },
            qHeadersList = null;

        // Sanity check
        if (typeof headerName !== "string" || typeof headerValue !== "string") {
            return;
        }

        if (!queue.headers) {
            // TODO: Add prototype functions to help add/copy/remove headers
            queue.headers = {
                once: [],
                always: []
            };
        }

        qHeadersList = !!recurring ? queue.headers.always : queue.headers.once;
        qHeadersList.push(header);
    }

    /**
     * Copies HTTP headers {name,value} from the specified queue to an
     * object.
     * @function
     * @private
     * @name queueService-copyHeaders
     * @param  {String} queueId The id of the queue whose headers are copied.
     * @param  {Object} [headerObj] The object to which headers are added. If no
     * object is specified then a new one is created.
     * @return {Object} The object containing the copied headers.
     */
    function copyHeaders(queueId, headerObj) {
        var i = 0,
            len = 0,
            queue = queueManager.get(queueId),
            qHeaders = queue.headers,
            headersList = null;

        headerObj = headerObj || {};

        function copy(l, o) {
            var i = 0,
                len = 0,
                header = null;

            for (i = 0, len = l.length; i < len; i += 1) {
                header = l[i];
                o[header.name] = header.value;
            }
        }

        if (qHeaders) {
            headersList = [qHeaders.always, qHeaders.once];

            for (i = 0, len = headersList.length; i < len; i += 1) {
                copy(headersList[i], headerObj);
            }
        }

        return headerObj;
    }

    /**
     * Clear HTTP headers {name,value} from the specified queue. Only headers
     * that are to be sent once are cleared.
     * @function
     * @private
     * @name queueService-clearHeaders
     * @param  {String} queueId The id of the queue whose headers are cleared.
     */
    function clearHeaders(queueId) {
        var queue = null,
            qHeaders = null;

        if (!queueManager.exists(queueId)) {
            throw new Error("Queue: " + queueId + " does not exist!");
        }

        queue = queueManager.get(queueId);
        qHeaders = queue ? queue.headers : null;
        if (qHeaders) {
            // Only reset headers that are sent once.
            qHeaders.once = [];
        }
    }

    /**
     * Invoke the core function to get any HTTP request headers from
     * external scripts and add these headers to the default queue.
     * @function
     * @private
     * @returns The number of external headers added to the queue.
     */
    function getExternalRequestHeaders() {
        var i = 0,
            len,
            header,
            headers = core.provideRequestHeaders();

        if (headers && headers.length) {
            for (i = 0, len = headers.length; i < len; i += 1) {
                header = headers[i];
                addHeaderToQueue("DEFAULT", header.name, header.value, header.recurring);
            }
        }
        return i;
    }

    /**
     * Clears a specific queue and sends its serialized content to the server.
     * @function
     * @private
     * @name queueService-flushQueue
     * @param  {String} queueId The id of the queue to be flushed.
     */
    function flushQueue(queueId, sync) {
        var data = queueManager.flush(queueId),
            count = data !== null ? data.length : 0,
            queue = queueManager.get(queueId),
            httpHeaders = {
                "Content-Type": "application/json",
                "X-Tealeaf": "device (UIC) Lib/4.0.0.1607",
                "X-TealeafType": "GUI",  // For our past sins
                "X-TeaLeaf-Page-Url": getUrlPath()
            },
            serializer = queue.serializer || "json",
            contentEncoder = queue.encoder,
            requestData,
            retObj,
            xdomainFrameWindow = null;

        if (!count) {
            return;
        }

        // Wrap the messages with the header
        data = mS.wrapMessages(data);

        // Serialize the data
        if (serializer) {
            data = sS.serialize(data, serializer);
        }

        // Encode if specified
        if (contentEncoder) {
            retObj = eS.encode(data, contentEncoder);
            if (retObj && retObj.data && !retObj.error) {
                data = retObj.data;
                httpHeaders["Content-Encoding"] = retObj.encoding;
            }
        }

        getExternalRequestHeaders();
        copyHeaders(queueId, httpHeaders);

        if (queue.crossDomainEnabled) {
            xdomainFrameWindow = core.utils.getIFrameWindow(queue.crossDomainIFrame);
            if (!xdomainFrameWindow) {
                core.utils.clog("Cannot access xdomain frame window.");
                return;
            }
            requestData = {
                request: {
                    url: queue.url,
                    async: !sync,
                    headers: httpHeaders,
                    data: data
                }
            };

            if (!core.utils.isIE && typeof window.postMessage === "function") {
                xdomainFrameWindow.postMessage(requestData, queue.crossDomainIFrame.src);
            } else {
                try {
                    xdomainFrameWindow.sendMessage(requestData);
                } catch (e) {
                    core.utils.clog("Cannot access sendMessage API on xdomain frame window.");
                    return;
                }
            }
        } else {
            aS.sendRequest({
                oncomplete: handleXhrCallback,
                url: queue.url,
                async: !sync,
                headers: httpHeaders,
                data: data
            });
        }
        clearHeaders(queueId);
    }

    /**
     * Iterates over all queues and sends their contents to the servers.
     * @function
     * @private
     * @name queueServive-flushAll
     */
    function flushAll(sync) {
        var conf = null,
            queues = CONFIG.queues,
            i = 0;
        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            flushQueue(conf.qid, sync);
        }
        return true;
    }


    /**
     * Adds a message event to the specified queue.
     * If the queue threshold is reached the queue gets flushed.
     * @function
     * @private
     * @name queueService-addToQueue
     * @param {String} queueId The id of the queue which should be flushed.
     * @param {Object} data    The message event which should be stored in the queue.
     */
    function addToQueue(queueId, data) {
        var length = queueManager.push(queueId, mS.createMessage(data));
        if (length >= queueManager.get(queueId).threshold &&
                autoFlushing && core.getState() !== "unloading") {
            flushQueue(queueId);
        }
    }

    /**
     * Returns the queue id for the queue which is responsible for the given module.
     * @function
     * @private
     * @name queueService-getQueueId
     * @param  {String} moduleName The name of the module for which the id should get looked up.
     * @return {String}            Returns the queue id for the corresponding queue or the default queue id.
     */
    function getQueueId(moduleName) {
        var conf = null,
            queues = CONFIG.queues,
            module = "",
            i = 0,
            j = 0;

        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            if (conf && conf.modules) {
                for (j = 0; j < conf.modules.length; j += 1) {
                    module = conf.modules[j];
                    if (module === moduleName) {
                        return conf.qid;
                    }
                }
            }
        }
        return defaultQueue.qid;
    }


    function setTimer(qid, interval) {
        queueTimers[qid] = window.setTimeout(function tick() {
            flushQueue(qid);
            queueTimers[qid] = window.setTimeout(tick, interval);
        }, interval);
    }


    function clearTimers() {
        var key = 0;

        for (key in queueTimers) {
            if (queueTimers.hasOwnProperty(key)) {
                window.clearTimeout(queueTimers[key]);
                delete queueTimers[key];
            }
        }

        queueTimers = {};
    }


    /**
     * Handles the configupdated event from the configService and reinitialize all queues.
     * @function
     * @private
     * @name queueService-handleConfigUpdated
     * @param  {Object} newConf The new configuration object diff.
     */
    function handleConfigUpdated(newConf) {
        // TODO: merge config
    }



    /**
     * Sets up all the needed queues and event handlers and start the queueTick.
     * @function
     * @private
     * @param  {Object} config The queueService configuration object.
     */
    function initQueueService(config) {
        CONFIG = config;

        core.utils.forEach(CONFIG.queues, function (conf, i) {
            var crossDomainIFrame = null;
            if (conf.qid === "DEFAULT") {
                defaultQueue = conf;
            }
            if (conf.crossDomainEnabled) {
                crossDomainIFrame = bS.query(conf.crossDomainFrameSelector);
                if (!crossDomainIFrame) {
                    core.fail("Cross domain iframe not found");
                }
            }

            queueManager.add(conf.qid, {
                url: conf.endpoint,
                threshold: conf.maxEvents,
                serializer: conf.serializer,
                encoder: conf.encoder,
                timerInterval: conf.timerInterval || 0,
                crossDomainEnabled: conf.crossDomainEnabled || false,
                crossDomainIFrame: crossDomainIFrame
            });

            if (typeof conf.timerInterval !== "undefined" && conf.timerInterval > 0) {
                setTimer(conf.qid, conf.timerInterval);
            }
        });

        cS.subscribe("configupdated", handleConfigUpdated);

        isInitialized = true;
    }

    function destroy() {
        if (autoFlushing) {
            flushAll(!CONFIG.asyncReqOnUnload);
        }
        cS.unsubscribe("configupdated", handleConfigUpdated);

        clearTimers();

        CONFIG = null;
        defaultQueue = null;
        isInitialized = false;
    }

    /**
     * @scope queueService
     */
    return {
        addHeaderToQueue: addHeaderToQueue,
        copyHeaders: copyHeaders,
        clearHeaders: clearHeaders,
        getExternalRequestHeaders: getExternalRequestHeaders,
        getQueueManager: function () {
            return queueManager;
        },
        getAutoFlushing: function () {
            return autoFlushing;
        },
        init: function () {
            if (!isInitialized) {
                initQueueService(cS.getServiceConfig("queue") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(queueService)");
            }
        },

        /**
         * Get's called when the core shut's down.
         * Clean up everything.
         */
        destroy: function () {
            destroy();
        },

        // TODO: Need to expose for selenium functional tests
        _getQueue: function (qid) { return queueManager.get(qid).data; },

        /**
         * Adds a HTTP header (name,value) pair to the specified queue.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {String} headerName The name of the header to be added.
         * @param  {String} headerValue The value of the header to be added.
         * @param  {String} queueId The id of the queue which should be flushed.
         */
        addHeader: function (moduleName, headerName, headerValue, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addHeaderToQueue(queueId, headerName, headerValue);
        },

        /**
         * Enables/disables automatic flushing of queues so that the application
         * could decide on their own when to flush by calling flushAll.
         * @param {Boolean} flag Could be either true or false to enable or disable
         *                  auto flushing respectively.
         */
        setAutoFlush: function (flag) {
            if (flag === true) {
                autoFlushing = true;
            } else {
                autoFlushing = false;
            }
        },

        /**
         * Forces a particular queue to be flushed, sending its information to the server.
         * @param  {String} queueId The ID of the queue to be flushed.
         */
        flush: function (queueId) {
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            flushQueue(queueId);
        },

        /**
         * Forces all queues to be flushed, sending all queue information to the server.
         */
        flushAll: function (sync) {
            return flushAll(!!sync);
        },

        /**
         * Send event information to the module's default queue.
         * This doesn't necessarily force the event data to be sent to the server,
         * as this behavior is defined by the queue itself.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {Object} queueEvent The event information to be saved to the queue.
         * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
         */
        post: function (moduleName, queueEvent, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addToQueue(queueId, queueEvent);
        }
    };

});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document, ActiveXObject */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browserBase", function (core) {
    "use strict";

    var nonClickableTags = {
            OPTGROUP: true,
            OPTION: true,
            NOBR: true
        },
        queryDom = {},
        configService = core.getService("config"),
        serializerService = null,
        config,
        blacklist,
        customid,
        getXPathFromNode,
        isInitialized = false;

    function updateConfig() {
        configService = core.getService("config");
        serializerService = core.getService("serializer");
        config = core.getService("config").getServiceConfig("browser") || {};
        blacklist = config.hasOwnProperty("blacklist") ? config.blacklist : [];
        customid = config.hasOwnProperty("customid") ? config.customid : [];
    }

    function initBrowserBase() {
        updateConfig();
        configService.subscribe("configupdated", updateConfig);
        serializerService = core.getService("serializer");

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    function checkId(node) {
        var i,
            len,
            re;

        if (!node || !node.id || typeof node.id !== "string") {
            return false;
        }

        for (i = 0, len = blacklist.length; i < len; i += 1) {
            if (typeof blacklist[i] === "string") {
                if (node.id === blacklist[i]) {
                    return false;
                }
            } else if (typeof blacklist[i] === "object") {
                re = new RegExp(blacklist[i].regex, blacklist[i].flags);
                if (re.test(node.id)) {
                    return false;
                }
            }
        }
        return true;
    }

    function getEventType(event, target) {
        var returnObj = {
                type: null,
                // Event subtype is not used in the UIC
                subType: null
            },
            type;

        // Sanity check
        if (!event) {
            return returnObj;
        }

        // Normalize event type for jQuery events focusin, focusout
        type = event.type;
        switch (type) {
        case "focusin":
            type = "focus";
            break;
        case "focusout":
            type = "blur";
            break;
        default:
            break;
        }
        returnObj.type = type;

        return returnObj;
    }

    /**
     * Examines the type and subType of the target.
     * @function
     * @name browserService-getElementType
     * @param  {Object} element The normalized target element.
     * @return {Object} Returns an object which contains the type and subType of the target element.
     */
    function getElementType(element) {
        var returnObj = {
                type: null,
                subType: null
            };

        // Sanity check
        if (!element) {
            return returnObj;
        }

        returnObj.type = element.tagName;
        returnObj.subType = element.type || null;

        return returnObj;
    }

    /**
     * Returns an element by it's id and idType where id could be either an HTML id,
     *     attribute ID or XPath selector.
     * @param  {String} selector The selector. Either a single HTML ID or an attribute ID
     *                  example: "myid=customid" or a tealeaf XPath string.
     * @param  {Number} type     A number, indicating the type of the query
     *                           as in the object 'idTypes' below.
     *                           -1 for HTML ID, -2 for XPath and -3 for attribute ID.
     * @return {Object}          Returns the node, if found. Otherwise null.
     */
    function getNodeFromID(selector, type, scope) {
        var idTypes = {
                HTML_ID: "-1",
                XPATH_ID: "-2",
                ATTRIBUTE_ID: "-3"
            },
            doc,
            node = null,
            parts;

        // Sanity check
        if (!selector || !type) {
            return node;
        }

        doc = scope || window.document;
        type = type.toString();
        if (type === idTypes.HTML_ID) {
            if (doc.getElementById) {
                node = doc.getElementById(selector);
            } else if (doc.querySelector) {
                node = doc.querySelector("#" + selector);
            }
        } else if (type === idTypes.ATTRIBUTE_ID) {
            parts = selector.split("=");
            if (doc.querySelector) {
                node = doc.querySelector("[" + parts[0] + "=\"" + parts[1] + "\"]");
            }
        } else if (type === idTypes.XPATH_ID) {
            node = queryDom.xpath(selector, doc);
        }
        return node;
    }

    /**
     * Generates an XPath for a given node
     * @function
     */
    getXPathFromNode = (function () {

        var specialChildNodes = {
                "NOBR": true,
                "P": true
            };

        /**
         * Returns Xpath string for a node
         * @private
         * @param {Element} node DOM element
         * @return {string} xpath string
         */
        function getXPathArrayFromNode(node) {
            var i,
                j,
                idValid = false,
                tmp_child = null,
                parent_window = null,
                parent_node = null,
                xpath = [],
                loop = true,
                localTop = core._getLocalTop();

            while (loop) {
                loop = false;

                if (!core.utils.isUndefOrNull(node)) {
                    if (!core.utils.isUndefOrNull(node.tagName)) {
                        // Hack fix to handle tags that are not normally visual elements
                        if (specialChildNodes.hasOwnProperty(node.tagName)) {
                            node = node.parentNode;
                        }
                    }
                    for (idValid = checkId(node);
                            node !== document && !idValid;
                            idValid = checkId(node)) {
                        parent_node = node.parentNode;
                        if (!parent_node) {
                            parent_window = core.utils.getWindow(node);
                            parent_node = (parent_window !== localTop) ? parent_window.frameElement : document;
                        }

                        tmp_child = parent_node.firstChild;
                        if (typeof tmp_child === "undefined") {
                            return xpath;
                        }

                        for (j = 0; tmp_child; tmp_child = tmp_child.nextSibling) {
                            if (tmp_child.nodeType === 1 && tmp_child.tagName === node.tagName) {
                                if (tmp_child === node) {
                                    xpath[xpath.length] = [node.tagName, j];
                                    break;
                                }
                                j += 1;
                            }
                        }
                        node = parent_node;
                    }

                    if (idValid) {
                        xpath[xpath.length] = [node.id];
                        if (core.utils.isIFrameDescendant(node)) {
                            loop = true;
                            node = core.utils.getWindow(node).frameElement;
                        }
                    }
                }
            }

            return xpath;
        }

        // actual getXPathFromNode function
        return function (node) {
            var xpath = getXPathArrayFromNode(node),
                parts = [],
                i = xpath.length;

            if (i < 1) {
                return "null";
            }
            while (i) {
                i -= 1;
                if (xpath[i].length > 1) {
                    parts[parts.length] = '["' + xpath[i][0] + '",' + xpath[i][1] + "]";
                } else {
                    parts[parts.length] = '[' + serializerService.serialize(xpath[i][0], "json") + ']';
                }
            }
            return ("[" + parts.join(",") + "]");
        };
    }());

    /**
     * Returns the scroll position (left, top) of the document
     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX
     * @private
     * @param {DOMObject} doc The document object.
     * @return {Object} An object specifying the document's scroll offset position {left, top}
     */
    function getDocScrollPosition(doc) {
        var scrollPos = {
                left: -1,
                top: -1
            },
            docElement;

        doc = doc || document;
        // Get the scrollLeft, scrollTop from documentElement or body.parentNode or body in that order.
        docElement = doc.documentElement || doc.body.parentNode || doc.body;

        // If window.pageXOffset exists, use it. Otherwise fallback to getting the scrollLeft position.
        scrollPos.left = (typeof window.pageXOffset === "number") ? window.pageXOffset : docElement.scrollLeft;
        scrollPos.top = (typeof window.pageYOffset === "number") ? window.pageYOffset : docElement.scrollTop;

        return scrollPos;
    }

    /**
     * Returns true if an event is a jQuery event wrpper object.
     * @private
     * @param {UIEvent} event Browser event to examine
     * @return {boolean} true if given event is jQuery event
     */
    function isJQueryEvent(event) {
        return event && typeof event.originalEvent !== "undefined" &&
            typeof event.isDefaultPrevented !== "undefined"  &&
            !event.isSimulated;
    }


    /**
     * Looks for event details. Usually it returns an event itself, but for touch events
     * function returns an element from one of the touch arrays.
     * @private
     * @param {UIEvent} event Browser event. If skipped function will look for window.event
     * @return {UIEvent} latest touch details for touch event or original event object
     *          for all other cases
     */
    function getEventDetails(event) {
        if (!event) {
            return null;
        }
        if (event.type && event.type.indexOf("touch") === 0) {
            if (isJQueryEvent(event)) {
                event = event.originalEvent;
            }
            if (event.type === "touchstart") {
                event = event.touches[event.touches.length - 1];
            } else if (event.type === "touchend") {
                event = event.changedTouches[0];
            }
        }
        return event;
    }


    /**
     * Normalizes the event object for InternetExplorer older than 9.
     * @return {HttpEvent} normalized event object
     */
    function normalizeEvent(event) {
        var e = event || window.event,
            doc = document.documentElement,
            body = document.body,
            found = false,
            foundElement = null,
            i = 0;

        // skip jQuery event wrapper
        if (isJQueryEvent(e)) {
            e = e.originalEvent;
        }

        // IE case
        if (typeof event === 'undefined' || typeof e.target === 'undefined') {
            e.target = e.srcElement || window.window;
            e.timeStamp = Number(new Date());
            if (e.pageX === null || typeof e.pageX === "undefined") {
                e.pageX = e.clientX + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
                    ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
                e.pageY = e.clientY + ((doc && doc.scrollTop)  || (body && body.scrollTop)  || 0) -
                    ((doc && doc.clientTop)  || (body && body.clientTop)  || 0);
            }
            e.preventDefault = function () {
                this.returnValue = false;
            };
            e.stopPropagation = function () {
                this.cancelBubble = true;
            };
        }

        // Chrome case getting blur for inner elements sending click
        if (window.chrome && e.path !== undefined && e.type === "click") {
            if (e.path.length === undefined) {
                return e;
            }

            for (i = 0; i < e.path.length; i++) {
                if (e.path[i].tagName === "BUTTON") {
                    found = true;
                    foundElement = e.path[i];
                    i = e.path.length;
                }
            }
            if (found) {
                return {
                    originalEvent: e,
                    target: foundElement,
                    srcElement: foundElement,
                    type: e.type,
                    pageX: document.body.scrollLeft + foundElement.getBoundingClientRect().left,
                    pageY: document.body.scrollTop + foundElement.getBoundingClientRect().top
                };
            }
        }

        return e;
    }

    /**
     * Normalizes target element. In case of touch event the target is considered to be an
     * element for whch the last action took place
     * @private
     * @param {UIEvent} event browser event
     * @return {Element} DOM element
     */
    function normalizeTarget(event) {
        var itemSource = null;

        if (!event) {
            return null;
        }

        if (event.srcElement) {
            // IE
            itemSource = event.srcElement;
        } else {
            // W3C
            itemSource = event.target;
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.explicitOriginalTarget;
            }
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.originalTarget;
            }
        }

        if (!itemSource && event.type.indexOf("touch") === 0) {
            itemSource = getEventDetails(event).target;
        }

        while (itemSource && nonClickableTags[itemSource.tagName]) {
            itemSource = itemSource.parentNode;
        }

        // IE when srcElement pointing to window
        if (!itemSource && event.srcElement === null) {
            itemSource = window.window;
        }

        return itemSource;
    }


    /**
     * Returns event position independently to the event type.
     * In case of touch event the position of last action will be returned.
     * @private
     * @param {UIEvent} event Browser event
     * @return {Object} object containing x and y properties
     */
    function getEventPosition(event) {
        var posX = 0,
            posY = 0,
            doc = document.documentElement,
            body = document.body;

        event = getEventDetails(event);

        if (event) {
            if (event.pageX || event.pageY) {
                posX = event.pageX;
                posY = event.pageY;
            } else if (event.clientX || event.clientY) {
                posX = event.clientX + (doc ? doc.scrollLeft : (body ? body.scrollLeft : 0)) -
                                       (doc ? doc.clientLeft : (body ? body.clientLeft : 0));
                posY = event.clientY + (doc ? doc.scrollTop : (body ? body.scrollTop : 0)) -
                                       (doc ? doc.clientTop : (body ? body.clientTop : 0));
            }
        }

        return {
            x: posX,
            y: posY
        };
    }

    /**
     * Find one or more elements using a XPath selector.
     * @function
     * @name browserService-queryDom.xpath
     * @param  {String} query The XPath query to search for.
     * @param  {Object} [scope="document"] The DOM subtree to run the query in.
     * @return {Object}       Returns the DOM element matching the XPath.
     */
    queryDom.xpath = function (query, scope) {
        var xpath = null,
            elem,
            pathElem = null,
            i,
            j,
            k,
            len,
            jlen;

        // Sanity check
        if (!query) {
            return null;
        }

        xpath = serializerService.parse(query);
        scope = scope || document;
        elem = scope;

        if (!xpath) {
            return null;
        }

        for (i = 0, len = xpath.length; i < len && elem; i += 1) {
            pathElem = xpath[i];
            if (pathElem.length === 1) {
                if (scope.getElementById) {
                    elem = scope.getElementById(pathElem[0]);
                } else if (scope.querySelector) {
                    elem = scope.querySelector("#" + pathElem[0]);
                } else {
                    elem = null;
                }
            } else {
                for (j = 0, k = -1, jlen = elem.childNodes.length; j < jlen; j += 1) {
                    if (elem.childNodes[j].nodeType === 1 && elem.childNodes[j].tagName.toUpperCase() === pathElem[0]) {
                        k += 1;
                        if (k === pathElem[1]) {
                            elem = elem.childNodes[j];
                            break;
                        }
                    }
                }
                if (k === -1) {
                    return null;
                }
            }
        }

        return (elem === scope || !elem) ? null : elem;
    };


    /**
     * The Point interface represents a point on the page to
     *     x- and y-coordinates.
     * @constructor
     * @private
     * @name browserService-Point
     * @param {Integer} x The x-coordinate of the point.
     * @param {Integer} y The y-coordinate of the point.
     */
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }


    /**
     * The Size  interface represents the width and height of an element
     *     on the page.
     * @constructor
     * @private
     * @name browserService-Size
     * @param {Integer} width  Width of the element that received the event.
     * @param {Integer} height Height of the element that received the event.
     */
    function Size(width, height) {
        this.width = width || 0;
        this.height = height || 0;
    }


    /**
     * The ElementData interface represents a normalized browser event object.
     * @constructor
     * @private
     * @name browserService-ElementData
     * @param {Object} event  The browser event.
     * @param {Object} target The HTML element which received the event.
     */
    function ElementData(event, target) {
        var id,
            elementType,
            pos;

        target = normalizeTarget(event);
        id = this.examineID(target);
        elementType = getElementType(target);
        pos = this.examinePosition(event, target);

        this.element = target;
        this.id = id.id;
        this.idType = id.type;
        this.type = elementType.type;
        this.subType = elementType.subType;
        this.state = this.examineState(target);
        this.position = new Point(pos.x, pos.y);
        this.size = new Size(pos.width, pos.height);
        this.xPath = id.xPath;
        this.name = id.name;
    }

    /**#@+
     * @constant
     * @enum {Number}
     * @fieldOf browserService-ElementData
     */
    ElementData.HTML_ID = -1;
    ElementData.XPATH_ID = -2;
    ElementData.ATTRIBUTE_ID = -3;
    /**#@-*/

    /**
     * Examines how to specify the target element
     *     (either by css selectors or xpath)
     *     and returns an object with the properties id and type.
     * @function
     * @name browserService-ElementData.examineID
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object with the properties id and type.
     *      id contains either a css or xpath selector.
     *      type contains a reference to either ElementData.HTML_ID,
     *      ElementData.XPATH_ID or ElementData.ATTRIBUTE_ID
     * @todo determine the element css/xpath/attribute selector.
     */
    ElementData.prototype.examineID = function (target) {
        var id,
            type,
            xPath,
            attribute_id,
            name,
            i = customid.length,
            attrib;

        try {
            xPath = getXPathFromNode(target);
        } catch (e) { }
        name = target.name;

        try {
            if (!core.utils.isIFrameDescendant(target)) {

                if (checkId(target)) {
                    id = target.id;
                    type = ElementData.HTML_ID;
                } else if (customid.length && target.attributes) {
                    while (i) {
                        i -= 1;
                        attrib = target.attributes[customid[i]];
                        if (typeof attrib !== "undefined") {
                            id = customid[i] + "=" + (attrib.value || attrib);
                            type = ElementData.ATTRIBUTE_ID;
                        }
                    }
                }
            }
        } catch (e2) { }

        if (!id) {
            id = xPath;
            type = ElementData.XPATH_ID;
        }

        return {
            id: id,
            type: type,
            xPath: xPath,
            name: name
        };
    };


    /**
     * Examines the current state of the HTML element if it's an input/ui element.
     * @function
     * @name browserService-ElementData.examineState
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object which contains all properties
     *     to describe the state.
     * @todo determine the current state.
     */
    ElementData.prototype.examineState = function (target) {
        var tagnames = {
                "a": ["innerText", "href"],
                "input": {
                    "range": ["maxValue:max", "value"],
                    "checkbox": ["value", "checked"],
                    "radio": ["value", "checked"],
                    "image": ["src"]
                },
                "select": ["value"],
                "button": ["value", "innerText"],
                "textarea": ["value"]
            },
            tagName = typeof target.tagName !== "undefined" ? target.tagName.toLowerCase() : "",
            properties = tagnames[tagName] || null,
            selectedOption = null,
            values = null,
            i = 0,
            len = 0,
            alias = null,
            key = "";

        if (properties !== null) {
            // For input elements, another level of indirection is required
            if (Object.prototype.toString.call(properties) === "[object Object]") {
                // default state for input elements is represented by the "value" property
                properties = properties[target.type] || ["value"];
            }
            values = {};
            for (key in properties) {
                if (properties.hasOwnProperty(key)) {
                    if (properties[key].indexOf(":") !== -1) {
                        alias = properties[key].split(":");
                        values[alias[0]] = target[alias[1]];
                    } else if (properties[key] === "innerText") {
                        values[properties[key]] = core.utils.trim(target.innerText || target.textContent);
                    } else {
                        values[properties[key]] = target[properties[key]];
                    }
                }
            }
        }

        // Special processing for select lists
        if (tagName === "select" && target.options && !isNaN(target.selectedIndex)) {
            values.index = target.selectedIndex;
            if (values.index >= 0 && values.index < target.options.length) {
                selectedOption = target.options[target.selectedIndex];
                /* Select list value is derived from the selected option's properties
                 * in the following order:
                 * 1. value
                 * 2. label
                 * 3. text
                 * 4. innerText
                 */
                values.value = selectedOption.getAttribute("value") || selectedOption.getAttribute("label") || selectedOption.text || selectedOption.innerText;
                values.text = selectedOption.text || selectedOption.innerText;
            }
        }

        return values;
    };


    /**
     * Gets the current zoom value of the browser with 1 being equivalent to 100%.
     * @function
     * @name getZoomValue
     * @return {int}        Returns zoom value of the browser.
     */
    function getZoomValue() {
        var factor = 1,
            rect,
            physicalW,
            logicalW;

        if (document.body.getBoundingClientRect) {
            // rect is only in physical pixel size in IE before version 8
            // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
            // on IE 9
            try {
                rect = document.body.getBoundingClientRect();
            } catch (e) {
                core.utils.clog("getBoundingClientRect failed.", e);
                return factor;
            }
            physicalW = rect.right - rect.left;
            logicalW = document.body.offsetWidth;

            // the zoom level is always an integer percent value
            factor = Math.round((physicalW / logicalW) * 100) / 100;
        }
        return factor;
    }

    /**
     * Gets BoundingClientRect value from a HTML element.
     * @function
     * @name getBoundingClientRectNormalized
     * @param  {Object} element The HTML element.
     * @return {Object} An object with x, y, width, and height.
     */
    function getBoundingClientRectNormalized(element) {
        var rect,
            rectangle,
            zoom,
            scrollPos;

        if (!element || !element.getBoundingClientRect) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
        // on IE 9
        try {
            rect = element.getBoundingClientRect();
            scrollPos = getDocScrollPosition(document);
        } catch (e) {
            core.utils.clog("getBoundingClientRect failed.", e);
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        rectangle = {
            // Normalize viewport-relative left & top with scroll values to get left-x & top-y relative to the document
            x: rect.left + scrollPos.left,
            y: rect.top + scrollPos.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
        if (core.utils.isIE) {
            // IE ONLY: the bounding rectangle include the top and left borders of the client area
            rectangle.x -= document.documentElement.clientLeft;
            rectangle.y -= document.documentElement.clientTop;

            zoom = getZoomValue();
            if (zoom !== 1) {  // IE 7 at non-default zoom level
                rectangle.x = Math.round(rectangle.x / zoom);
                rectangle.y = Math.round(rectangle.y / zoom);
                rectangle.width = Math.round(rectangle.width / zoom);
                rectangle.height = Math.round(rectangle.height / zoom);
            }
        }
        return rectangle;
    }

    /**
     * Examines the position of the event relative to the HTML element which
     * received the event on the page. The top left corner of the element is 0,0
     * and bottom right corner of the element is equal to it's width, height.
     * @function
     * @name browserService-ElementData.examinePosition
     * @param  {Object} target The HTML element which received the event.
     * @return {Point}        Returns a Point object.
     */
    ElementData.prototype.examinePosition = function (event, target) {
        var posOnDoc = getEventPosition(event),
            elPos = getBoundingClientRectNormalized(target);

        elPos.x = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.x - elPos.x)) : elPos.width / 2;
        elPos.y = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.y - elPos.y)) : elPos.height / 2;

        return elPos;
    };


    /**
     * The WebEvent  interface represents a normalized browser event object.
     *     When an event occurs, the BrowserService wraps the native event
     *     object in a WebEvent.
     * @constructor
     * @private
     * @name browserService-WebEvent
     * @param {Object} event The native browser event.
     */
    function WebEvent(event) {
        var pos,
            eventType;

        this.data = event.data || null;
        this.delegateTarget = event.delegateTarget || null;

		//add the gesture event data to the webevent if it exists.
		if (event.gesture || (event.originalEvent && event.originalEvent.gesture)) {
			this.gesture = event.gesture || event.originalEvent.gesture;
		}

        event = normalizeEvent(event);
        pos = getEventPosition(event);
        this.custom = false;    // @TODO: how to determine if it's a custom event?
        this.nativeEvent = this.custom === true ? null : event;
        this.position = new Point(pos.x, pos.y);
        this.target = new ElementData(event, event.target);
        // Do not rely on browser provided event.timeStamp since FF sets
        // incorrect values. Refer to Mozilla Bug 238041
        this.timestamp = (new Date()).getTime();

        eventType = getEventType(event, this.target);
        this.type = eventType.type;
        this.subType = eventType.subType;
    }

    function processDOMEvent(event) {
        core._publishEvent(new WebEvent(event));
    }


    return {
        // Expose private functions for unit testing
        normalizeEvent: normalizeEvent,
        normalizeTarget: normalizeTarget,
        getEventDetails: getEventDetails,
        getEventPosition: getEventPosition,
        getEventType: getEventType,
        getElementType: getElementType,
        getBoundingClientRectNormalized: getBoundingClientRectNormalized,
        checkId: checkId,
        getZoomValue: getZoomValue,
        getDocScrollPosition: getDocScrollPosition,
        init: function () {
            if (!isInitialized) {
                initBrowserBase();
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(browserBaseService)");
            }
        },
        destroy: function () {
            destroy();
        },
        WebEvent: WebEvent,
        ElementData: ElementData,
        processDOMEvent: processDOMEvent,

        getXPathFromNode: function (moduleName, node) {
            return getXPathFromNode(node);
        },
        getNodeFromID: getNodeFromID,
        queryDom: queryDom
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT:true, XPathResult:true, document: true */
/*global console: false */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browser", function (core) {
    "use strict";

    var jQuery,
        queryDom,
        handlerMappings,
        errorCodes = {
            JQUERY_NOT_SUPPORTED: "JQUERYNOTSUPPORTED",
            JQUERY_NOT_FOUND: "JQUERYNOTFOUND"
        },
        configService = core.getService("config"),
        base = core.getService('browserBase'),
        browser  = configService.getServiceConfig("browser") || {},
        // from w3c
        addEventListener = null,
        removeEventListener = null,
        isInitialized = false;


    /**
     * Returns a new function which will be used in the subscribe method and
     *     which calls the handler function with the normalized WebEvent.
     * @private
     * @function
     * @name browserService-wrapWebEvent
     * @param  {Function} handler The handler which was passed to the
     *     browserService's subscribe method.
     * @return {Function}         Returns a new function which, when called,
     *     passes a WebEvent to the handler.
     */
    function wrapWebEvent(handler) {
        return function (event) {
            var webEvent = new base.WebEvent(event);
            handler(webEvent);
        };
    }


    /**
     * Check wether a certain method exists on the jQuery object. If not an exception is thrown.
     * @function
     * @private
     * @name browserService-jQueryFnExists
     * @param  {Objcet} object   The jQuery object.
     * @param  {String} property The methodname te test for.
     */
    function jQueryFnExists(object, property) {
        if (typeof object[property] !== "function") {
            core.fail("jQuery Object does not support " + property, errorCodes.JQUERY_NOT_SUPPORTED);
        }
    }


    /**
     * Check for correct jQuery version and methods.
     * Throws an exception if jQuery is not supported by the library.
     * @function
     * @private
     * @name browserService-verifyJQuery
     */
    function verifyJQuery() {
        var wrapperFunctions = ["on", "off"],
            jQFunctions = ["ajax", "find", "getScript"],
            jQVersion = (typeof jQuery === "function" && typeof jQuery.fn === "object") ? jQuery.fn.jquery : 0,
			jQVersionMajor = jQVersion !== 0 ? parseInt(jQVersion.split(".")[0], 10) : 0,
			jQVersionMinor = jQVersion !== 0 ? parseInt(jQVersion.split(".")[1], 10) : 0,
            i,
            len = 0,
            dummyWrapper = null;
        if (typeof jQuery !== "function") {
            core.fail("jQuery not found.", errorCodes.JQUERY_NOT_FOUND);
        }

        for (i = 0, len = jQFunctions.length; i < len; i += 1) {
            jQueryFnExists(jQuery, jQFunctions[i]);
        }

        for (i = 0, len = wrapperFunctions.length, dummyWrapper = jQuery({}); i < len; i += 1) {
            jQueryFnExists(dummyWrapper, wrapperFunctions[i]);
        }

        if (!(jQVersionMajor >= 2 || (jQVersionMajor === 1 && jQVersionMinor >= 7))) {
            core.fail("jQuery Object has the wrong version (" + jQVersion + ")", errorCodes.JQUERY_NOT_SUPPORTED);
        }
    }


    /**
     * @private
     * @namespace
     * @name browserService-queryDom
     */
    queryDom = {
        /**
         * Helper function to transform a nodelist into an array.
         * @function
         * @name browserService-queryDom.list2Array
         * @param  {List} nodeList Pass in a DOM NodeList
         * @return {Array}          Returns an array.
         */
        list2Array: function (nodeList) {
            var len = nodeList.length,
                result = [],
                i;

            // Sanity check
            if (!nodeList) {
                return result;
            }

            if (typeof nodeList.length === "undefined") {
                return [nodeList];
            }

            for (i = 0; i < len; i += 1) {
                result[i] = nodeList[i];
            }
            return result;
        },

        /**
         * Finds one or more elements in the DOM using a CSS or XPath selector
         * and returns an array instead of a NodeList.
         * @function
         * @name browserService-queryDom.find
         * @param  {String} query Pass in a CSS or XPath selector query.
         * @param  {Object} [scope="document"]  The DOM subtree to run the query in.
         *      If not provided, document is used.
         * @param  {String} [type="css"]  The type of query. Either "css' (default)
         *      or 'xpath' to allow XPath queries.
         * @return {Array}       Returns an array of nodes that matches the particular query.
         */
        find: function (query, scope, type) {
            type = type || "css";
            return this.list2Array(this[type](query, scope));
        },

        /**
         * Find one or more elements using a CSS selector.
         * @function
         * @name browserService-queryDom.css
         * @param  {String} query The CSS selector query.
         * @param  {Object} [scope="document"] The DOM subtree to run the query in.
         * @return {Array}       Returns an array of nodes that matches the particular query.
         */
        css: function (query, scope) {
            scope = scope || document;
            return jQuery(scope).find(query).get();
        }
    };

    // store handler functions which got passed to subscribe/unsubscribe.
    handlerMappings = (function () {
        var data = new core.utils.WeakMap();

        return {
            add: function (originalHandler) {
                var handlers = data.get(originalHandler) || [wrapWebEvent(originalHandler), 0];

                handlers[1] += 1;
                data.set(originalHandler, handlers);
                return handlers[0];
            },

            find: function (originalHandler) {
                var handlers = data.get(originalHandler);
                return handlers ? handlers[0] : null;
            },

            remove: function (originalHandler) {
                var handlers = data.get(originalHandler);
                if (handlers) {
                    handlers[1] -= 1;
                    if (handlers[1] <= 0) {
                        data.remove(originalHandler);
                    }
                }
            }
        };
    }());

    /**
     * Initialization function
     * @function
     */
    function initBrowserServiceJQuery(config) {
        var useCapture = (browser.useCapture === true);

        queryDom.xpath = base.queryDom.xpath;

        // find jQuery object
        if (config.hasOwnProperty("jQueryObject")) {
            jQuery = core.utils.access(config.jQueryObject);
        } else {
            jQuery = window.jQuery;
        }

        // verify jQuery
        verifyJQuery();

        // register event functions
        if (useCapture && typeof document.addEventListener === 'function') {
            addEventListener = function (target, eventName, handler) {
                var _handler = function (e) { handler(jQuery.event.fix(e)); };
                target.addEventListener(eventName, _handler, useCapture);
            };
            removeEventListener = function (target, eventName, handler) {
                var _handler = function (e) { handler(jQuery.event.fix(e)); };
                target.removeEventListener(eventName, _handler, useCapture);
            };
        } else {
            jQueryFnExists(jQuery({}), "on");
            addEventListener = function (target, eventName, handler) {
                jQuery(target).on(eventName, handler);
            };
            jQueryFnExists(jQuery({}), "off");
            removeEventListener = function (target, eventName, handler) {
                jQuery(target).off(eventName, handler);
            };
        }

        isInitialized = true;
    }


    /**
     * @scope browserService
     */
    return {
        jQueryFnExists: jQueryFnExists,
        verifyJQuery: verifyJQuery,
        handlerMappings: handlerMappings,

        /**
         * Initializes the service
         */
        init: function () {
            if (!isInitialized) {
                initBrowserServiceJQuery(configService.getServiceConfig("browser") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(browserService.jQuery)");
            }
        },

        /**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

        /**
         * Returns service name
         */
        getServiceName: function () {
            return "jQuery";
        },

        /**
         * Find a single element in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object|null}       The first matching HTML element or null if not found.
         */
        query: function (query, scope, type) {
            jQueryFnExists(jQuery, "find");
            try {
				return queryDom.find(query, scope, type)[0] || null;
			} catch (err) {
				console.log(err.message);
				return [];
			}
        },

        /**
         * Find all elements in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object[]|Array}       An array of HTML elements matching the query
         *     or and empty array if no elements are matching.
         */
        queryAll: function (query, scope, type) {
            jQueryFnExists(jQuery, "find");
            try {
				return queryDom.find(query, scope, type);
			} catch (err) {
				console.log(err.message);
				return [];
			}
        },

        /**
         * Loads a JavaScript file onto the current page.
         * @param  {String} url The URL of the JavaScript file to load.
         */
        loadScript: function (url) {
            jQueryFnExists(jQuery, "getScript");
            jQuery.getScript(url);
        },


        /**
         * Subscribes an event handler to be called when a particular event occurs.
         * @param  {String} eventName The name of the event to listen for.
         * @param  {Object} target    The object on which the event will fire.
         * @param  {Function} handler   The function to call when the event occurs.
         *     The browserServices passes a WebEvent object to this handler
         * @param  {Object} [delegateTarget] The delegated target on which the event will fire.
         * @param  {String} [data] The token data which will be returned as event.data when the event triggers.
         */
        subscribe: function (eventName, target, handler, delegateTarget, data) {
            var wrappedHandler = handlerMappings.add(handler);

            jQueryFnExists(jQuery({}), "on");

            if (!delegateTarget) {
                addEventListener(target, eventName, wrappedHandler);
            } else {
                jQuery(delegateTarget).on(eventName, target, data, wrappedHandler);
            }
        },

        /**
         * Unsubscribes an event handler from a particular event.
         * @param  {String} eventName The name of the event for which the handler was subscribed.
         * @param  {Object} target    The object on which the event fires.
         * @param  {Function} handler   The function to remove as an event handler.
         * @param  {Object} delegateTarget The delegated target on which the event fires.
         */
        unsubscribe: function (eventName, target, handler, delegateTarget) {
            jQueryFnExists(jQuery({}), "off");
            var wrappedHandler = handlerMappings.find(handler);
            if (wrappedHandler) {
                try {
                    if (!delegateTarget) {
                        removeEventListener(target, eventName, wrappedHandler);
                    } else {
                        jQuery(delegateTarget).off(eventName, target, wrappedHandler);
                    }
                } catch (e) {
                    core.utils.clog("Unsubscribe failed for event: " + eventName + "\n" + e.message);
                }
                handlerMappings.remove(handler);
            }
        },

        /**
         * Returns a reference to jQuery object used by the service
         * @return {Object} reference to jQuery used by the service
         */
        getJQuery: function () {
            return jQuery;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*global TLT:true, window: true */

/**
 * @name ajaxService
 * @namespace
 */
TLT.addService("ajax", function (core) {
    "use strict";

    var makeAjaxCall,
        configService = core.getService("config"),
        browser = core.getService('browser'),
        jQuery,
        isInitialized = false;

    /**
     * Builds an object of key => value pairs of HTTP headers from a string.
     * @param  {String} headers The string of HTTP headers separated by newlines
     *      (i.e.: "Content-Type: text/html\nLast-Modified: ..")
     * @return {Object}         Returns an object where every key is a header
     *     and every value it's correspondending value.
     */
    function extractResponseHeaders(headers) {
        headers = headers.split('\n');
        var headersObj = {},
            i = 0,
            len = headers.length,
            header = null;
        for (i = 0; i < len; i += 1) {
            header = headers[i].split(': ');
            headersObj[header[0]] = header[1];
        }
        return headersObj;
    }

    /**
     * This function returns a function which can be passed to the jQuery ajax call
     * as callback handler.
     * It will call the sendRequest callback with the correct ajaxResponse interface.
     * @private
     * @function
     * @name browserService-wrapAjaxResponse
     * @param  {Function} complete The original callback function which should be when
     *      the request finishes.
     * @return {Function}          A function which could be passed as a callback handler to
     *      the jquery ajax handler.
     */
    function wrapAjaxResponse(complete) {
        /**
         * Calls the ajax callback function and provides the ajaxResponse in the correct format.
         * This Function gets called by the jQuery ajax callback method.
         * @private
         * @function
         * @name browserService-wrapAjaxResponse-ajaxResponseHandler
         * @param  {Object} jqXhrError   In case of an error this object would become the jqXhr object
         *      otherwise it's the parsed data.
         * @param  {String} status       The status of the ajax call as textstring.
         * @param  {Object} jqXhrSuccess In case of a successfull ajax request this object would
         *      become the jqXhr object.
         */
        return function ajaxResponseHandler(jqXhrError, status, jqXhrSuccess) {
            var jqXhr = jqXhrError,
                success = false;
            if (status === "success") {
                jqXhr = jqXhrSuccess || jqXhrError;
                success = true;
            }
            complete({
                headers: extractResponseHeaders(jqXhr.getAllResponseHeaders()),
                responseText: jqXhr.responseText,
                statusCode: jqXhr.status,
                success: success
            });
        };
    }

    /**
     * @private
     * @function
     * @name browserService-makeAjaxCall
     * @see browserService.sendRequest
     */
    makeAjaxCall = {
        /**
         * @see browserService.sendRequest
         */
        init: function (message) {
            var version = parseFloat(jQuery.fn.jquery);

            if (version <= 1.7) {
                this.init = makeAjaxCall["jQuery<=1.7"];
            } else {
                this.init = makeAjaxCall["jQuery>=1.8"];
            }
            this.init(message);
        },

        /**
         * @see browserService.sendRequest
         */
        "jQuery<=1.7": function (message) {
            message.complete = wrapAjaxResponse(message.oncomplete);
            delete message.oncomplete;
            jQuery.ajax(message);
        },

        /**
         * @see browserService.sendRequest
         */
        "jQuery>=1.8": function (message) {
            var oncomplete = wrapAjaxResponse(message.oncomplete),
                jqXhr;
            delete message.oncomplete;
            jqXhr = jQuery.ajax(message.url, message);
            browser.jQueryFnExists(jqXhr, "always");
            jqXhr.always(oncomplete);
		}
	};

	function initAjaxService(config) {
		// find jQuery object
		if (config.hasOwnProperty("jQueryObject")) {
			jQuery = core.utils.access(config.jQueryObject);
		} else {
			jQuery = window.jQuery;
		}

		isInitialized = true;
	}

	return {
		init: function () {
			if (!isInitialized) {
				initAjaxService(configService.getServiceConfig("browser") || {});
			} else {
				core.utils.clog("Attempt to initialize service which has been already initialized(ajaxService.jQuery)");
			}
		},

		/**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

		/**
         * Makes an Ajax request to the server.
         * @param {Object} message An AjaxRequest object containing all the information
         *     neccessary for making the request.
         * @param {String} [message.contentType] Set to a string to override the default
         *     content type of the request.
         * @param {String} [message.data] A string containing data to POST to the server.
         * @param {Object} [message.headers] An object whose properties represent HTTP headers.
         * @param {Function} message.oncomplete A callback function to call when the
         *     request has completed.
         * @param {Number} [message.timeout] The number of milliseconds to wait
         *     for a response before closing the Ajax request.
         * @param {String} [message.type="POST"] Either 'GET' or 'POST',
         *     indicating the type of the request to make.
         * @param {String} message.url The URL to send the request to.
         *     This should contain any required query string parameters.
         */
        sendRequest: function (message) {
            browser.jQueryFnExists(jQuery, "ajax");
            message.type = message.type || "POST";
            message.processData = message.processData || false;
            makeAjaxCall.init(message);
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The DOM Capture Service provides the ability to capture a snapshot of
 * the DOM as a HTML snippet.
 * @exports domCaptureService
 */

/*global TLT:true, window: true, Node:true */
/*global console: false */

/**
 * @name domCaptureService
 * @namespace
 */
TLT.addService("domCapture", function (core) {
    "use strict";

    var configService = core.getService("config"),
        messageService,
        isInitialized = false,
        tltUniqueIDIndex = 1,
        dupNode = function () {},
        getDOMCapture = function () {},
        updateConfig = function () {};

    /**
     * Initialization of the service. Subscribe with config service for
     * the configupdated message.
     * @private
     * @function
     * @param {object} config
     */
    function initDOMCaptureService(config) {
        configService.subscribe("configupdated", updateConfig);
        messageService = core.getService("message");
        isInitialized = true;
    }

    /**
     * Destroy the service. Unsubscribe from the configupdated message.
     * @private
     * @function
     */
    function destroyDOMCaptureService() {
        configService.unsubscribe("configupdated", updateConfig);
        isInitialized = false;
    }

    /**
     * Returns a unique identifier string.
     * @private
     * @function
     * @returns {String} A string that can be used as a unique identifier.
     */
    function getUniqueID() {
        var id;

        id = "tlt-" + core.utils.getSerialNumber();

        return id;
    }

    /**
     * Remove child nodes matching the given tag name.
     * @private
     * @function
     * @param {DOMNode} node The root or parent DOM Node element
     * @param {String}  tagName The tag to be removed
     * @returns The node without any tags matching tagName
     */
    function removeTags(node, tagName) {
        var i,
            nodeList;

        // Sanity check
        if (!node || !node.getElementsByTagName || !tagName) {
            return;
        }

        nodeList = node.getElementsByTagName(tagName);
        if (nodeList && nodeList.length) {
            for (i = nodeList.length - 1; i >= 0; i -= 1) {
                nodeList[i].parentNode.removeChild(nodeList[i]);
            }
        }

        return node;
    }

    /**
     * Returns the DOCTYPE of the document as a formatted string.
     * @private
     * @function
     * @param {DOMNode} node A document node.
     * @returns {String} The formatted doctype or null.
     */
    function getDoctypeAsString(node) {
        var doctype,
            doctypeStr = null;

        // Sanity check
        if (!node || !node.doctype) {
            return null;
        }

        doctype = node.doctype;
        if (doctype) {
            doctypeStr = "<!DOCTYPE " + doctype.name +
                         (doctype.publicId ? ' PUBLIC "' + doctype.publicId + '"' : "") +
                         (!doctype.publicId && doctype.systemId ? ' SYSTEM' : "") +
                         (doctype.systemId ? ' "' + doctype.systemId + '"' : "") +
                         ">";
        }

        return doctypeStr;
    }

    /**
     * Fix child input nodes and set attributes such as value & checked.
     * @private
     * @function
     * @param {DOMNode} target The root or parent DOM Node element
     */
    function fixInputs(target) {
        var i,
            j,
            inputElement,
            inputList,
            len,
            radio,
            radioButtons,
            radioLen;

        // Sanity check
        if (!target) {
            return;
        }

        inputList = target.getElementsByTagName("input");
        if (inputList) {
            for (i = 0, len = inputList.length; i < len; i += 1) {
                inputElement = inputList[i];
                switch (inputElement.type) {
                case "checkbox":
                case "radio":
                    if (inputElement.checked) {
                        inputElement.setAttribute("checked", "checked");
                    } else {
                        inputElement.removeAttribute("checked");
                    }
                    break;
                default:
                    inputElement.setAttribute("value", inputElement.value);
                    break;
                }
            }
        }
    }

    /**
     * Fix the child select lists by setting the selected attribute on the option elements of
     * the lists in the target node.
     * @private
     * @function
     * @param {DOMNode} source The root or parent DOM Node element
     * @param {DOMNode} target The target DOM Node element that is a copy of the source
     */
    function fixSelectLists(source, target) {
        var sourceElem,
            sourceList,
            targetElem,
            targetList,
            i,
            j,
            len;

        // Sanity check
        if (!source || !source.getElementsByTagName || !target || !target.getElementsByTagName) {
            return;
        }

        sourceList = source.getElementsByTagName("select");
        targetList = target.getElementsByTagName("select");

        // TODO: ASSERT source and target nodes have same order of select elements

        if (sourceList) {
            for (i = 0, len = sourceList.length; i < len; i += 1) {
                sourceElem = sourceList[i];
                targetElem = targetList[i];
                for (j = 0; j < sourceElem.options.length; j += 1) {
                    if (j === sourceElem.selectedIndex || sourceElem.options[j].selected) {
                        targetElem.options[j].setAttribute("selected", "selected");
                    } else {
                        targetElem.options[j].removeAttribute("selected");
                    }
                }
            }
        }
    }

    /**
     * Return the outer HTML of the document or element.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element
     * @returns {String} The HTML text of the document or element. If the node is not
     * a document or element type then return null.
     */
    function getHTMLText(node) {
        var nodeType,
            htmlText = null;

        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
                // DOCUMENT_NODE
                htmlText = node.documentElement.outerHTML;
                break;
            case 1:
                // ELEMENT_NODE
                htmlText = node.outerHTML;
                break;
            default:
                htmlText = null;
                break;
            }
        }
        return htmlText;
    }

    /**
     * Checks if the DOM node is allowed for capture. Only document and element
     * node types are allowed for capture.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element to be checked
     * @returns {Boolean} Returns true if the node is document or element type.
     */
    function isNodeValidForCapture(node) {
        var nodeType,
            valid = false;
        // Only DOCUMENT (9) & ELEMENT (1) nodes are valid for capturing
        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
            case 1:
                valid = true;
                break;
            default:
                valid = false;
                break;
            }
        }
        return valid;
    }

    /**
     * Capture the frames from the source and add the unique token to the frame element
     * in the target.
     * @private
     * @function
     * @param {DOMNode} source The source element
     * @param {DOMNode} target The target element duplicated from the source.
     * @param {Object}  options The capture options object
     * @returns {Object} Returns the captured frames & canvas elements as per the enabled options.
     */
    function getIframes(source, target, options) {
        var i, j,
            len,
            frameTag,
            frameTags = [ "iframe", "frame" ],
            sourceIframe,
            iframeWindow,
            iframeDoc,
            iframeCapture,
            iframeID,
            returnObject = {
                frames: [],
                canvas: []
            },
            sourceIframeList,
            targetIframeList;

        for (j = 0; j < frameTags.length; j += 1) {
            frameTag = frameTags[j];
            // Get the frames in the original DOM
            sourceIframeList = source.getElementsByTagName(frameTag);

            // Get the cloned frames - the content is not copied here - these will be
            // used to add an attribute to specify which item in the frames collection
            // contains the content for this frame
            targetIframeList = target.getElementsByTagName(frameTag);

            if (sourceIframeList) {
                for (i = 0, len = sourceIframeList.length; i < len; i += 1) {
                    try {
                        sourceIframe = sourceIframeList[i];
                        iframeWindow = core.utils.getIFrameWindow(sourceIframe);
                        if (iframeWindow && iframeWindow.document) {
                            iframeDoc = iframeWindow.document;

                            iframeCapture = getDOMCapture(iframeDoc, iframeDoc, options);
                            iframeID = getUniqueID();
                            // Set the tltid for this frame in the target DOM
                            targetIframeList[i].setAttribute("tltid", iframeID);

                            // Merge this frame's captured DOM into the return object
                            returnObject.frames.push({
                                root: iframeCapture.root,
                                charset: iframeDoc.characterSet || iframeDoc.charset,
                                tltid: iframeID
                            });
                            returnObject.frames = returnObject.frames.concat(iframeCapture.frames);
                            returnObject.canvas = returnObject.canvas.concat(iframeCapture.canvas);
                        }
                    } catch (e) {
                        // Do nothing!
                    }
                }
            }
        }
        return returnObject;
    }

    /**
     * Calculate the total length of the HTML in the captured object.
     * @private
     * @function
     * @param {Object} captureObj The DOM capture object containing the serialized HTML.
     * @returns {Number} Returns the total length of the serialized object.
     */
    function getCapturedLength(captureObj) {
        var i,
            len,
            totalLength = 0;

        if (!captureObj || !captureObj.root) {
            return totalLength;
        }

        totalLength = captureObj.root.length;
        for (i = 0, len = captureObj.frames.length; i < len; i += 1) {
            if (captureObj.frames[i].root) {
                totalLength += captureObj.frames[i].root.length;
            }
        }

        return totalLength;
    }

    /**
     * Clone the provided document or element node.
     * @private
     * @function
     * @param {DOMNode} node The element to be duplicated.
     * @returns {DOMNode} Returns the duplicated node.
     */
    dupNode = function (node) {
        var dup = null;

        if (isNodeValidForCapture(node)) {
            dup = node.cloneNode(true);
            if (!dup && node.documentElement) {
                // Fix for Android and Safari bug which returns null when cloneNode is called on the document element.
                dup = node.documentElement.cloneNode(true);
            }
        }

        return dup;
    };

    /**
     * Capture the DOM starting at the root element as per the provided configuration options.
     * @private
     * @function
     * @param {DOMNode} doc The document element.
     * @param {DOMNode} root The root element that needs to be captured.
     * @param {Object}  options The capture options object.
     * @returns {Object} Returns the object containing the captured and serialized DOM.
     */
    getDOMCapture = function (doc, root, options) {
        var new_doc = null,
            canvasCaptureList,
            frameCaptureObj,
            captureObj = {};

        // Sanity check
        if (!doc || !root) {
            return captureObj;
        }

        new_doc = dupNode(root, doc);

        // Remove script tags
        if (options.removeScripts) {
            removeTags(new_doc, "script");
        }

        // Set "selected" attribute on select list elements
        fixSelectLists(root, new_doc);

        // Set attributes on input elements.
        fixInputs(new_doc);

        // Apply privacy
        new_doc = messageService.applyPrivacyToDocument(new_doc);

        if (options.captureCanvas) {
            // TODO: Get the canvas elements
            canvasCaptureList = null;
        }

        if (options.captureFrames) {
            // Get the iframes
            frameCaptureObj = getIframes(root, new_doc, options);
        }

        // Add all the captured data to the capture object
        if (frameCaptureObj) {
            captureObj = core.utils.mixin(captureObj, frameCaptureObj);
        }
        if (canvasCaptureList) {
            if (!captureObj.canvas) {
                captureObj.canvas = [];
            }
            captureObj.canvas = captureObj.canvas.concat(canvasCaptureList);
        }
        captureObj.root = (getDoctypeAsString(root) || "") + getHTMLText(new_doc);
        captureObj.charset = doc.characterSet || doc.charset;

        return captureObj;
    };

    /**
     * Callback function which receives notification from config service when
     * the configuration is updated.
     * @private
     * @function
     */
    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
    };

    /**
     * @scope domCaptureService
     */
    return {
        // Expose private functions for unit testing
        updateConfig: updateConfig,
        getUniqueID: getUniqueID,
        removeTags: removeTags,
        getDoctypeAsString: getDoctypeAsString,
        fixInputs: fixInputs,
        fixSelectLists: fixSelectLists,
        getHTMLText: getHTMLText,
        isNodeValidForCapture: isNodeValidForCapture,
        getCapturedLength: getCapturedLength,
        dupNode: dupNode,
        /**
         * Callback function invoked by the core to initialize the DOM Capture service.
         * @private
         * @function
         */
        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(domCaptureService)");
            }
        },

        /**
         * Callback function invoked by the core to destroy the DOM Capture service.
         * @private
         * @function
         */
        destroy: function () {
            destroyDOMCaptureService();
        },

        /**
         * API function exposed by the DOM Capture service. Accepts the root element and
         * DOM capture options object.
         * @param  {DOMNode} root The root element for the DOM capture.
         * @param  {Object}  options The configuration options for performing the DOM capture.
         * @return {Object} An object containing the captured DOM.
         */
        captureDOM: function (root, options) {
            var captureObj = null,
                totalLength = 0;

            // Sanity check - DOM Capture is not supported on IE 8 and below
            if (!isInitialized || core.utils.isLegacyIE) {
                return captureObj;
            }

            if (!options || typeof options !== "object") {
                options = {};
            }
            root = root || window.document;

            captureObj = getDOMCapture(window.document, root, options);

            // Check if the capture meets the length threshold (if any)
            if (options.maxLength) {
                totalLength = getCapturedLength(captureObj);
                if (totalLength > options.maxLength) {
                    captureObj = {
                        errorCode: 101,
                        error: "Captured length (" + totalLength + ") exceeded limit (" + options.maxLength + ")."
                    };
                }
            }

            return captureObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The EncoderService provides the ability to extend the library with various data encodings.
 * @exports encoderService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name encoderService
 * @namespace
 */
TLT.addService("encoder", function (core) {
    "use strict";

    var encoderServiceConfig = {},
        configService = null,
        handleConfigUpdated = null,
        isInitialized = false;

    /**
     * Returns the encoder object for the specified encoder type.
     * @private
     * @function
     * @param {String} type The type of encoder object. e.g. "gzip"
     * @returns {Object} The encoder object or null if not found.
     */
    function getEncoder(type) {
        var encoder = null;

        // Sanity check
        if (!type) {
            return encoder;
        }
        encoder = encoderServiceConfig[type];
        if (encoder && typeof encoder.encode === "string") {
            encoder.encode = core.utils.access(encoder.encode);
        }

        return encoder;
    }

    /**
     * Initializes the encoder service.
     * @private
     * @function
     * @param {Object} config The configuration object for this service
     */
    function initEncoderService(config) {
        encoderServiceConfig = config;

        configService.subscribe("configupdated", handleConfigUpdated);
        isInitialized = true;
    }

    /**
     * Destroys the encoder service.
     * @private
     * @function
     */
    function destroy() {
        configService.unsubscribe("configupdated", handleConfigUpdated);

        isInitialized = false;
    }

    /**
     * Callback handler for the configupdated event. Refreshes the service configuration to the latest.
     * @private
     * @function
     */
    handleConfigUpdated = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initEncoderService(configService.getServiceConfig("encoder") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        // Expose private functions for unit testing
        handleConfigUpdated: handleConfigUpdated,
        getEncoder: getEncoder,

        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initEncoderService(configService.getServiceConfig("encoder") || {});
            } else {
                core.utils.clog("Attempt to initialize service (encoder) which has been already initialized.");
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Encodes data using specified encoder.
         * @param  {String} data The data to encode.
         * @param  {String} type The name of the encoder to use.
         * @return {Object} An object containing the encoded data or error message.
         */
        encode: function (data, type) {
            var encoder,
                result,
                returnObj = {
                    data: null,
                    encoding: null,
                    error: null
                };

            // Sanity check
            if ((typeof data !== "string" && !data) || !type) {
                returnObj.error = "Invalid " + (!data ? "data" : "type") + " parameter.";
                return returnObj;
            }

            // Get the specified encoder
            encoder = getEncoder(type);
            if (!encoder) {
                returnObj.error = "Specified encoder (" + type + ") not found.";
                return returnObj;
            }

            // Sanity check
            if (typeof encoder.encode !== "function") {
                returnObj.error = "Configured encoder (" + type + ") encode method is not a function.";
                return returnObj;
            }

            // Invoke the encode method of the encoder and return the result.
            result = encoder.encode(data);
            if (!result || core.utils.getValue(result, "buffer", null) === null) {
                returnObj.error = "Encoder (" + type + ") returned an invalid result.";
                return returnObj;
            }

            returnObj.data = result.buffer;
            returnObj.encoding = encoder.defaultEncoding;

            return returnObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The MessageService creates messages in the correct format to be transmitted to the server.
 * @exports messageService
 */

/*global TLT:true */

/**
 * @name messageService
 * @namespace
 */
TLT.addService("message", function (core) {
    "use strict";

    var screenviewOffsetTime = null,
        count             = 0,
        messageCount      = 0,
        sessionStart      = new Date(),
        tlStartLoad       = new Date(),
        browserBaseService = core.getService("browserBase"),
        browserService    = core.getService("browser"),
        configService     = core.getService("config"),
        config            = configService.getServiceConfig("message") || {},
        windowHref        = window.location.href,
        windowId          = "TODO",
        pageId            = "ID" + tlStartLoad.getHours() + "H" +
                            tlStartLoad.getMinutes() + "M" +
                            tlStartLoad.getSeconds() + "S" +
                            tlStartLoad.getMilliseconds() + "R" +
                            Math.random(),
        privacy           = config.hasOwnProperty("privacy") ? config.privacy : [],
        privacyMasks      = {},
        maskingCharacters = {
            lower: "x",
            upper: "X",
            numeric: "9",
            symbol: "@"
        },

        //TODO move these to a global section due to they might be used elsewhere
        isApple = navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPod") > -1 || navigator.userAgent.indexOf("iPad") > -1,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Android") > -1,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = window.screen ? window.screen.width : 0,
        deviceOriginalHeight = window.screen ? window.screen.height : 0,
        deviceOrientation = window.orientation || 0,
        deviceWidth = isApple || isAndroidChrome ? deviceOriginalWidth : deviceOriginalWidth <= 320 ? deviceOriginalWidth : deviceOriginalWidth / devicePixelRatio,
        deviceHeight = isApple || isAndroidChrome ? deviceOriginalHeight : deviceOriginalWidth <= 320 ? deviceOriginalHeight : deviceOriginalHeight / devicePixelRatio,
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        startWidth = window.innerWidth || document.documentElement.clientWidth,
        startHeight = window.innerHeight || document.documentElement.clientHeight,
        isInitialized = false;


    /**
     * Base structure for a message object.
     * @constructor
     * @private
     * @name messageService-Message
     * @param {Object} event The QueueEvent to transform into a message object.
     */
    function Message(event) {
        var key = '';

        /**
         * The message type.
         * @type {Number}
         * @see browserService-Message.TYPES
         */
        this.type          = event.type;
        /**
         * The offset from the beginning of the session.
         * @type {Number}
         */
        this.offset        = (new Date()).getTime() - sessionStart.getTime();
        /**
         * The offset from the most recent application context message.
         * @type {Number}
         */
        if ((event.type === 2) || (screenviewOffsetTime === null)) {
            screenviewOffsetTime = new Date();
        }
        this.screenviewOffset = (new Date()).getTime() - screenviewOffsetTime.getTime();

        /**
         * The count of the overall messages until now.
         * @type {Number}
         */
        this.count         = (messageCount += 1);

        /**
         * To indicate that user action came from the web.
         * @type {Boolean}
         */
        this.fromWeb       = true;

        // iterate over the properties in the queueEvent and add all the objects to the message.
        for (key in event) {
            if (event.hasOwnProperty(key)) {
                this[key] = event[key];
            }
        }
    }

    /**
     * Empty filter. Returns an empty string which would be used as value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns an empty string.
     */
    privacyMasks.PVC_MASK_EMPTY = function (value) {
        return "";
    };

    /**
     * Basic filter. Returns a predefined string for every value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a predefined mask/string.
     */
    privacyMasks.PVC_MASK_BASIC = function (value) {
        var retMask = "XXXXX";

        // Sanity check
        if (typeof value !== "string") {
            return "";
        }
        return (value.length ? retMask : "");
    };

    /**
     * Type filter. Returns predefined values for uppercase/lowercase
     *                         and numeric values.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a string/mask which uses predefined
     *                        characters to mask the value.
     */
    privacyMasks.PVC_MASK_TYPE = function (value) {
        var characters,
            i = 0,
            len = 0,
            retMask = "";

        // Sanity check
        if (typeof value !== "string") {
            return retMask;
        }

        characters = value.split("");

        for (i = 0, len = characters.length; i < len; i += 1) {
            if (core.utils.isNumeric(characters[i])) {
                retMask += maskingCharacters.numeric;
            } else if (core.utils.isUpperCase(characters[i])) {
                retMask += maskingCharacters.upper;
            } else if (core.utils.isLowerCase(characters[i])) {
                retMask += maskingCharacters.lower;
            } else {
                retMask += maskingCharacters.symbol;
            }
        }
        return retMask;
    };

    privacyMasks.PVC_MASK_EMPTY.maskType = 1; // reported value is empty string.
    privacyMasks.PVC_MASK_BASIC.maskType = 2; // reported value is fixed string "XXXXX".
    privacyMasks.PVC_MASK_TYPE.maskType = 3;  // reported value is a mask according to character type
                                              // as per configuration, e.g. "HelloWorld123" becomes "XxxxxXxxxx999".
    privacyMasks.PVC_MASK_CUSTOM = {
        maskType: 4 // reported value is return value of custom function provided by config.
    };

    /**
     * Checks which mask should be used to replace the value and applies
     * it to the string. If an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask The privacy object.
     * @param  {String} str  The string to be masked.
     */
    function maskStr(mask, str) {
        var filter = privacyMasks.PVC_MASK_BASIC;

        // Sanity check
        if (typeof str !== "string") {
            return str;
        }

        if (!mask) {
            // Default
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_EMPTY.maskType) {
            filter = privacyMasks.PVC_MASK_EMPTY;
        } else if (mask.maskType === privacyMasks.PVC_MASK_BASIC.maskType) {
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_TYPE.maskType) {
            filter = privacyMasks.PVC_MASK_TYPE;
        } else if (mask.maskType === privacyMasks.PVC_MASK_CUSTOM.maskType) {
            if (typeof mask.maskFunction === "string") {
                filter = core.utils.access(mask.maskFunction);
            } else {
                filter = mask.maskFunction;
            }
            if (typeof filter !== "function") {
                // Reset to default
                filter = privacyMasks.PVC_MASK_BASIC;
            }
        }
        return filter(str);
    }

    /**
     * Checks which mask should be used to replace the value and applies
     * it on the message object. By default, if an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask    The privacy object.
     * @param  {Object} message The entire message object.
     */
    function applyMask(mask, message) {
        // Sanity check
        if (!message || !message.target) {
            return;
        }

        if (typeof message.target.prevState !== "undefined" && message.target.prevState.hasOwnProperty("value")) {
            message.target.prevState.value = maskStr(mask, message.target.prevState.value);
        }
        if (typeof message.target.currState !== "undefined" && message.target.currState.hasOwnProperty("value")) {
            message.target.currState.value = maskStr(mask, message.target.currState.value);
        }
    }

    /**
     * Checks whether one of the privacy targets matches the target
     *                          of the current mesage.
     * TODO: There are several places in the library where the same type
     * of matching result is required based on id or selector. This should
     * be consolidated into a single helper function.
     * @param  {Array} targets An array of objects as defined in the
     *                         privacy configuration.
     * @param  {Object} target  The target object of the message.
     * @return {Boolean}         Returns true if one of the targets match.
     *                           Otherwise false.
     */
    function matchesTarget(targets, target) {
        var i,
            j,
            element,
            qr,
            qrLen,
            qrTarget,
            regex,
            len,
            tmpTarget;

        // Sanity check
        if (!targets || !target || !target.id) {
            return false;
        }

        for (i = 0, len = targets.length; i < len; i += 1) {
            tmpTarget = targets[i];

            // Check if target in config is a selector string.
            if (typeof tmpTarget === "string") {
                qr = browserService.queryAll(tmpTarget);
                for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                    if (qr[j]) {
                        qrTarget = browserBaseService.ElementData.prototype.examineID(qr[j]);
                        if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                            return true;
                        }
                    }
                }
            } else if (tmpTarget.id && tmpTarget.idType && target.idType.toString() === tmpTarget.idType.toString()) {
                // Note: idType provided by wizard is a string so convert both to strings before comparing.

                // An id in the configuration could be a direct match, in which case it will be a string OR
                // it could be a regular expression in which case it would be an object like this:
                // {regex: ".+private$", flags: "i"}
                switch (typeof tmpTarget.id) {
                case "string":
                    if (tmpTarget.id === target.id) {
                        return true;
                    }
                    break;
                case "object":
                    regex = new RegExp(tmpTarget.id.regex, tmpTarget.id.flags);
                    if (regex.test(target.id)) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    /**
     * Runs through all privacy configurations and checks if it matches
     * the current message object.
     * @param  {Object} message The message object.
     * @return {Object}         The message, either with replaced values
     *                          if a target of the privacy configuration
     *                          matched or the original message if the
     *                          configuration didn't match.
     */
    function privacyFilter(message) {
        var i,
            len,
            mask;

        if (!message || !message.hasOwnProperty("target")) {
            return message;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            if (matchesTarget(mask.targets, message.target)) {
                applyMask(mask, message);
                break;
            }
        }
        return message;
    }

    /**
     * Applies the privacy configuration to all the matching elements
     * of the specified document object.
     * @param  {DOMDocument} doc The document object to which the privacy rules
     *                      need to be applied.
     * @return {DOMDocument}     The document object to which the privacy rules
     *                      have been applied.
     */
    function applyPrivacyToDocument(doc) {
        var i, j, k,
            element,
            len,
            mask,
            qr,
            qrLen,
            target,
            targets,
            targetsLen;

        // Sanity check
        if (!doc) {
            return doc;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            targets = mask.targets;
            for (j = 0, targetsLen = targets.length; j < targetsLen; j += 1) {
                target = targets[j];
                if (typeof target === "string") {
                    // CSS selector
                    qr = browserService.queryAll(target, doc);
                    for (k = 0, qrLen = qr.length; k < qrLen; k += 1) {
                        element = qr[k];
                        if (element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                } else {
                    if (typeof target.id === "string") {
                        element = browserBaseService.getNodeFromID(target.id, target.idType, doc);
                        if (element && element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                    // TODO: Handle the case where the target.id is a regex.
                    /*
                     * 1. Save all the regex rules into 3 arrays depending on the idType
                     * {
                     *     htmlID: [ {regex, mask} ],
                     *     xpathID: [],
                     *     customID: []
                     * }
                     * 2. Outside this for loop, get all the input elements in the document
                     * 3. Get element id, idType
                     */
                }
            }
        }

        return doc;
    }

    /**
     * Gets called when the configserver fires configupdated event.
     */
    function updateConfig() {
        configService = core.getService("config");
        config = configService.getServiceConfig("message") || {};
        privacy = config.hasOwnProperty("privacy") ? config.privacy : [];
    }

    function initMessageService() {
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }


    /**
     * @scope messageService
     */
    return {
        privacyMasks: privacyMasks,
        applyMask: applyMask,
        matchesTarget: matchesTarget,
        privacyFilter: privacyFilter,
        updateConfig: updateConfig,

        init: function () {
            if (!isInitialized) {
                initMessageService();
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(messageService)");
            }
        },

        destroy: function () {
            destroy();
        },

        applyPrivacyToDocument: applyPrivacyToDocument,

        /**
         * Accepts a simple queue event  and wraps it into a complete message that the server can understand.
         * @param  {Object} event The simple event information
         * @return {Object}       A complete message that is ready for transmission to the server.
         */
        createMessage: function (event) {
            if (typeof event.type === "undefined") {
                throw new TypeError("Invalid queueEvent given!");
            }
            return privacyFilter(new Message(event));
        },

        /**
         * Mock function to create a JSON structure around messages before sending to server.
         * @param  {Array} messages An array of messages
         * @return {Object}          Returns a JavaScript object which can be serialized to JSON
         *      and send to the server.
         *  @todo rewrite functionality
         */
        wrapMessages: function (messages) {
            var messagePackage = {
                messageVersion: "4.0.0.0",
                serialNumber: (count += 1),
                sessions: [{
                    id: pageId,
                    startTime: tlStartLoad.getTime(),
                    timezoneOffset: tlStartLoad.getTimezoneOffset(),
                    messages: messages,
                    clientEnvironment: {
                        webEnvironment: {
                            libVersion: "4.0.0.1607",
                            page: windowHref,
                            windowId: windowId,
                            screen: {
                                devicePixelRatio: devicePixelRatio,
                                deviceOriginalWidth: isApple || isAndroidChrome ? deviceOriginalWidth * devicePixelRatio : deviceOriginalWidth,
                                deviceOriginalHeight: isApple || isAndroidChrome ? deviceOriginalHeight * devicePixelRatio : deviceOriginalHeight,
                                deviceWidth: deviceWidth,
                                deviceHeight: deviceHeight,
                                deviceToolbarHeight: deviceToolbarHeight,
                                width: startWidth,
                                height: startHeight,
                                orientation: deviceOrientation
                            }
                        }
                    }
                }]
            },
                webEnvScreen = messagePackage.sessions[0].clientEnvironment.webEnvironment.screen;

            webEnvScreen.orientationMode = core.utils.getOrientationMode(webEnvScreen.orientation);
            /*
            if (true) { // Add usability to config settings
                //messagePackage.domainId = "<<TODO domainId>>"; This was used to send to correct posting url, no longer needed. Followup with Chris. Checked with Joe.
                //messagePackage.samplingRate = "<<TODO samplingRate>>"; This is no longer needed. We will not focus on sampling for this release of 8.6.
            }
            */
            return messagePackage;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SerializerService provides the ability to serialize
 * data into one or more string formats.
 * @exports serializerService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name serializerService
 * @namespace
 */
TLT.addService("serializer", function (core) {
    "use strict";

    /**
     * JSON serializer. If possible it uses JSON.stringify method, but
     * for older browsers it provides minimalistic implementaction of
     * custom serializer (limitations: does not detect circular
     * dependencies, does not serialize date objects and does not
     * validate names of object fields).
     * @private
     * @function
     * @name serializerService-serializeToJSON
     * @param {Any} obj - any value
     * @returns {string} serialized string
     */
    function serializeToJSON(obj) {
        var str,
            key,
            len = 0;
        if (typeof obj !== "object" || obj === null) {
            switch (typeof obj) {
            case "function":
            case "undefined":
                return "null";
            case "string":
                return '"' + obj.replace(/\"/g, '\\"') + '"';
            default:
                return String(obj);
            }
        } else if (Object.prototype.toString.call(obj) === "[object Array]") {
            str = "[";
            for (key = 0, len = obj.length; key < len; key += 1) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str += serializeToJSON(obj[key]) + ",";
                }
            }
        } else {
            str = "{";
            for (key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str = str.concat('"', key, '":', serializeToJSON(obj[key]), ",");
                    len += 1;
                }
            }
        }
        if (len > 0) {
            str = str.substring(0, str.length - 1);
        }
        str += String.fromCharCode(str.charCodeAt(0) + 2);
        return str;
    }


    /**
     * Serializer / Parser implementations
     * @type {Object}
     */
    var configService = core.getService("config"),
        serialize = {},
        parse = {},
        defaultSerializers = {
            json: (function () {
                if (typeof window.JSON !== "undefined") {
                    return {
                        serialize: window.JSON.stringify,
                        parse: window.JSON.parse
                    };
                }

                return {
                    serialize: serializeToJSON,
                    // TODO: find a better way than using eval
                    parse: function (data) {
                        return eval("(" + data + ")");
                    }
                };
            }())
        },
        updateConfig = null,
        isInitialized = false;

    function addObjectIfExist(paths, rootObj, propertyName) {
        var i,
            len,
            obj;

        paths = paths || [];
        for (i = 0, len = paths.length; i < len; i += 1) {
            obj = paths[i];
            if (typeof obj === "string") {
                obj = core.utils.access(obj);
            }
            if (typeof obj === "function") {
                rootObj[propertyName] = obj;
                break;
            }
        }
    }
	function checkParserAndSerializer() {
		var isParserAndSerializerInvalid;
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
			isParserAndSerializerInvalid = true;
        } else {
			if (typeof parse.json('{"foo": "bar"}') === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = parse.json('{"foo": "bar"}').foo !== "bar";
			}
			if (typeof parse.json("[1, 2]") === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1, 2]")[0] !== 1;
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1,2]")[1] !== 2;
			}
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json({"foo": "bar"}) !== '{"foo":"bar"}';
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json([1, 2]) !== "[1,2]";
		}
		return isParserAndSerializerInvalid;
	}
    function initSerializerService(config) {
        var format;
        for (format in config) {
            if (config.hasOwnProperty(format)) {
                addObjectIfExist(config[format].stringifiers, serialize, format);
                addObjectIfExist(config[format].parsers, parse, format);
            }
        }

        // use default JSON parser/serializer if possible
        if (!(config.json && config.json.hasOwnProperty("defaultToBuiltin")) || config.json.defaultToBuiltin === true) {
            serialize.json = serialize.json || defaultSerializers.json.serialize;
            parse.json = parse.json || defaultSerializers.json.parse;
        }

        //sanity check
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
            core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.");
        }
		if (checkParserAndSerializer()) {
			if (typeof serialize.json !== "function" && typeof parse.json !== "function") {
				console.log("parse.json() and serialize.json() are not a functions.");
			} else if (typeof serialize.json !== "function") {
				console.log("serialize.json() is not a function.");
			} else if (typeof parse.json !== "function") {
				console.log("parse.json() is not a function.");
			} else {
				if (typeof parse.json('{"foo": "bar"}') === "undefined") {
					console.log("parse.json('{'foo': 'bar'}') is undefined");
				} else if (parse.json('{"foo":"bar"}').foo !== "bar") {
					console.log('Parsing of JSON object is failing.');
				}
				if (typeof parse.json("[1, 2]") === "undefined") {
					console.log("parse.json('[1, 2]') is undefined");
				} else if (parse.json("[1,2]")[0] !== 1 || parse.json("[1,2]")[1] !== 2) {
					console.log('Parsing of JSON array is failing.');
				}
				if (serialize.json({"foo": "bar"}) !== '{"foo":"bar"}') {
					console.log('Stringification of JSON object is failing.');
				}
				if (serialize.json([1, 2]) !== "[1,2]") {
					console.log('Stringification of JSON array is failing.');
				}
			}
			core.fail("JSON stringification and parsing are not working as expected");
		}
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }


    function destroy() {
        serialize = {};
        parse = {};

        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed. Verify initSerializerService is idempotent
        initSerializerService(configService.getServiceConfig("serializer") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        // Expose private functions for unit testing
        updateConfig: updateConfig,
        init: function () {
            if (!isInitialized) {
                initSerializerService(configService.getServiceConfig("serializer") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(serializerService)");
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Parses a string into a JavaScript object.
         * @param  {String} data The string to parse.
         * @param  {String} [type="json"] The format of the data.
         * @return {Object}      An object representing the string data.
         */
        parse: function (data, type) {
            type = type || "json";
            if (typeof parse[type] !== "function") {
                core.utils.clog("Unsupported type of data in parse method of serializer service: " + type);
            }
            return parse[type](data);
        },

        /**
         * Serializes object data into a string using the format specified.
         * @param  {Object} data The data to serialize.
         * @param  {String} [type="json"] The format to serialize the data into.
         * @return {String}      A string containing the serialization of the data.
         */
        serialize: function (data, type) {
            type = type || "json";
            if (typeof serialize[type] !== "function") {
                core.utils.clog("Unsupported type of data in serializer method of serializer service: " + type);
            }
            return serialize[type](data);
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Overstat module implements the logic for collecting
 * data for cxOverstat. The current uses are for the Hover Event and
 * Hover To Click event.
 * @exports overstat
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name overstat
     * @namespace
     */
    TLT.addModule("overstat", function (context) {
        "use strict";

        var tlTypes = {
            "input:radio": "radioButton",
            "input:checkbox": "checkBox",
            "input:text": "textBox",
            "input:password": "textBox",
            "input:file": "fileInput",
            "input:button": "button",
            "input:submit": "submitButton",
            "input:reset": "resetButton",
            "input:image": "image",
            "input:color": "color",
            "input:date": "date",
            "input:datetime": "datetime",
            "input:datetime-local": "datetime-local",
            "input:number": "number",
            "input:email": "email",
            "input:tel": "tel",
            "input:search": "search",
            "input:url": "url",
            "input:time": "time",
            "input:week": "week",
            "input:month": "month",
            "textarea:": "textBox",
            "select:": "selectList",
            "button:": "button",
            "a:": "link"
        },

            eventMap = {},
            configDefaults = { "UPDATE_INTERVAL" : 250,
                                "HOVER_THRESHOLD_MIN" : 1000,
                                "HOVER_THRESHOLD_MAX" : 2 * 60 * 1000,
                                "GRIDCELL_MAX_X" : 10,
                                "GRIDCELL_MAX_Y" : 10,
                                "GRIDCELL_MIN_WIDTH" : 20,
                                "GRIDCELL_MIN_HEIGHT" : 20
                };

        /**
         * Used to test and get value from an object.
         * @private
         * @function
         * @name replay-getValue
         * @param {object} parentObj An object you want to get a value from.
         * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
         * @return {object} If object is found, if not then null will be returned.
         */
        function getValue(parentObj, propertyAsStr) {
            var i,
                properties;

            // Sanity check
            if (!parentObj || typeof parentObj !== "object") {
                return null;
            }

            properties = propertyAsStr.split(".");
            for (i = 0; i < properties.length; i += 1) {
                if ((typeof parentObj === "undefined") || (parentObj[properties[i]] === null)) {
                    return null;
                }
                parentObj = parentObj[properties[i]];
            }
            return parentObj;
        }

        function getConfigValue(key) {
            var overstatConfig = context.getConfig() || {},
                value = overstatConfig[key];
            return typeof value === "number" ? value : configDefaults[key];
        }

        function postUIEvent(hoverEvent, options) {
            var tagName = getValue(hoverEvent, "webEvent.target.element.tagName") || "",
                type = tagName.toLowerCase() === "input" ? getValue(hoverEvent, "webEvent.target.element.type") : "",
                tlType = tlTypes[tagName.toLowerCase() + ":" + type] || tagName,

                uiEvent = {
                    type: 9,
                    event: {
                        hoverDuration: hoverEvent.hoverDuration,
                        hoverToClick: getValue(options, "hoverToClick")
                    },
                    target: {
                        id: getValue(hoverEvent, "webEvent.target.id") || "",
                        idType: getValue(hoverEvent, "webEvent.target.idType") || "",
                        name: getValue(hoverEvent, "webEvent.target.name") || "",
                        tlType: tlType,
                        type: tagName,
                        subType: type,
                        position: {
                            width: getValue(hoverEvent, "webEvent.target.element.offsetWidth") || 0,
                            height: getValue(hoverEvent, "webEvent.target.element.offsetHeight") || 0,
                            relXY: hoverEvent.gridX + "," + hoverEvent.gridY
                        }
                    }
                };

                // if id is null or empty, what are we firing on? it can't be replayed anyway
            if ((typeof uiEvent.target.id) === undefined || uiEvent.target.id === "") {
                return;
            }

            context.utils.clog("Overstat - posted hover event");
            context.utils.clog(uiEvent);
            context.post(uiEvent);
        }

        function stopNode(node) {
            if (node && node.element) { node = node.element; }
            return !node || node === document.body || node === document.html || node === document;
        }

        function getParent(node) {
            if (!node) { return null; }
            return node.element ? node.element.parentNode : node.parentNode;
        }

        function getOffsetParent(node) {
            if (!node) { return null; }
            var parent = node.element ? node.element.offsetParent : node.offsetParent;
            return parent || getParent(node);
        }

        /*
         * for when mouseout is called - if you have moved over a child element, mouseout is fired for the parent element
         * @private
         * @function
         * @name overstat-isChildOf
         * @return {boolean} Returns whether node is a child of root
         */
        function isChildOf(root, node) {
            if (!node || node === root) { return false; }
            node = getParent(node);

            while (!stopNode(node)) {
                if (node === root) { return true; }
                node = getParent(node);
            }

            return false;
        }

        function getNativeEvent(e) {
            if (e.nativeEvent) { e = e.nativeEvent; }
            return e;
        }

        function getNativeTarget(e) {
            return getNativeEvent(e).target;
        }

        function getNativeNode(node) {
            if (!node) { return null; }
            return node.element || node;
        }

        function getNodeType(node) {
            if (!node) { return -1; }
            if (node.element) { node = node.element; }
            return node.nodeType || -1;
        }

        function getNodeTagName(node) {
            if (!node) { return ""; }
            if (node.element) { node = node.element; }
            return node.tagName ? node.tagName.toUpperCase() : "";
        }

        function getNodeElement(node) {
            if (node && node.element) { node = node.element; }
            return node;
        }

        function stopEventPropagation(e) {
            if (!e) { return; }
            if (e.nativeEvent) { e = e.nativeEvent; }

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.cancelBubble) {
                e.cancelBubble();
            }
        }

        function ignoreNode(node) {
            var tagName = getNodeTagName(node);
            return getNodeType(node) !== 1 || tagName === "TR" || tagName === "TBODY" || tagName === "THEAD";
        }

        /**
         * Generates an XPath for a given node, stub method until the real one is available
         * @function
         */
        function getXPathFromNode(node) {
            if (!node) { return ""; }
            if (node.xPath) { return node.xPath; }
            node = getNativeNode(node);
            return context.getXPathFromNode(node);
        }

        /*
         * replacement for lang.hitch(), setTimeout loses all scope
         * @private
         * @function
         * @name overstat-callHoverEventMethod
         * @return {object} Returns the value of the called method
         */
        function callHoverEventMethod(key, methodName) {
            var hEvent = eventMap[key];
            if (hEvent && hEvent[methodName]) { return hEvent[methodName](); }
        }

        function HoverEvent(dm, gx, gy, webEvent) {
            this.xPath = dm !== null ? getXPathFromNode(dm) : "";
            this.domNode = dm;
            this.hoverDuration = 0;
            this.hoverUpdateTime = 0;
            this.gridX = Math.max(gx, 0);
            this.gridY = Math.max(gy, 0);
            this.parentKey = "";
            this.updateTimer = -1;
            this.disposed = false;
            this.childKeys = {};
            this.webEvent = webEvent;

            /*
             * @public
             * @function
             * @name overstat-HoverEvent.getKey
             * @return {string} Returns the string unique key of this event
             */
            this.getKey = function () {
                return this.xPath + ":" + this.gridX + "," + this.gridY;
            };

            /*
             * update hoverTime, set timer to update again
             * @public
             * @function
             * @name overstat-HoverEvent.update
             */
            this.update = function () {
                var curTime = new Date().getTime(),
                    key = this.getKey();

                if (this.hoverUpdateTime !== 0) {
                    this.hoverDuration += curTime - this.hoverUpdateTime;
                }

                this.hoverUpdateTime = curTime;

                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(function () { callHoverEventMethod(key, "update"); }, getConfigValue("UPDATE_INTERVAL"));
            };

            /*
             * leaveClone is true if you want to get rid of an event but leave a new one in it's place.
             * usually this will happen due to a click, where the hover ends, but you want a new hover to
             * begin in the same place
             * @public
             * @function
             * @name overstat-HoverEvent.dispose
             */
            this.dispose = function (leaveClone) {
                clearTimeout(this.updateTimer);
                delete eventMap[this.getKey()];
                this.disposed = true;

                if (leaveClone) {
                    var cloneEvt = this.clone();
                    eventMap[cloneEvt.getKey()] = cloneEvt;
                    cloneEvt.update();
                }
            };

            /*
             * clear update timer, add to hover events queue if threshold is reached, dispose in any case
             * @public
             * @function
             * @name overstat-HoverEvent.process
             * @return {boolean} Returns whether or not the event met the threshold requirements and was added to the queue
             */
            this.process = function (wasClicked) {
                clearTimeout(this.updateTimer);
                if (this.disposed) { return false; }

                var addedToQueue = false,
                    hEvent = this,
                    key = null;
                if (this.hoverDuration >= getConfigValue("HOVER_THRESHOLD_MIN")) {
                    this.hoverDuration = Math.min(this.hoverDuration, getConfigValue("HOVER_THRESHOLD_MAX"));
                    // add to ui event queue here
                    addedToQueue = true;
                    postUIEvent(this, { hoverToClick : !!wasClicked });

                    while (typeof hEvent !== "undefined") {
                        hEvent.dispose(wasClicked);
                        hEvent = eventMap[hEvent.parentKey];
                    }
                } else {
                    this.dispose(wasClicked);
                }

                return addedToQueue;
            };

            /*
             * return a fresh copy of this event
             * @public
             * @function
             * @name overstat-HoverEvent.clone
             * @return {HoverTest} Returns a copy of this event with a reset hover time
             */
            this.clone = function () {
                var cloneEvent = new HoverEvent(this.domNode, this.gridX, this.gridY);
                cloneEvent.parentKey = this.parentKey;

                return cloneEvent;
            };
        }

        function createHoverEvent(node, x, y, webEvt) {
            return new HoverEvent(node, x, y, webEvt);
        }

        /*
         * get element offset according to the top left of the document
         * @private
         * @function
         * @name overstat-calculateNodeOffset
         * @return {object} Returns an object with x and y offsets
         */
        function calculateNodeOffset(node) {
            if (node && node.position) { return { x: node.position.x, y: node.position.y }; }
            node = getNodeElement(node);
            var offsetX = node.offsetLeft,
                offsetY = node.offsetTop,
                lastOffsetX = offsetX,
                lastOffsetY = offsetY,
                offsetDiffX = 0,
                offsetDiffY = 0,
                curNode = getOffsetParent(node);

            while (curNode) {
                if (stopNode(curNode)) { break; }

                offsetDiffX = curNode.offsetLeft - (curNode.scrollLeft || 0);
                offsetDiffY = curNode.offsetTop - (curNode.scrollTop || 0);

                if (offsetDiffX !== lastOffsetX || offsetDiffY !== lastOffsetY) {
                    offsetX += offsetDiffX;
                    offsetY += offsetDiffY;

                    lastOffsetX = offsetDiffX;
                    lastOffsetY = offsetDiffY;
                }

                curNode = getOffsetParent(curNode);
            }

            if (isNaN(offsetX)) { offsetX = 0; }
            if (isNaN(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * calculate position relative to top left corner of element
         * @private
         * @function
         * @name overstat-calculateRelativeCursorPos
         * @return {object} Returns an object with x and y offsets
         */
        function calculateRelativeCursorPos(node, cursorX, cursorY) {
            node = getNodeElement(node);
            var nodeOffset = calculateNodeOffset(node),
                offsetX = cursorX - nodeOffset.x,
                offsetY = cursorY - nodeOffset.y;

            if (!isFinite(offsetX)) { offsetX = 0; }
            if (!isFinite(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * determine grid cell dimensions based on the constants
         * @private
         * @function
         * @name overstat-calculateGridCell
         * @return {object} Returns the x and y grid location
         */
        function calculateGridCell(node, offsetX, offsetY) {
            node = getNodeElement(node);
            var cellWidth = node.offsetWidth > 0 ? Math.max(node.offsetWidth / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_WIDTH")) : getConfigValue("GRIDCELL_MIN_WIDTH"),
                cellHeight = node.offsetHeight > 0 ? Math.max(node.offsetHeight / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_HEIGHT")) : getConfigValue("GRIDCELL_MIN_HEIGHT"),

                cellX = Math.floor(offsetX / cellWidth),
                cellY = Math.floor(offsetY / cellHeight);

            if (!isFinite(cellX)) { cellX = 0; }
            if (!isFinite(cellY)) { cellY = 0; }
            return { x: cellX, y: cellY };
        }

        /*
         * called when a hover event fires - processes all unrelated hover events from the queue.
         * events are related if they are the calling event, or any parent events
         * @private
         * @function
         * @name overstat-cleanupHoverEvents
         */
        function cleanupHoverEvents(curEvent) {
            var hEvent = curEvent,
                curKey = curEvent.getKey(),
                allowedKeyMap = {},
                key = null,
                childKey = null;

            allowedKeyMap[curKey] = true;

            while (typeof hEvent !== "undefined") {
                allowedKeyMap[hEvent.parentKey] = true;
                if (hEvent.parentKey === "" || hEvent.parentKey === hEvent.getKey()) {
                    break;
                }

                hEvent = eventMap[hEvent.parentKey];
            }

            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key) && !allowedKeyMap[key]) {
                    hEvent = eventMap[key];
                    if (hEvent) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * similar to cleanupHoverEvents, this will process all events within a domNode (fired on mouseout)
         * @private
         * @function
         * @name overstat-processEventsByDomNode
         */
        function processEventsByDomNode(eventNode, keyToIgnore) {
            var hEvent = null,
                key = null;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    if (hEvent.domNode === eventNode && hEvent.getKey() !== keyToIgnore) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * 1) determine element and grid position for event
         * 2) find existing matching event if possible
         * 3) update event hover time
         * 4) bubble to parent node, for linking purposes
         * within the UI SDK framework, this should be called for each node in the heirarchy (box model)
         * going top down. so the parent (if the calculation is correct) should already exist, and have
         * it's own parent link, which helps during cleanupHoverEvents
         * @private
         * @function
         * @name overstat-hoverHandler
         * @return {HoverEvent} Returns the relevant HoverEvent object (either found or created)
         */
        function hoverHandler(e, node, isParent) {
            if (!node) { node = e.target; }
            if (stopNode(node)) { return null; }
            if (context.utils.isiOS || context.utils.isAndroid) { return null; }

            var rPos, gPos, hEvent, key, parentKey, parentEvent, offsetParent;

            if (!ignoreNode(node)) {
                rPos = calculateRelativeCursorPos(node, e.position.x, e.position.y);
                gPos = calculateGridCell(node, rPos.x, rPos.y);
                hEvent = new HoverEvent(node, gPos.x, gPos.y, e);
                key = hEvent.getKey();

                if (eventMap[key]) {
                    hEvent = eventMap[key];
                } else {
                    eventMap[key] = hEvent;
                }

                hEvent.update();

                // link parent, but in the case that it refers to itself (sometimes with frames) make sure the parentKey
                // is not the same as the current key
                if (!isParent) {
                    offsetParent = getOffsetParent(node);
                    if (offsetParent) {
                        parentEvent = hoverHandler(e, offsetParent, true);
                        if (parentEvent !== null) {
                            parentKey = parentEvent.getKey();
                            key = hEvent.getKey();
                            if (key !== parentKey) {
                                hEvent.parentKey = parentKey;
                            }
                        }
                    }

                    cleanupHoverEvents(hEvent);
                }
            } else {
                hEvent = hoverHandler(e, getOffsetParent(node), isParent);
            }

            return hEvent;
        }

        /*
         * process all events related to the event target, as hovering stops when leaving the element
         * @private
         * @function
         * @name overstat-leaveHandler
         */
        function leaveHandler(e) {
            e = getNativeEvent(e);
            if (isChildOf(e.target, e.relatedTarget)) {
                return;
            }

            processEventsByDomNode(e.target);
        }

        /*
         * on click, resolve current hover events, and reset hover count
         * @private
         * @function
         * @name overstat-clickHandler
         */
        function clickHandler(e) {
            var hEvent = null, key;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    hEvent.process(true);
                }
            }
        }

        /*
         * switches on window event type and routes it appropriately
         * @private
         * @function
         * @name overstat-handleEvent
         */
        function handleEvent(e) {
            var targetId = getValue(e, "target.id");

            // Sanity check
            if (!targetId) {
                return;
            }

            switch (e.type) {
            case "mousemove":
                hoverHandler(e);
                break;
            case "mouseout":
                leaveHandler(e);
                break;
            case "click":
                clickHandler(e);
                break;
            }
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {

            // Expose for unit testing

            DEBUG: 1,

            // Properties

            // Functions
            postUIEvent: postUIEvent,
            getValue: getValue,

            /**
             * Initialize the overstat module.
             */
            init: function () {
            },

            /**
             * Terminate the overstat module.
             */
            destroy: function () {
                var key, i;
                for (key in eventMap) {
                    if (eventMap.hasOwnProperty(key)) {
                        eventMap[key].dispose();
                        delete eventMap[key];
                    }
                }
            },

            /**
             * Handle events subscribed by the overstat module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                handleEvent(event);
            },

            /**
             * Handle system messages subscribed by the overstat module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            },

			createHoverEvent: createHoverEvent,
			cleanupHoverEvents: cleanupHoverEvents,
            eventMap: eventMap
        };
    });  // End of TLT.addModule
} else {

    // Only throw an error in DEBUG mode.
    throw "Overstat module included but TLT is not defined!!!";

}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Performance module implements the logic for monitoring and
 * reporting performance data such as the W3C Navigation Timing.
 * @exports performance
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name performance
     * @namespace
     */
    TLT.addModule("performance", function (context) {
        "use strict";

        var moduleState = {
                loadReceived: false,
                unloadReceived: false,
                perfEventSent: false
            },
            calculatedRenderTime = 0;


        /**
         * Returns true if the property is filtered out. The property is considered
         * to be filtered out if it exists in the filter object with a value of true.
         * @private
         * @function
         * @name performance-isFiltered
         * @param {string} prop The property name to be tested.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {boolean} true if the property is filtered out, false otherwise.
         */
        function isFiltered(prop, filter) {
            // Sanity check
            if (typeof prop !== "string") {
                return false;
            }

            // If there is no filter object then the property is not filtered out.
            if (!filter || typeof filter !== "object") {
                return false;
            }

            return (filter[prop] === true);
        }

        /**
         * Returns the normalized timing object. Normalized values are offsets measured
         * from the "navigationStart" timestamp which serves as the epoch. Also applies
         * the filter.
         * @private
         * @function
         * @name performance-parseTiming
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {object} The normalized timing properties.
         */
        function parseTiming(timing, filter) {
            var epoch = 0,
                normalizedTiming = {},
                prop = "",
                value = 0;

            // Sanity checks
            if (!timing || typeof timing !== "object" || !timing.navigationStart) {
                return {};
            }

            epoch = timing.navigationStart;
            for (prop in timing) {
                // IE_COMPAT, FF_COMPAT: timing.hasOwnProperty(prop) returns false for
                // performance timing members in IE 9 and Firefox 14.0.1.

                // IE_COMPAT: timing.hasOwnProperty does not exist in IE8 and lower for
                // host objects. Legacy IE does not support hasOwnProperty on hosted objects.
                if (Object.prototype.hasOwnProperty.call(timing, prop) || typeof timing[prop] === "number") {
                    if (!isFiltered(prop, filter)) {
                        value = timing[prop];
                        if (typeof value === "number" && value && prop !== "navigationStart") {
                            normalizedTiming[prop] = value - epoch;
                        } else {
                            normalizedTiming[prop] = value;
                        }
                    }
                }
            }

            return normalizedTiming;
        }

        /**
         * Calculates the render time from the given timing object.
         * @private
         * @function
         * @name performance-getRenderTime
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @return {integer} The calculated render time or 0.
         */
        function getRenderTime(timing) {
            var renderTime = 0,
                startTime,
                endTime,
                utils = context.utils;

            if (timing) {
                // Use the lesser of domLoading or responseEnd as the start of render, see data in CS-8915
                startTime = (timing.responseEnd > 0 && timing.responseEnd < timing.domLoading) ? timing.responseEnd : timing.domLoading;
                endTime = timing.loadEventStart;
                if (utils.isNumeric(startTime) && utils.isNumeric(endTime) && endTime > startTime) {
                    renderTime = endTime - startTime;
                }
            }

            return renderTime;
        }

        /**
         * Calculates the render time by measuring the difference between when the
         * library core was loaded and when the page load event occurs.
         * @private
         * @function
         * @name performance-processLoadEvent
         * @param  {Object} event The normalized data extracted from a browser event object.
         */
        function processLoadEvent(event) {
            var startTime = context.getStartTime();
            if (event.timestamp > startTime && !calculatedRenderTime) {
                // Calculate the render time
                calculatedRenderTime = event.timestamp - startTime;
            }
        }

        /**
         * Posts the performance event.
         * @private
         * @function
         * @name performance-postPerformanceEvent
         * @param {object} window The DOM window
         */
        function postPerformanceEvent(window) {
            var config = context.getConfig() || {},
                navType = "UNKNOWN",
                queueEvent = {
                    type: 7,
                    performance: {}
                },
                navigation,
                performance,
                timing;

            // Sanity checks
            if (!window || moduleState.perfEventSent) {
                return;
            }

            performance = window.performance || {};
            timing = performance.timing;
            navigation = performance.navigation;

            if (timing) {
                queueEvent.performance.timing = parseTiming(timing, config.filter);
                queueEvent.performance.timing.renderTime = getRenderTime(timing);
            } else if (config.calculateRenderTime) {
                queueEvent.performance.timing = {
                    renderTime: calculatedRenderTime,
                    calculated: true
                };
            } else {
                // Nothing to report.
                return;
            }

            // Do not include renderTime if it is over the threshold.
            if (config.renderTimeThreshold && queueEvent.performance.timing.renderTime > config.renderTimeThreshold) {
                queueEvent.performance.timing.invalidRenderTime = queueEvent.performance.timing.renderTime;
                delete queueEvent.performance.timing.renderTime;
            }

            if (navigation) {
                switch (navigation.type) {
                case 0:
                    navType = "NAVIGATE";
                    break;
                case 1:
                    navType = "RELOAD";
                    break;
                case 2:
                    navType = "BACKFORWARD";
                    break;
                default:
                    navType = "UNKNOWN";
                    break;
                }
                queueEvent.performance.navigation = {
                    type: navType,
                    redirectCount: navigation.redirectCount
                };
            }

            // Invoke the context API to post this event
            context.post(queueEvent);
            // TODO: Remove all instances of perfEventSent flag from this method and localize it's use in the caller?
            moduleState.perfEventSent = true;
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {

            // Expose private functions for unit testing
            isFiltered: isFiltered,
            parseTiming: parseTiming,
            getRenderTime: getRenderTime,
            postPerformanceEvent: postPerformanceEvent,

            /**
             * Initialize the performance module.
             */
            init: function () {
                // TODO: Possibly add check to see if navigation timing interface is supported. If not, short circuit the implementation below.
            },

            /**
             * Terminate the performance module.
             */
            destroy: function () {

            },

            /**
             * Handle events subscribed by the performance module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                switch (event.type) {
                case "load":
                    moduleState.loadReceived = true;
                    processLoadEvent(event);
                    break;
                case "unload":
                    moduleState.unloadReceived = true;
                    // Force the performance data to be posted (if it hasn't been done already.)
                    if (!moduleState.perfEventSent) {
                        // TODO: Directly referencing the global window but may want to sandbox this.
                        postPerformanceEvent(window);
                    }
                    break;
                default:
                    break;
                }
            },

            /**
             * Handle system messages subscribed by the performance module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            }
        };
    });  // End of TLT.addModule
} else {

    // Only throw an error in DEBUG mode.
    throw "Performance module included but TLT is not defined!!!";

}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Replay module implements the logic for monitoring and
 * reporting user interaction data used for replay and usability.
 * @exports replay
 */

/*global TLT:true */

// Sanity check
TLT.addModule("replay", function (context) {
    "use strict";

    var tlTypes = {
    // Keep these sorted for readability.
            "a:": "link",
            "button:button": "button",
            "button:submit": "button",
            "input:button": "button",
            "input:checkbox": "checkBox",
            "input:color": "colorPicker",
            "input:date": "datePicker",
            "input:datetime": "datetimePicker",
            "input:datetime-local": "datetime-local",
            "input:email": "emailInput",
            "input:file": "fileInput",
            "input:image": "image",
            "input:month": "month",
            "input:number": "numberPicker",
            "input:password": "textBox",
            "input:radio": "radioButton",
            "input:range": "slider",
            "input:reset": "resetButton",
            "input:search": "searchBox",
            "input:submit": "submitButton",
            "input:tel": "tel",
            "input:text": "textBox",
            "input:time": "timePicker",
            "input:url": "urlBox",
            "input:week": "week",
            "select:": "selectList",
            "select:select-one": "selectList",
            "textarea:": "textBox",
            "textarea:textarea": "textBox"
        },
        utils = context.utils,
        currOrientation = window.orientation || 0,
        savedTouch = {
            scale: 0,
            timestamp: 0
        },
        pastEvents = {},
        prevHash = window.location.hash,
        lastEventId = null,
        tmpQueue = [],
        eventCounter = 0,
        curClientState = null,
        pastClientState = null,
        errorCount = 0,
        visitOrder = "",
        lastVisit = "",
        pageLoadTime = (new Date()).getTime(),
        pageDwellTime = 0,
        prevWebEvent = null,
        viewEventStart = null,
        viewTimeStart = null,
        scrollViewStart = null,
        scrollViewEnd = null,
        nextScrollViewStart = null,
        viewPortXStart = 0,
        viewPortYStart = 0,
        inBetweenEvtsTimer = null,
        lastFocusEvent = { inFocus: false },
        lastClickEvent = null,
        //TODO move these to a global section due to they might be used elsewhere
        isApple = utils.isiOS,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && utils.isAndroid,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = (window.screen ? window.screen.width : 0),
        deviceOriginalHeight = (window.screen ? window.screen.height : 0),
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        config = context.getConfig(),
        deviceScale = 1,
        previousDeviceScale = 1,
        extendGetItem;

    /**
     * Returns true if the click event changes the target state or is otherwise
     * relevant for the target.
     * @private
     * @param {WebEvent.target} target Webevent target
     * @return {boolean} true if the click event is relevant for the target, false otherwise.
     */
    function isTargetClickable(target) {
        var clickable = false,
            clickableInputTypes = "|button|image|submit|reset|checkbox|radio|",
            subType = null;

        if (typeof target !== "object" || !target.type) {
            return clickable;
        }

        switch (target.type) {
        case "INPUT":
            // Clicks are relevant for button type inputs only.
            subType = "|" + (target.subType || "") + "|";
            if (clickableInputTypes.indexOf(subType.toLowerCase()) === -1) {
                clickable = false;
            } else {
                clickable = true;
            }
            break;
        case "SELECT":
        case "TEXTAREA":
            clickable = false;
            break;
        default:
            // By default, clicks are relevant for all targets.
            clickable = true;
            break;
        }

        return clickable;
    }

    function parentElements(node) {
        var parents = [];
        node = node.parentNode;
        while (node) {
            parents.push(node);
            node = node.parentNode;
        }
        return parents;
    }

    function getParentLink(parents) {
        return context.utils.some(parents, function (node) {
            // Either links or buttons could have content
            if (node.tagName === "A" || node.tagName === "BUTTON") {
                return node;
            }
            return null;
        });
    }

    /**
     * Get the normalized tlEvent from the underlying DOM event and target.
     * @private
     * @param {object} webEvent The normalized webEvent with event and target (control.)
     * @return {string} The normalized value for the tlEvent as per the JSON Logging Data Format.
     */
    function getTlEvent(webEvent) {
        var tlEvent = webEvent.type,
            target = webEvent.target;

        if (typeof tlEvent === "string") {
            tlEvent = tlEvent.toLowerCase();
        } else {
            tlEvent = "unknown";
        }

        if (tlEvent === "blur") {
            tlEvent = "focusout";
        }

        if (tlEvent === "change") {
            if (target.type === "INPUT") {
                switch (target.subType) {
                case "text":
                case "date":
                case "time":
                    // tlEvent is textChange, dateChange or timeChange respectively.
                    tlEvent = target.subType + "Change";
                    break;
                default:
                    // For all other input fields the tlEvent is valueChange.
                    tlEvent = "valueChange";
                    break;
                }
            } else if (target.type === "TEXTAREA") {
                tlEvent = "textChange";
            } else {
                tlEvent = "valueChange";
            }
        }

        return tlEvent;
    }

    /**
     * Invoke the core API to take the DOM capture. If a delay is specified, then
     * schedule a DOM capture.
     * @private
     * @param {DOMElement} root Root element from which the DOM capture snapshot should be taken.
     * @param {object} [config] Configuration options for the capture.
     * @param {Number} [delay] Milliseconds after which to take the DOM snapshot.
     * @return {string} Returns the unique DOM Capture id.
     */
    function scheduleDOMCapture(root, config, delay) {
        var dcid = null;
        // Sanity check
        if (!root) {
            return dcid;
        }
        config = config || {};
        if (delay) {
            dcid = "dcid-" + context.utils.getSerialNumber() + "." + (new Date()).getTime() + "s";
            window.setTimeout(function () {
                config.dcid = dcid;
                context.performDOMCapture(root, config);
            }, delay);
        } else {
            delete config.dcid;
            dcid = context.performDOMCapture(root, config);
        }
        return dcid;
    }

    /**
     * Check the DOM capture rules to see if DOM capture should be triggered for this combination
     * of event, target, screenview as applicable.
     * @private
     * @param {String} eventType Name of the event e.g. click, change, load, unload
     * @param {DOMElement} target The target element of the event. Some events (such as load/unload) may not
     * have a target in which case it would be null.
     * @param {String} [screenviewName] The screenview name for load and unload events.
     * @returns {String} Returns the unique DOM Capture id or null.
     */
    function addDOMCapture(eventType, target, screenviewName) {
        var i,
            capture = false,
            captureConfig,
            dcEnabled = false,
            dcTrigger,
            dcTriggerList,
            dcid = null,
            delay = 0,
            len,
            replayConfig;

        // Sanity check
        if (!eventType || (!target && !screenviewName)) {
            return dcid;
        }
        if (!target && !(eventType === "load" || eventType === "unload")) {
            return dcid;
        }

        replayConfig = context.getConfig() || {};
        dcEnabled = utils.getValue(replayConfig, "domCapture.enabled", false);
        if (!dcEnabled || context.utils.isLegacyIE) {
            // DOM Capture is not supported for IE8 and below
            return dcid;
        }

        dcTriggerList = utils.getValue(replayConfig, "domCapture.triggers") || [];
        for (i = 0, len = dcTriggerList.length; i < len; i += 1) {
            dcTrigger = dcTriggerList[i];
            if (dcTrigger.event === eventType) {
                if (eventType === "load" || eventType === "unload") {
                    if (dcTrigger.screenviews) {
                        capture = (-1 !== utils.indexOf(dcTrigger.screenviews, screenviewName));
                    } else {
                        capture = true;
                    }
                } else {
                    if (dcTrigger.targets) {
                        capture = (-1 !== utils.matchTarget(dcTrigger.targets, target));
                    } else {
                        capture = true;
                    }
                }
            }

            if (capture) {
                // Get the configuration (if any)
                captureConfig = utils.getValue(replayConfig, "domCapture.options", {});
                // Immediate or delayed?
                delay = dcTrigger.delay || 0;

                dcid = scheduleDOMCapture(window.document, captureConfig, delay);
                break;
            }
        }
        return dcid;
    }

    /**
     * Used to create control object from a webEvent.
     * TODO: Move tlType and similar normalization to message service.
     * XXX - Requires review and clean-up.
     * @private
     * @function
     * @name replay-createQueueEvent
     * @param {object} options An object with the following properties:
     *                 webEvent A webEvent that will created into a control.
     *                 id Id of the object.
     *                 prevState Previous state of the object.
     *                 currState Current state of the object.
     *                 visitedCount Visited count of the object.
     *                 dwell Dwell time on the object.
     *                 focusInOffset When you first focused on the object.
     * @return {object} Control object.
     */
    function createQueueEvent(options) {
        var control,
            dcid,
            target        = utils.getValue(options, "webEvent.target", {}),
            targetType    = target.type,
            targetSubtype = target.subType || null,
            tlType        = tlTypes[targetType.toLowerCase() + ":" + targetSubtype] || targetType,
            parents       = parentElements(utils.getValue(target, "element")),
            parentLinkNode = null,
            relXY         = utils.getValue(target, "position.relXY"),
            eventSubtype  = utils.getValue(options, "webEvent.subType", null);

        control = {
            type: 4,
            target: {
                id: target.id || "",
                idType: target.idType,
                name: target.name,
                tlType: tlType,
                type: targetType,
                position: {
                    width: utils.getValue(target, "element.offsetWidth"),
                    height: utils.getValue(target, "element.offsetHeight")
                },
                currState: options.currState || null
            },
            event: {
                tlEvent: getTlEvent(utils.getValue(options, "webEvent")),
                type: utils.getValue(options, "webEvent.type", "UNKNOWN")
            }
        };

        if (targetSubtype) {
            control.target.subType = targetSubtype;
        }

        if (relXY) {
            control.target.position.relXY = relXY;
        }

        if (typeof options.dwell === "number" && options.dwell > 0) {
            control.target.dwell = options.dwell;
        }

        if (typeof options.visitedCount === "number") {
            control.target.visitedCount = options.visitedCount;
        }

        if (typeof options.prevState !== "undefined") {
            control.prevState = options.prevState;
        }

        if (eventSubtype) {
            control.event.subType = eventSubtype;
        }

        // Add usability to config settings
        parentLinkNode = getParentLink(parents);
        control.target.isParentLink = !!parentLinkNode;
        if (parentLinkNode) {
            // Add the parent's href, value and innerText if the actual target doesn't
            // support these properties
            if (parentLinkNode.href) {
                control.target.currState = control.target.currState || {};
                control.target.currState.href = control.target.currState.href || parentLinkNode.href;
            }
            if (parentLinkNode.value) {
                control.target.currState = control.target.currState || {};
                control.target.currState.value = control.target.currState.value || parentLinkNode.value;
            }
            if (parentLinkNode.innerText || parentLinkNode.textContent) {
                control.target.currState = control.target.currState || {};
                control.target.currState.innerText = utils.trim(control.target.currState.innerText || parentLinkNode.innerText || parentLinkNode.textContent);
            }
        }

        if (utils.isUndefOrNull(control.target.currState)) {
            delete control.target.currState;
        }
        if (utils.isUndefOrNull(control.target.name)) {
            delete control.target.name;
        }

        // Check if DOM Capture needs to be triggered for this message.
        // If the event is click then DOM capture is only allowed if the target is click-able
        if (control.event.type !== "click" || isTargetClickable(target)) {
            // Check and add DOM Capture
            dcid = addDOMCapture(control.event.type, target);
            if (dcid) {
                control.dcid = dcid;
            }
        }

        return control;
    }

    function postUIEvent(queueEvent) {
        context.post(queueEvent);
    }

    function updateVisitOrder(msg) {
        var name = utils.getValue(msg, "target.name"),
            dwell = utils.getValue(msg, "target.dwell") || -1;

        if (name) {
            visitOrder += name + ":" + dwell + ";";
            lastVisit = name;
        }
    }

    /**
     * Posts all events from given array to the message service. The input
     * array is cleared on exit from the function.
     * Function additionally consolidates events fired on the same DOM element
     * TODO: Explain the consolidation process. Needs to be refactored!
     * @private
     * @param {Array} queue An array of QueueEvents
     * @return void
     */
    function postEventQueue(queue) {
        var i = 0,
            j,
            len = queue.length,
            e1,
            e2,
            tmp,
            ignoredEvents = {
                mouseout: true,
                mouseover: true
            },
            results = [];

        for (i = 0; i < len; i += 1) {
            e1 = queue[i];
            if (!e1) {
                continue;
            }
            if (ignoredEvents[e1.event.type]) {
                results.push(e1);
            } else {
                for (j = i + 1; j < len && queue[j]; j += 1) {
                    if (!ignoredEvents[queue[j].event.type]) {
                        break;
                    }
                }
                if (j < len) {
                    e2 = queue[j];
                    if (e2 && e1.target.id === e2.target.id && e1.event.type !== e2.event.type) {
                        if (e1.event.type === "click") {
                            tmp = e1;
                            e1 = e2;
                            e2 = tmp;
                        }
                        if (e2.event.type === "click") {
                            e1.target.position = e2.target.position;
                            i += 1;
                        } else if (e2.event.type === "blur") {
                            e1.target.dwell = e2.target.dwell;
                            e1.target.visitedCount = e2.target.visitedCount;
                            e1.focusInOffset = e2.focusInOffset;
                            e1.target.position = e2.target.position;
                            i += 1;
                        }
                        queue[j] = null;
                        queue[i] = e1;
                    }
                }
                results.push(queue[i]);
            }
        }

        for (e1 = results.shift(); e1; e1 = results.shift()) {
            updateVisitOrder(e1);
            context.post(e1);
        }
        queue.splice(0, queue.length);
    }


    if (typeof window.onerror !== "function") {
        window.onerror = function (msg, url, line) {
            var errorMessage = null;

            if (typeof msg !== "string") {
                return;
            }
            line = line || -1;
            errorMessage = {
                type: 6,
                exception: {
                    description: msg,
                    url: url,
                    line: line
                }
            };

            errorCount += 1;
            context.post(errorMessage);
        };
    }

    /**
     * Handles the focus events. It is fired either when the real focus event take place
     * or right after the click event on an element (only when browser focus event was not fired)
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleFocus(id, webEvent) {
        lastFocusEvent = webEvent;
        lastFocusEvent.inFocus = true;
        if (typeof pastEvents[id] === "undefined") {
            pastEvents[id] = {};
        }

        pastEvents[id].focus = lastFocusEvent.dwellStart = Number(new Date());
        pastEvents[id].focusInOffset = viewTimeStart ? lastFocusEvent.dwellStart - Number(viewTimeStart) : -1;
        pastEvents[id].prevState = utils.getValue(webEvent, "target.state");
        pastEvents[id].visitedCount = pastEvents[id].visitedCount + 1 || 1;
    }

    /**
     * Create and add value that will be posted to queue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function addToTmpQueue(webEvent, id) {
        tmpQueue.push(createQueueEvent({
            webEvent: webEvent,
            id: id,
            currState: utils.getValue(webEvent, "target.state")
        }));
    }

    /**
     * Handles blur events. It is invoked when browser blur events fires or from the
     * handleFocus method (only when browser 'blur' event didn't take place).
     * In the first case it's called with current event details, in the second one -
     * with lastFocusEvent. Method posts the tmpQueue of events. If during the same
     * focus time change event was fired the focus data will be combined together with
     * the last change event from the tmpQueue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleBlur(id, webEvent) {
        var convertToBlur = false,
            dcid,
            lastQueueEvent,
            i = 0;

        if (typeof id === "undefined" || id === null || typeof webEvent === "undefined" || webEvent === null) {
            return;
        }

        lastFocusEvent.inFocus = false;

        if (typeof pastEvents[id] !== "undefined" && pastEvents[id].hasOwnProperty("focus")) {
            pastEvents[id].dwell =  Number(new Date()) - pastEvents[id].focus;
        } else {
            // Blur without any prior event on this control.
            pastEvents[id] = {};
            pastEvents[id].dwell = 0;
        }

        if (tmpQueue.length === 0) {
            // Orphaned blur without any prior event.
            addToTmpQueue(webEvent, id);
        }

        // Visited count is missing 
        if (tmpQueue[tmpQueue.length - 1]) {
            for (i = tmpQueue.length - 1; i >= 0; i--) {
                tmpQueue[i].target.visitedCount = pastEvents[id].visitedCount;
            }
        }

        lastQueueEvent = tmpQueue[tmpQueue.length - 1];
        if (lastQueueEvent) {
            lastQueueEvent.target.dwell = pastEvents[id].dwell;
            lastQueueEvent.focusInOffset = pastEvents[id].focusInOffset;
            lastQueueEvent.target.visitedCount = pastEvents[id].visitedCount;

            // if the click (without generating change event) fires on an
            // input element for which it's not relevant - report event as a blur and update the currState
            if (lastQueueEvent.event.type === "click") {
                if (!isTargetClickable(lastQueueEvent.target)) {
                    lastQueueEvent.target.currState = utils.getValue(webEvent, "target.state");
                    convertToBlur = true;
                }
            } else if (lastQueueEvent.event.type === "focus") {
                convertToBlur = true;
            }

            if (convertToBlur) {
                lastQueueEvent.event.type = "blur";
                lastQueueEvent.event.tlEvent = "focusout";
                // Check if DOM Capture needs to be triggered for this message.
                dcid = addDOMCapture(lastQueueEvent.event.type, webEvent.target);
                if (dcid) {
                    lastQueueEvent.dcid = dcid;
                }
            }
        }

        postEventQueue(tmpQueue);
    }

    /**
     * Checks to see in tmpQueue there is an older control that needs to be posted to server.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return Whether it has been sent to server.
     */
    function checkQueue(id, webEvent) {
        var hasInQueue = false;

        // TODO: Optimize the index by storing tmpQueue.length - 1 into a variable?
        if (tmpQueue.length > 0 && tmpQueue[tmpQueue.length - 1] && tmpQueue[tmpQueue.length - 1].target.id !== id &&
                // iOS scrolls & Android resizes after selecting a textbox
                webEvent.type !== "scroll" && webEvent.type !== "resize" &&
                // mouseover should not affect handleBlur invocation
                webEvent.type !== "mouseout" && webEvent.type !== "mouseover" &&
                // Need focus and click values to complete consolidation of message for these types
                (tmpQueue[tmpQueue.length - 1].target.tlType !== "textBox" &&
                tmpQueue[tmpQueue.length - 1].target.tlType !== "selectList")) {
            handleBlur(tmpQueue[tmpQueue.length - 1].target.id, tmpQueue[tmpQueue.length - 1]);
            hasInQueue = true;
        }
        return hasInQueue;
    }

    /**
     * Handles change and click events. Its called when browser 'change' event fires
     * or together with click event (from 'handleClick' method).
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleChange(id, webEvent) {
        if (typeof pastEvents[id] !== "undefined" && !pastEvents[id].hasOwnProperty("focus")) {
            handleFocus(id, webEvent);
        }

        addToTmpQueue(webEvent, id);

        if (typeof pastEvents[id] !== "undefined" && typeof pastEvents[id].prevState !== "undefined") {
            // TODO: Optimize the index by storing tmpQueue.length - 1 to a variable.
            if (tmpQueue[tmpQueue.length - 1].target.tlType === "textBox" ||
                    tmpQueue[tmpQueue.length - 1].target.tlType === "selectList") {
                tmpQueue[tmpQueue.length - 1].target.prevState = pastEvents[id].prevState;
            }
        }
    }

    /**
     * Sets the relative X & Y values to a webEvent.
     * TODO: Explain how relative X & Y should be calculated (in other words, define relative X & Y)
     * XXX - Shouldn't this be named "get" instead of "set"?
     * @private
     * @param {WebEvent} webEvent Normalized browser event
     * @return String value of relative X & Y
     */
    function setRelativeXY(webEvent) {
        var x = webEvent.target.position.x,
            y = webEvent.target.position.y,
            width = webEvent.target.size.width,
            height = webEvent.target.size.height,
            relX = Math.abs(x / width).toFixed(1),
            relY = Math.abs(y / height).toFixed(1);

        relX = relX > 1 || relX < 0 ? 0.5 : relX;
        relY = relY > 1 || relY < 0 ? 0.5 : relY;

        return relX + "," + relY;
    }

    /**
     * Handles click events. Additionally it recognizes situations when browser didn't
     * fire the focus event and in such case it invokes 'handleFocus' method.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleClick(id, webEvent) {
        var relXY,
            addRelXY = true,
            tmpQueueLength = 0;

        if (webEvent.target.element.tagName === "SELECT" && lastClickEvent && lastClickEvent.target.id === id) {
            lastClickEvent = null;
            return;
        }

        if (!lastFocusEvent.inFocus) {
            handleFocus(id, webEvent);
        }

        // Sometimes the change triggers before the click (observed in Chrome and Android)
        // XXX - Not sure I fully understand this logic - MP
        tmpQueueLength = tmpQueue.length;
        if (tmpQueueLength && utils.getValue(tmpQueue[tmpQueueLength - 1], "event.type") !== "change") {
            handleChange(id, webEvent);
        }

        relXY = setRelativeXY(webEvent);

        // During use of arrow keys to select a radio option, it throws a click event after change event
        // which is incorrect for usability data. We only capture user clicks and not framework clicks.
        tmpQueueLength = tmpQueue.length;

        if (webEvent.position.x === 0 && webEvent.position.y === 0 && tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.tlType") === "radioButton") {
            addRelXY = false;
        } else {
            // For all other cases, record the relXY in the target.position
            webEvent.target.position.relXY = relXY;
        }

        // Update the existing queue entry with relXY info. from the click event
        if (tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.id") === id) {
            if (addRelXY) {
                tmpQueue[tmpQueueLength - 1].target.position.relXY = relXY;
            }
        } else {
            // Else add the click event to the queue
            addToTmpQueue(webEvent, id);
        }

        // XXX - What is lastClickEvent being used for? - MP
        lastClickEvent = webEvent;
    }

    /**
     * Returns the normalized orientation in degrees. Normalized values are measured
     * from the default portrait position which has an orientation of 0. From this
     * position the respective values are as follows:
     * 0   - Portrait orientation. Default
     * -90 - Landscape orientation with screen turned clockwise.
     * 90  - Landscape orientation with screen turned counterclockwise.
     * 180 - Portrait orientation with screen turned upside down.
     * @private
     * @function
     * @name replay-getNormalizedOrientation
     * @param {object} webEvent A normalized event object per the WebEvent
     * @return {integer} The normalized orientation value.
     */
    function getNormalizedOrientation(webEvent) {
        var orientation = 0;
        if (window.orientation) {
            orientation = window.orientation;
        } else if (webEvent !== undefined && webEvent.orientation) {
            orientation = webEvent.orientation;
        }

        // XXX - This functionality should probably be moved into the browser service.
        // TODO: Normalize for Android
        return orientation;
    }


    /**
     * Handles the "orientationchange" event and posts the appropriate message
     * to the replay module's queue.
     * @private
     * @function
     * @name replay-handleOrientationChange
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleOrientationChange(webEvent) {
        var newOrientation = getNormalizedOrientation(webEvent),
            orientationChangeEvent = {
                type: 4,
                event: {
                    type: "orientationchange"
                },
                target: {
                    prevState: {
                        orientation: currOrientation,
                        orientationMode: utils.getOrientationMode(currOrientation)
                    },
                    currState: {
                        orientation: newOrientation,
                        orientationMode: utils.getOrientationMode(newOrientation)
                    }
                }
            };

        postUIEvent(orientationChangeEvent);
        currOrientation = newOrientation;
    }

    /* TODO: Refactor this to use a well-defined touchState object */
    function isDuplicateTouch(touchState) {
        var result = false;

        if (!touchState) {
            return result;
        }

        result = (savedTouch.scale === touchState.scale &&
                Math.abs((new Date()).getTime() - savedTouch.timestamp) < 500);

        return result;
    }

    function saveTouchState(touchState) {
        savedTouch.scale = touchState.scale;
        savedTouch.rotation = touchState.rotation;
        savedTouch.timestamp = (new Date()).getTime();
    }

    /**
     * Takes the scale factor and returns the pinch mode as a text string.
     * Values less than 1 correspond to a pinch close gesture. Values greater
     * than 1 correspond to a pinch open gesture.
     * @private
     * @function
     * @name replay-getPinchType
     * @return {String} "CLOSE", "OPEN" or "NONE" for valid scale values.
     * "INVALID" in case of error.
     */
    function getPinchType() {
        var s,
            pinchType;

        s = deviceScale - previousDeviceScale;
        if (isNaN(s)) {
            pinchType = "INVALID";
        } else if (s < 0) {
            pinchType = "CLOSE";
        } else if (s > 0) {
            pinchType = "OPEN";
        } else {
            pinchType = "NONE";
        }

        return pinchType;
    }

    function addLegacyHeaders(eventType) {
        var pageObjects = [],
            renderTime = 0,
            RENDER_TIME_CAP = 3600000,
            timing = null;

        switch (eventType) {
        case "load":
            pageLoadTime = (new Date()).getTime();

            pageObjects = window.document.getElementsByName("object");
            context.addHeader("X-TeaLeaf-Page-Objects", pageObjects.length);
            break;
        case "unload":
            // Add the render time to the HTTP headers
            timing = utils.getValue(window, "performance.timing");
            if (timing && timing.loadEventStart) {
                renderTime = Math.abs(timing.loadEventStart - timing.responseEnd);
                context.addHeader("X-TeaLeaf-Page-Render", renderTime > RENDER_TIME_CAP ? RENDER_TIME_CAP : renderTime);
            }

            // Add the dwell time to the HTTP headers
            pageDwellTime = (new Date()).getTime() - pageLoadTime;
            context.addHeader("X-TeaLeaf-Page-Dwell", pageDwellTime);

            context.addHeader("X-TeaLeaf-Page-Cui-Exceptions", errorCount);

            context.addHeader("X-TeaLeaf-Visit-Order", visitOrder);

            context.addHeader("X-TeaLeaf-Page-Last-Field", lastVisit);
            break;
        default:
            break;
        }
    }

    /**
     * Used to create the client state message from a webEvent.
     * @private
     * @function
     * @name replay-getClientStateMessage
     * @param {object} webEvent A webEvent that will be used to create the clientState.
     * @return {object} Client state message object.
     */
    function getClientStateMessage(webEvent) {
        var documentElement = document.documentElement,
            documentBody = document.body,
            msg = {
                type: 1,
                clientState: {
                    pageWidth: document.width || (!documentElement ? 0 : documentElement.offsetWidth),
                    pageHeight: Math.max((!document.height ? 0 : document.height), (!documentElement ? 0 : documentElement.offsetHeight), (!documentElement ? 0 : documentElement.scrollHeight)),
                    viewPortWidth: window.innerWidth || documentElement.clientWidth,
                    viewPortHeight: window.innerHeight || documentElement.clientHeight,
                    viewPortX: window.pageXOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollLeft) : documentElement.scrollLeft || 0),
                    viewPortY: window.pageYOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollTop) : documentElement.scrollTop || 0),
                    deviceOrientation: window.orientation || 0,
                    event: utils.getValue(webEvent, "type")
                }
            },
            deviceWidth = 1,
            scaleWidth = 1;

        pastClientState = pastClientState || msg;

        if (Math.abs(msg.clientState.deviceOrientation) === 90) {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalHeight - deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalHeight - deviceToolbarHeight : ((deviceOriginalHeight / devicePixelRatio) - deviceToolbarHeight);
            }
        } else {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalWidth + deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalWidth - deviceToolbarHeight : ((deviceOriginalWidth / devicePixelRatio) - deviceToolbarHeight);
            }
        }

        scaleWidth = (msg.clientState.viewPortWidth === 0 ? 1 : deviceWidth / msg.clientState.viewPortWidth);

        // Made scale a bit smaller to adjust for scroll bars that appear on top of content on certain browsers.
        msg.clientState.deviceScale = (scaleWidth - 0.02).toFixed(3);

        // Set the viewTime for this client state
        msg.clientState.viewTime = 0;
        if (scrollViewStart && scrollViewEnd) {
            msg.clientState.viewTime = scrollViewEnd.getTime() - scrollViewStart.getTime();
        }

        if (webEvent.type === "scroll") {
            msg.clientState.viewPortXStart = pastClientState.clientState.viewPortX;
            msg.clientState.viewPortYStart = pastClientState.clientState.viewPortY;
        }

        return msg;
    }

    /**
     * Post the current client state and also record it as pastClientState.
     * Reset the scrollViewStart/End values.
     * @private
     * @function
     * @name replay-sendClientState
     */
    function sendClientState() {
        if (curClientState) {
            postUIEvent(curClientState);
            pastClientState = curClientState;
            curClientState = null;
            scrollViewStart = nextScrollViewStart || scrollViewStart;
            scrollViewEnd = null;
        }
    }

    /**
     * Used to create client state from a webEvent.
     * @private
     * @function
     * @name replay-handleClientState
     * @param {object} webEvent A webEvent that will created into a clientState and saved for previous and current client state.
     * @return {object} Client state object.
     */
    function handleClientState(webEvent) {
        var attentionMsg = null;

        curClientState = getClientStateMessage(webEvent);

        // TODO: Change these if-else to a switch statement
        if (webEvent.type === "scroll" || webEvent.type === "resize") {
            // Set the interval timeout so we can collect related scroll / resize events in one batch
            if (sendClientState.timeoutId) {
                window.clearTimeout(sendClientState.timeoutId);
                sendClientState.timeoutId = 0;
            }
            sendClientState.timeoutId = window.setTimeout(sendClientState, utils.getValue(config, "scrollTimeout", 2000));
        } else if (webEvent.type === "touchstart" || webEvent.type === "load") {
            if (curClientState) {
                // set the initial device scale which is used to determine what type of pinch happened
                previousDeviceScale = parseFloat(curClientState.clientState.deviceScale);
            }
        } else if (webEvent.type === "touchend") {
            if (curClientState) {
                // used to determine what type of pinch happened
                deviceScale = parseFloat(curClientState.clientState.deviceScale);
                // Send client state on touchend
                sendClientState();
            }
        }

        if (webEvent.type === "load" || webEvent.type === "unload") {
            // The "Attention" event is deprecated
            if (webEvent.type === "unload" && pageLoadTime) {
                // Save the "attention" event which is essentially a dup of the unload with viewTime starting from page load.
                attentionMsg = utils.clone(curClientState);
                attentionMsg.clientState.event = "attention";
                attentionMsg.clientState.viewTime = (new Date()).getTime() - pageLoadTime;
            }

            sendClientState();

            if (attentionMsg) {
                // send the attentionMsg
                curClientState = attentionMsg;
                sendClientState();
            }
        }

        return curClientState;
    }

    /**
     * Handles the "touchstart" event, which is only used to get the deviceScale before a pinch
     * @private
     * @function
     * @name replay-handleTouchStart
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchStart(webEvent) {
        var fingerCount = utils.getValue(webEvent, "nativeEvent.touches.length", 0);

        if (fingerCount === 2) {
            handleClientState(webEvent);
        }
    }

    /**
     * Handles the "touchend" event and posts the appropriate message to the
     * replay module's queue.
     * @private
     * @function
     * @name replay-handleTouchEnd
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchEnd(webEvent) {
        var fingerCount,
            prevTouchState = {},
            // Rotation angle for android devices does not work for all devices/browsers
            rotation = utils.getValue(webEvent, "nativeEvent.rotation", 0) || utils.getValue(webEvent, "nativeEvent.touches[0].webkitRotationAngle", 0),
            scale = utils.getValue(webEvent, "nativeEvent.scale", 1),
            touchState = null,
            touchEndEvent = {
                type: 4,
                event: {
                    type: "touchend"
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        // count the number of fingers placed on the screen
        fingerCount = utils.getValue(webEvent, "nativeEvent.changedTouches.length", 0) + utils.getValue(webEvent, "nativeEvent.touches.length", 0);
        if (fingerCount !== 2) {
            return;
        }

        // 1st handle the client state change. This will update the device scale information.
        handleClientState(webEvent);

        // Only post when there are two fingers reported by the touchend event object
        // create the current touchstate
        touchState = {
            rotation: rotation ? rotation.toFixed(2) : 0,
            scale: deviceScale ? deviceScale.toFixed(2) : 1
        };
        touchState.pinch = getPinchType();

        // create the prev touch state
        prevTouchState.scale = previousDeviceScale ? previousDeviceScale.toFixed(2) : 1;

        // Set the curr and prev states
        touchEndEvent.target.prevState = prevTouchState;
        touchEndEvent.target.currState = touchState;

        postUIEvent(touchEndEvent);
    }

    /**
     * Compares two WebEvent's to determine if they are duplicates. Examines
     * the event type, target id and the timestamp to make this determination.
     * XXX - Push this into the browser service or core?!?
     * @private
     * @function
     * @name replay-isDuplicateEvent
     * @param {object} curr A WebEvent object
     * @param {object} prev A WebEvent object
     * @return {boolean} Returns true if the WebEvents are duplicates.
     */
    function isDuplicateEvent(curr, prev) {
        var propsToCompare = ["type", "target.id"],
            prop = null,
            i,
            len,
            duplicate = true,
            DUPLICATE_EVENT_THRESHOLD_TIME = 10,
            timeDiff = 0,
            currTimeStamp = 0,
            prevTimeStamp = 0;

        // Sanity check
        if (!curr || !prev || typeof curr !== "object" || typeof prev !== "object") {
            duplicate = false;
        }

        // Compare WebEvent properties
        for (i = 0, len = propsToCompare.length; duplicate && i < len; i += 1) {
            prop = propsToCompare[i];
            if (utils.getValue(curr, prop) !== utils.getValue(prev, prop)) {
                duplicate = false;
                break;
            }
        }

        if (duplicate) {
            currTimeStamp = utils.getValue(curr, "timestamp");
            prevTimeStamp = utils.getValue(prev, "timestamp");
            // Don't compare if neither objects have a timestamp
            if (!(isNaN(currTimeStamp) && isNaN(prevTimeStamp))) {
                // Check if the event timestamps are within the predefined threshold
                timeDiff = Math.abs(utils.getValue(curr, "timestamp") - utils.getValue(prev, "timestamp"));
                if (isNaN(timeDiff) || timeDiff > DUPLICATE_EVENT_THRESHOLD_TIME) {
                    duplicate = false;
                }
            }
        }

        return duplicate;
    }

    /**
     * Keeps track of the location.hash and logs the appropriate screenview messages
     * when a hash change is detected.
     * @private
     * @function
     * @name replay-trackHashchange
     */
    function trackHashchange() {
        var currHash = window.location.hash;

        if (currHash === prevHash) {
            return;
        }

        // TODO: Expose logScreenview on context so we don't reference TLT
        if (prevHash) {
            // Send the screenview unload
            TLT.logScreenviewUnload(prevHash);
        }

        if (currHash) {
            // Send the screenview load
            TLT.logScreenviewLoad(currHash);
        }

        // Save the current hash value
        prevHash = currHash;
    }

    /**
      * Returns true if the key (localStorage key) is to be captured. The key is considered
      * to be filtered out if it does not exists in the capture object.
      * @private
      * @function
      * @name replay-isStorageKeyCaptured
      * @param {string} key The key name to be tested
      * associated boolean value. A key marked false will be filtered out or if the key in not found
      * @return {boolean} true if the key is to be captured, false otherwise.
      */
    function isStorageKeyCaptured(key) {
        //[capture] An object that contains key names
        var capture = config.storageKeys;

        // Sanity check
        if (typeof key !== "string") {
            return false;
        }

        if (utils.indexOf(capture, key) === -1) {
            return false;
        }
        return true;
    }

    /**
     * Handles the "webStorage" event and posts the appropriate message to the
     * replay module's queue only if isStorage(key)
     * @private
     * @function
     * @name replay-handleStorage
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleStorage(data) {
        var storage = null;
        if (data && isStorageKeyCaptured(data.key)) {
            storage = {
                type: 8,
                webStorage: data
            };

            postUIEvent(storage);
        }

        return storage;
    }

    /**
     * Extend the getItem() method of the object Storage
     * This is done to capture reads from localStorage.getItem().
     * Assuming client js is using this api and this method is run before everything else.
     * @private
     * @function
     * @name replay extendGetItem
     * @returns {Boolean} false for failiure and true for success.
     **/
    extendGetItem = (function (window) {
        var _getItem = window.Storage ? window.Storage.prototype.getItem : function () {};

        return function () {
            var storageData;
            try {
                window.Storage.prototype.getItem = function (key) {
                    try {
                        var value = _getItem.call(localStorage, key);
                        storageData = {
                            key: key || null,
                            value: value
                        };

                        handleStorage(storageData);
                        return value;
                    } catch (e) {}
                };
            } catch (e) {
                return false;
            }
            return true;
        };
    }(window));

    /**
     * Default handler for event types that are not being processed by the module.
     * @private
     * @function
     * @param {object} webEvent A WebEvent object
     * @name replay-defaultEventHandler
     */
    function defaultEventHandler(webEvent) {
        var msg = {
                type: 4,
                event: {
                    type: webEvent.type
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        postUIEvent(msg);
    }

    return {
        // Expose private functions for unit testing
        tlTypes: tlTypes,
        currOrientation: currOrientation,
        pastEvents: pastEvents,
        lastEventId: lastEventId,
        getTmpQueue: function () { return tmpQueue; },
        postEventQueue: postEventQueue,
        eventCounter: eventCounter,
        curClientState: curClientState,
        getViewEventStart: function () { return viewEventStart; },
        setViewEventStart: function (newViewEventStart) {viewEventStart = newViewEventStart; },
        viewTimeStart: viewTimeStart,
        parentElements: parentElements,
        getParentLink: getParentLink,
        createQueueEvent: createQueueEvent,
        postUIEvent: postUIEvent,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleChange: handleChange,
        handleClick: handleClick,
        getNormalizedOrientation: getNormalizedOrientation,
        handleOrientationChange: handleOrientationChange,
        handleClientState: handleClientState,
        getPinchType: getPinchType,
        saveTouchState: saveTouchState,
        isDuplicateTouch: isDuplicateTouch,
        getTlEvent: getTlEvent,
        isDuplicateEvent: isDuplicateEvent,
        scheduleDOMCapture: scheduleDOMCapture,
        addDOMCapture: addDOMCapture,
        trackHashchange: trackHashchange,
        isTargetClickable: isTargetClickable,
        defaultEventHandler: defaultEventHandler,
        extendGetItem: extendGetItem,
        isStorageKeyCaptured: isStorageKeyCaptured,
        handleStorage: handleStorage,
        init: function () {
            tmpQueue = [];
        },
        destroy: function () {
            handleBlur(lastEventId);
            tmpQueue = [];
        },
        onevent: function (webEvent) {
            var id = null,
                returnObj = null;

            // Sanity checks
            if (typeof webEvent !== "object" || !webEvent.type) {
                return;
            }

            if (isDuplicateEvent(webEvent, prevWebEvent)) {
                prevWebEvent = webEvent;
                return;
            }

            prevWebEvent = webEvent;

/*jshint devel:true */

            if (typeof console !== "undefined") {
                console.log("Replay event: ", webEvent);
            }

            id = utils.getValue(webEvent, "target.id");

            if (Object.prototype.toString.call(pastEvents[id]) !== "[object Object]") {
                pastEvents[id] = {};
            }

            checkQueue(id, webEvent);
            inBetweenEvtsTimer = new Date();

            switch (webEvent.type) {
            case "hashchange":
                trackHashchange();
                break;
            case "focus":
                returnObj = handleFocus(id, webEvent);
                break;
            case "blur":
                returnObj = handleBlur(id, webEvent);
                break;
            case "click":
                // Normal click processing
                returnObj = handleClick(id, webEvent);
                break;
            case "change":
                returnObj = handleChange(id, webEvent);
                break;
            case "orientationchange":
                returnObj = handleOrientationChange(webEvent);
                break;
			case "touchstart":
				handleTouchStart(webEvent);
				break;
            case "touchend":
                returnObj = handleTouchEnd(webEvent);
                break;
            case "load":
                extendGetItem();
                addLegacyHeaders("load");
                // initialize the start time for the scrolled view
                scrollViewStart = new Date();

                // send initial clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewLoad("root");

                break;
            case "screenview_load":
                // starts screenview time used for calculating the offset
                viewTimeStart = new Date();

                // Check and add DOM Capture
                returnObj = addDOMCapture("load", null, webEvent.name);

                break;
            case "screenview_unload":
                // Check and add DOM Capture
                returnObj = addDOMCapture("unload", null, webEvent.name);

                break;
            case "resize":
            case "scroll":
                if (!scrollViewEnd) {
                    scrollViewEnd = new Date();
                }
                nextScrollViewStart = new Date();

                handleClientState(webEvent);

                break;
            case "unload":
                // Flush any saved control
                if (tmpQueue !== null) {
                    postEventQueue(tmpQueue);
                }

                addLegacyHeaders("unload");
                // set the final timestamp of this scrolled view.
                scrollViewEnd = new Date();

                // send final clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewUnload("root");

                break;
            default:
                // Call the default handler for all other DOM events
                defaultEventHandler(webEvent);
                break;
            }

            lastEventId = id;
            return returnObj;
        },
        onmessage: function () {
        }
    };
});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SaaS module implements the logic for using Tealeaf in the cloud.
 * @exports saas
 */

/*global TLT:true */

// Sanity check
TLT.addModule("saas", function (context) {
    "use strict";

    /**
     * Sets the SaaS data object to the configuration specified by the user in the config.
     * @private
     */
    var SaasData = function () {
			if (typeof TLT.getCoreConfig().modules.saas !== "undefined") {
				var key;

				for (key in TLT.getCoreConfig().modules.saas) {
					if (TLT.getCoreConfig().modules.saas.hasOwnProperty(key) && typeof key === "string" && typeof TLT.getCoreConfig().modules.saas[key] === "string") {
						this[key] = TLT.getCoreConfig().modules.saas[key];
						document.cookie = key + "=" + this[key];
					}
				}

				/**
				* Gets Tealeaf SaaS session data
				* @function
				* @name saas-saasData.get
				* @param {string} key SaaS session key to get.
				* @return {string} Value associated with the SaaS session key or error description.
				*/
				this.get = function (key) {
					if (typeof key !== "string" || typeof this === "undefined") {
						return "SaaS Data undefined or key is not a string";
					}
					if (typeof this[key] === "undefined") {
						return "Key does not exist within saasData";
					}
					return this[key];
				};

				/**
				* Sets Tealeaf SaaS session data.
				* @function
				* @name saas-saasData.set
				* @param {string} key SaaS session key to be changed or created.
				* @param {string} value SaaS session value to be set.
				* @return {boolean} True if the cookie was set, false if not.
				*/
				this.set = function (key, value) {
					if (typeof key !== "string" || typeof value !== "string" || typeof this === "undefined" || key === "get" || key === "set" || key === "toSaasString" || key === "clear" || key === "remove") {
						return false;
					}
					this[key] = value;
					document.cookie = key + "=" + value;
					return true;
				};

				/**
				* Clears Tealeaf SaaS data.
				* @function
				* @name saas-saasData.clear
				* @returns {void}
				*/
				this.clear = function () {
					var key;
					for (key in this) {
						if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
							document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
							delete this[key];
						}
					}
					return;
				};

				/**
				* Removes a key/value pair from Tealeaf SaaS data.
				* @function
				* @name saas-saasData.remove
				* @returns {void}
				*/
				this.remove = function (key) {
					if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
						document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
						delete this[key];
					}
					return;
				};

				/**
				* Converts Tealeaf SaaS session key/value pairs into a semi-colon separated string
				* @function
				* @name saas-saasData.toString
				* @return {string} Key/value pairs in a semi-colon separated string like "key1=value1;key2=value2..."
				*/
				this.toSaasString = function () {
					var saasDataString = "",
						key;
					for (key in this) {
						if (this.hasOwnProperty(key) && typeof this.get(key) === "string") {
							saasDataString += key + "=" + this.get(key) + ";";
						}
					}
					return saasDataString;
				};
			}
		},
		_saasData = new SaasData();

    // Return the module's interface object. This contains callback functions which
    // will be invoked by the UIC core.
    return {
        init: function () {
            // Attach any custom event handlers here
			TLT.saasData = _saasData;
        },
        destroy: function () {
            // Detach any custom event handlers here
        },
        onevent: function (webEvent) {
            // Process DOM events that you registered in the configuration as
            // per your customized requirements
        }
    };

});
</script>
<script type="text/tljs" id="UIC-SDK-FILE-w3c-dev">/*!
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * @version 4.0.0.1607
 * @flags w3c,DEBUG,SUPPORT_LEGACY_HEADERS,ENABLE_LOCALSTORAGE_CAPTURE
 */

/**
 * @fileOverview Defines the core of the system, namely the TLT object.
 * @exports TLT
 */
/*global window*/
/*jshint loopfunc:true*/
/**
 * TLT (short for Tealeaf Technology) is the top-level object for the system. All
 * objects and functions live under TLT to prevent polluting the global
 * scope. This object also manages the modules and services on the page,
 * controlling their lifecycle, manages inter-module communication.
 * @namespace
 */
// Sanity check
if (window.TLT) {
    throw "Attempting to recreate TLT. Library may be included more than once on the page.";
}
var TLT = (function () {

    "use strict";

    /* Create and add a screenview message to the default queue. Also
     * notifies any listeners of the screenview load/unload event.
     * @param {Enum} type "LOAD" or "UNLOAD" indicating the type
     * of screenview event.
     * @param {string} name User friendly name of the screenview.
     * @param {string} [referrerName] Name of the previous screenview that
     * is being replaced.
     * @param {object} [root] DOMNode which represents the root or
     * parent of this screenview. Usually this is a div container.
     * @returns {void}
     */
    function logScreenview(type, name, referrerName, root) {
        var dcid = null,
            screenviewMsg = null,
            queue = TLT.getService("queue"),
            replay = TLT.getModule("replay"),
            webEvent = null,
            winLocation = window.location,
            host = winLocation.origin || null,
            url = winLocation.pathname;

        // Sanity checks
        if (!name || typeof name !== "string") {
            return;
        }
        if (!referrerName || typeof referrerName !== "string") {
            referrerName = "";
        }

        if (!host) {
            host = (winLocation.protocol || "") + "//" + (winLocation.host || "");
        }

        // This is needed for Native hybrid replay to get file path of webview assets used.
        if (host.indexOf("file://") > -1) {
            url = url.replace(/(.*?)(?=\/[^.\/]*\.app)/g, '').replace('.app//', '.app/');
        }

        screenviewMsg = {
            type: 2,
            screenview: {
                type: type,
                name: name,
                url: url,
                host: host,
                referrer: referrerName
            }
        };

        // XXX: Fix this hack. At least send a fully populated WebEvent object.
        // Ideally, want to use the publishEvent to route this to the correct modules.
        if (type === "LOAD") {
            webEvent = {
                type: "screenview_load",
                name: name
            };
        } else if (type === "UNLOAD") {
            webEvent = {
                type: "screenview_unload",
                name: name
            };
        }

        if (webEvent && replay) {
            dcid = replay.onevent(webEvent);
        }

        // If DOM Capture was triggered for this add it to the screenview message.
        if (dcid) {
            screenviewMsg.dcid = dcid;
        }

        if (type === "LOAD" || type === "UNLOAD") {
            queue.post("", screenviewMsg, "DEFAULT");
        }
    }


    var tltStartTime = (new Date()).getTime(),

        /**
         * A collection of module information. The keys in this object are the
         * module names and the values are an object consisting of three pieces
         * of information: the creator function, the instance, and context object
         * for that module.
         * @private
         */
        modules = {},

        /**
         * A collection of service information. The keys in this object are the
         * service names and the values are an object consisting of two pieces
         * of information: the creator function and the service object.
         * @private
         */
        services = {},

        /**
         * Indicates if the core has been initialized or not.
         * @private
         */
        initialized = false,
        state = null,

        /**
         * Checks whether given frame is blacklisted (in the config) or not.
         * @function
         * @private
         * @param {DOMElement} iframe an element to examine
         * @return {boolean} true if given iframe is blacklisted, false otherwise
         */
        isFrameBlacklisted = (function () {
            var blacklistedFrames,
                checkedFrames = [];

            function prepareBlacklistedFrames(scope) {
                var browserService = core.getService("browser"),
                    blacklist = core.getCoreConfig().framesBlacklist,
                    foundFrames,
                    i;
                blacklistedFrames = blacklistedFrames || [];
                scope = scope || null;
                if (typeof blacklist !== "undefined" && blacklist.length > 0) {
                    for (i = 0; i < blacklist.length; i += 1) {
                        foundFrames = browserService.queryAll(blacklist[i], scope);
                        if (foundFrames && foundFrames.length > 0) {
                            blacklistedFrames = blacklistedFrames.concat(foundFrames);
                        }
                    }
                    checkedFrames = checkedFrames.concat(browserService.queryAll('iframe', scope));
                }
            }

            function isFrameBlacklisted(iframe) {
                if (core.utils.indexOf(checkedFrames, iframe) < 0) {
                    prepareBlacklistedFrames(iframe.ownerDocument);
                }
                return core.utils.indexOf(blacklistedFrames, iframe) > -1;
            }

            isFrameBlacklisted.clearCache = function () {
                blacklistedFrames = null;
            };

            return isFrameBlacklisted;
        }()),

        /**
         * Last clicked element, needed for IE and 'beforeunload'
         * @private
         */
        lastClickedElement = null,

        /**
         * List of service passthroughs. These are methods that are called
         * from TLT and simply pass through to the given service without
         * changing the arguments. Doing this dynamically keeps the code
         * smaller and easier to update.
         * @private
         */
        servicePassthroughs = {

            "config": [

                /**
                 * Returns the global configuration object (the one passed to init()).
                 * @name getConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The global configuration object.
                 */
                "getConfig",

                /**
                 * Updates the global configuration object (the one passed to init()).
                 * @name updateConfig
                 * @memberOf TLT
                 * @function
                 * @returns {void}
                 */
                "updateConfig",

                /**
                 * Returns the core configuration object.
                 * @name getCoreConfig
                 * @memberOf TLT
                 * @function
                 * @returns {Object} The core configuration object.
                 */
                "getCoreConfig",

                /**
                 * Updates the core configuration object.
                 * @name updateCoreConfig
                 * @memberOf TLT
                 * @function
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateCoreConfig",

                /**
                 * Returns the configuration object for a module.
                 * @name getModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getModuleConfig",

                /**
                 * Updates a configuration object for a module.
                 * @name updateModuleConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} moduleName The name of the module to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateModuleConfig",

                /**
                 * Returns a configuration object for a service.
                 * @name getServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @returns {Object} The configuration object for the given module.
                 */
                "getServiceConfig",

                /**
                 * Updates a configuration object for a service.
                 * @name updateServiceConfig
                 * @memberOf TLT
                 * @function
                 * @param {String} serviceName The name of the service to retrieve config data for.
                 * @param {Object} config The updated configuration object.
                 * @returns {void}
                 */
                "updateServiceConfig"

            ],

            "queue": [
                /**
                 * Add HTTP header information to the module's default queue.
                 * This doesn't force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name addHeader
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName  The name of the module saving the header.
                 * @param  {String} headerName  The name of the header.
                 * @param  {String} headerValue The value of the header.
                 * @param  {String} [queueId]   Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "addHeader",
                /**
                 * Send event information to the module's default queue.
                 * This doesn't necessarily force the event data to be sent to the server,
                 * as this behavior is defined by the queue itself.
                 * @name post
                 * @memberOf TLT
                 * @function
                 * @param  {String} moduleName The name of the module saving the event.
                 * @param  {Object} queueEvent The event information to be saved to the queue.
                 * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
                 * @returns {void}
                 */
                "post",
                /**
                 * Enable/disable the automatic flushing of all queues.
                 * Either periodically by a timer or whenever the queue threshold is reached.
                 * @name setAutoFlush
                 * @memberOf TLT
                 * @function
                 * @param {Boolean} flag Set this to false to disable flushing
                 *                 or set it to true to enable automatic flushing (default)
                 * @returns {void}
                 */
                "setAutoFlush",
                /**
                 * Forces all queues to send their data to the server.
                 * @name flushAll
                 * @memberOf TLT
                 * @function
                 */
                "flushAll"

            ],

            "browserBase": [
                /**
                 * Calculates the xpath of the given DOM Node.
                 * @name getXPathFromNode
                 * @memberOf TLT
                 * @function
                 * @param {DOMElement} node The DOM node who's xpath is to be calculated.
                 * @returns {String} The calculated xpath.
                 */
                "getXPathFromNode",

                /**
                 * Let the UIC library process a DOM event, which was prevented
                 * from bubbling by the application.
                 * @name processDOMEvent
                 * @memberOf TLT
                 * @function
                 * @param {Object} event The browsers event object which was prevented.
                 */
                "processDOMEvent"
            ]
        },

        /**
         * Provides methods for handling load/unload events to make sure that this
         * kind of events will be handled independently to browser caching mechanism
         * @namespace
         * @private
         */
        loadUnloadHandler = (function () {
            var status = {};

            return {

                /**
                 * Normalizes the events specified in the configuration in the following ways:
                 * - For each load/unload module event adds corresponding pageshow/pagehide event.
                 * - Adds beforeunload
                 * - Adds propertychange if W3C service is being used for correct operation on legacy IE.
                 * @param {String} moduleName Name of the module
                 * @param {Array} moduleEvents An array of module event configs
                 * @param {object} [localTop] Local window element
                 * @param {object} [documentScope] document element
                 */
                normalizeModuleEvents: function (moduleName, moduleEvents, localTop, documentScope) {
                    var load = false,
                        unload = false,
                        browserService = core.getService("browser");

                    localTop = localTop || core._getLocalTop();
                    documentScope = documentScope || localTop.document;

                    status[moduleName] = {
                        loadFired: false,
                        pageHideFired: false
                    };

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        switch (eventConfig.name) {
                        case "load":
                            load = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pageshow"
                            }));
                            break;

                        case "unload":
                            unload = true;
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "pagehide"
                            }));
                            moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                name: "beforeunload"
                            }));
                            break;

                        // IE6, IE7 and IE8 - catching 'onpropertychange' event to
                        // simulate correct 'change' events on radio and checkbox.
                        // required for W3C only as jQuery normalizes it.
                        case "change":
                            if (core.utils.isLegacyIE && core.getFlavor() === "w3c") {
                                moduleEvents.push(core.utils.mixin(core.utils.mixin({}, eventConfig), {
                                    name: "propertychange"
                                }));
                            }
                            break;
                        }
                    });
                    if (!load && !unload) {
                        delete status[moduleName];
                        return;
                    }
                    status[moduleName].silentLoad = !load;
                    status[moduleName].silentUnload = !unload;
                    if (!load) {
                        moduleEvents.push({name: "load", target: localTop});
                    }
                    if (!unload) {
                        moduleEvents.push({name: "unload", target: localTop});
                    }
                },

                /**
                 * Checks if event can be published for the module(s) or not.
                 * The negative case can take place for load/unload events only, to avoid
                 * redundancy in handler execution. If as example load event was handled
                 * properly, the pageshow event will be ignored.
                 * @param {string} moduleName Name of the module
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                canPublish: function (moduleName, event) {
                    var mod;
                    if (status.hasOwnProperty(moduleName) === false) {
                        return true;
                    }
                    mod = status[moduleName];
                    switch (event.type) {
                    case "load":
                        mod.pageHideFired = false;
                        mod.loadFired = true;
                        return !mod.silentLoad;
                    case "pageshow":
                        mod.pageHideFired = false;
                        event.type = "load";
                        return !mod.loadFired && !mod.silentLoad;
                    case "pagehide":
                        event.type = "unload";
                        mod.loadFired = false;
                        mod.pageHideFired = true;
                        return !mod.silentUnload;
                    case "unload":
                    case "beforeunload":
                        event.type = "unload";
                        mod.loadFired = false;
                        return !mod.pageHideFired && !mod.silentUnload;
                    }
                    return true;
                },

                /**
                 * Checks if event indicates the core context is unloading.
                 * @param {WebEvent} event An instance of WebEvent
                 * @return {boolean}
                 */
                isUnload: function (event) {
                    return typeof event === "object" ?
                            (event.type === "unload" || event.type === "beforeunload" || event.type === "pagehide") :
                            false;
                }
            };

        }()),

        /**
         * Keeps track of the events being handled.
         * @private
         */
        events = {},

        /**
         * Keeps track of callback functions registered by the iOS and Android native libraries.
         * These are used for communication with the native library.
         */
        bridgeCallbacks = {},

        /**
         * init implementation (defined later)
         * @private
         */
        _init = function () {},
        _callback = null,

        /**
         * Flag to track if TLT.init API can been called.
         * @private
         */
        okToCallInit = true,

        // Tracks the inactivity timeout in publishEvent
        inactivityTimerId = null,
        // Placeholder for the inactivity timeout handler, defined after core.
        inactivityTimeoutHandler = function () {},

        // main interface for the core
        core = /**@lends TLT*/ {

            /**
             * Flag for debug builds
             */
            debugMode: true,

            /**
             * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
             */
            getStartTime: function () {
                return tltStartTime;
            },

            //---------------------------------------------------------------------
            // Core Lifecycle
            //---------------------------------------------------------------------

            /**
             * Initializes the system. The configuration information is passed to the
             * config service to management it. All modules are started (unless their
             * configuration information indicates they should be disabled), and web events
             * are hooked up.
             * @param {Object} config The global configuration object.
             * @param {function} [callback] function executed after initialization and destroy
                    the callback function takes one parameter which describes UIC state;
                    its value can be set to "initialized" or "destroyed"
             * @returns {void}
             */
            init: function (config, callback) {
                var timeoutCallback;
                _callback = callback;
                if (!okToCallInit) {
                    throw "init must only be called once!";
                }
                okToCallInit = false;
                timeoutCallback = function (event) {
                    event = event || window.event || {};
                    if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
                        if (document.removeEventListener) {
                            document.removeEventListener("DOMContentLoaded", timeoutCallback, false);
                            window.removeEventListener("load", timeoutCallback, false);
                        } else {
                            document.detachEvent("onreadystatechange", timeoutCallback);
                            window.detachEvent("onload", timeoutCallback);
                        }
                        _init(config, callback);
                    }
                };

                // case when DOM already loaded (lazy-loaded UIC)
                if (document.readyState === "complete") {
                    // Lets the current browser cycle to complete before calling init
                    setTimeout(timeoutCallback);
                } else if (document.addEventListener) {
                    document.addEventListener("DOMContentLoaded", timeoutCallback, false);
                    // A fallback in case DOMContentLoaded is not supported
                    window.addEventListener("load", timeoutCallback, false);
                } else {
                    document.attachEvent("onreadystatechange", timeoutCallback);
                    // A fallback in case onreadystatechange is not supported
                    window.attachEvent("onload", timeoutCallback);
                }
            },

            /**
             * Indicates if the system has been initialized.
             * @returns {Boolean} True if init() has been called, false if not.
             */
            isInitialized: function () {
                return initialized;
            },

            getState: function () {
                return state;
            },

            /**
             * Shuts down the system. All modules are stopped and all web events
             * are unsubscribed.
             * @returns {void}
             */
            // destroy: function (skipEvents, callback) {
            destroy: function (skipEvents) {

                var token = "",
                    eventName = "",
                    target = null,
                    serviceName = null,
                    service = null,
                    browser = null,
                    delegateTarget = false;

                if (okToCallInit) { //nothing to do
                    return false;
                }

                this.stopAll();

                if (!skipEvents) {
                    browser = this.getService("browser");
                    // Unregister events
                    for (token in events) {
                        if (events.hasOwnProperty(token) && browser !== null) {
                            eventName = token.split("|")[0];
                            target = events[token].target;
                            delegateTarget = events[token].delegateTarget || undefined;
                            browser.unsubscribe(eventName, target, this._publishEvent, delegateTarget);
                        }
                    }
                }

                // call destroy on services that have it
                for (serviceName in services) {
                    if (services.hasOwnProperty(serviceName)) {
                        service = services[serviceName].instance;

                        if (service && typeof service.destroy === "function") {
                            service.destroy();
                        }

                        services[serviceName].instance = null;
                    }
                }

                isFrameBlacklisted.clearCache();
                events = {};
                initialized = false;

                // Reset to allow re-initialization.
                okToCallInit = true;

                state = "destroyed";

                if (typeof _callback === "function") {
                    // Protect against unexpected exceptions since _callback is 3rd party code.
                    try {
                        _callback("destroyed");
                    } catch (e) {
                        // Do nothing!
                    }
                }
            },

            /**
             * Iterates over each module and starts or stops it according to
             * configuration information.
             * @returns {void}
             * @private
             */
            _updateModules: function (scope) {

                var config = this.getCoreConfig(),
                    browser = this.getService("browser"),
                    moduleConfig = null,
                    moduleName = null;

                if (config && browser && config.modules) {
                    try {
                        for (moduleName in config.modules) {
                            if (config.modules.hasOwnProperty(moduleName)) {
                                moduleConfig = config.modules[moduleName];

                                if (modules.hasOwnProperty(moduleName)) {
                                    if (moduleConfig.enabled === false) {
                                        this.stop(moduleName);
                                        continue;
                                    }

                                    this.start(moduleName);

                                    // If the module has specified events in the configuration
                                    // register event handlers for them.
                                    if (moduleConfig.events) {
                                        this._registerModuleEvents(moduleName, moduleConfig.events, scope);
                                    }
                                } else {    // it needs to be loaded
                                    if (browser.loadScript) {
                                        browser.loadScript(config.moduleBase + moduleName + ".js");
                                        // no callback needed because the module will start automatically
                                    }
                                }
                            }
                        }
                        this._registerModuleEvents.clearCache();
                    } catch (e) {
                        core.destroy();
                        return false;
                    }
                } else {
                    return false;
                }
                return true;
            },

            /**
             * Registers event handlers for all modules in a specific scope.
             * E.g. if the application changed the DOM via ajax and want to let
             * us rebind event handlers in this scope.
             * @param  {Object} scope A DOM element as a scope.
             */
            rebind: function (scope) {
                core._updateModules(scope);
            },

            /* Public API which returns the Tealeaf session data that has been
             * configured to be shared with 3rd party scripts.
             * @returns {object} JSON object containing the session data as
             * name-value pairs. If no data is available then returns null.
             */
            getSessionData: function () {

                if (!core.isInitialized()) {
                    throw "getSessionData API was called before UIC is initialized.";
                }

                var rv = null,
                    sessionData = null,
                    scName,
                    scValue,
                    config = core.getCoreConfig();

                if (!config || !config.sessionDataEnabled) {
                    return null;
                }

                sessionData = config.sessionData || {};

                // Add any session ID data
                scName = sessionData.sessionQueryName;
                if (scName) {
                    scValue = core.utils.getQueryStringValue(scName, sessionData.sessionQueryDelim);
                } else {
                    // Either the cookie name is configured or the default is assumed.
                    scName = sessionData.sessionCookieName || "TLTSID";
                    scValue = core.utils.getCookieValue(scName);
                }

                if (scName && scValue) {
                    rv = rv || {};
                    rv.tltSCN = scName;
                    rv.tltSCV = scValue;
                    rv.tltSCVNeedsHashing = !!sessionData.sessionValueNeedsHashing;
                }

                return rv;
            },

            /* Public API to create and add a custom event message to the default
             * queue.
             * @param {string} name Name of the custom event.
             * @param {object} customObj Custom object which will be serialized
             * to JSON and included with the custom message.
             * @returns {void}
             */
            logCustomEvent: function (name, customMsgObj) {

                if (!core.isInitialized()) {
                    throw "logCustomEvent API was called before UIC is initialized.";
                }

                var customMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!name || typeof name !== "string") {
                    name = "CUSTOM";
                }
                customMsgObj = customMsgObj || {};

                customMsg = {
                    type: 5,
                    customEvent: {
                        name: name,
                        data: customMsgObj
                    }
                };
                queue.post("", customMsg, "DEFAULT");
            },

            /* Public API to create and add an exception event message to the
             * default queue.
             * @param {string} msg Description of the error or exception.
             * @param {string} [url] URL related to the error or exception.
             * @param {integer} [line] Line number associated with the error or exception.
             * @returns {void}
             */
            logExceptionEvent: function (msg, url, line) {

                if (!core.isInitialized()) {
                    throw "logExceptionEvent API was called before UIC is initialized.";
                }

                var exceptionMsg = null,
                    queue = this.getService("queue");

                // Sanity checks
                if (!msg || typeof msg !== "string") {
                    return;
                }
                url = url || "";
                line = line || "";

                exceptionMsg = {
                    type: 6,
                    exception: {
                        description: msg,
                        url: url,
                        line: line
                    }
                };

                queue.post("", exceptionMsg, "DEFAULT");
            },

            /* Public API to create and add a screenview LOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * being loaded. Note: The same name must be used when the screenview
             * UNLOAD API is called.
             * @param {string} [referrerName] Name of the previous screenview that
             * is being replaced.
             * @param {object} [root] DOMNode which represents the root or
             * parent of this screenview. Usually this is a div container.
             * @returns {void}
             */
            logScreenviewLoad: function (name, referrerName, root) {

                if (!core.isInitialized()) {
                    throw "logScreenviewLoad API was called before UIC is initialized.";
                }

                logScreenview("LOAD", name, referrerName, root);
            },

            /* Public API to create and add a screenview UNLOAD message to the
             * default queue.
             * @param {string} name User friendly name of the screenview that is
             * unloaded. Note: This should be the same name used in the screenview
             * LOAD API.
             * @returns {void}
             */
            logScreenviewUnload: function (name) {

                if (!core.isInitialized()) {
                    throw "logScreenviewUnload API was called before UIC is initialized.";
                }

                logScreenview("UNLOAD", name);
            },

            /* Public API to log a DOM Capture message to the default queue.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            logDOMCapture: function (root, config) {
                var dcid = null,
                    domCaptureData,
                    domCaptureService,
                    msg,
                    queue;

                if (!this.isInitialized()) {
                    throw "logDOMCapture API was called before UIC is initialized.";
                }

                // DOM Capture is not supported on IE 8 and below
                if (core.utils.isLegacyIE) {
                    return dcid;
                }

                domCaptureService = this.getService("domCapture");
                if (domCaptureService) {
                    root = root || window.document;
                    config = config || {};
                    domCaptureData = domCaptureService.captureDOM(root, config);
                    if (domCaptureData) {
                        // Add the unique id for this DOM Capture message
                        dcid = config.dcid || ("dcid-" + this.utils.getSerialNumber() + "." + (new Date()).getTime());
                        domCaptureData.dcid = dcid;
                        // Create the message
                        msg = {
                            "type": 12,
                            "domCapture": domCaptureData
                        };
                        // POST it to the queue
                        queue = this.getService("queue");
                        queue.post("", msg, "DEFAULT");
                    } else {
                        dcid = null;
                    }
                }
                return dcid;
            },

            /* Function invoked by modules to log a DOM Capture message to the default queue.
             * @param {String} moduleName Name of the module which invoked this function.
             * @param {DOMElement} [root] Parent element from which to start the capture.
             * @param {Object} [config] DOM Capture configuration options.
             * @returns {String} The unique string representing the DOM Capture id.
             * null if DOM Capture failed.
             */
            performDOMCapture: function (moduleName, root, config) {
                return this.logDOMCapture(root, config);
            },

            /**
             * Helper function for registerBridgeCallbacks
             * It checks if the call back type is valid and enabled.
             * @function
             * @private
             * @param {String}
             * @returns {boolean} Whether callback type is enabled.
             */
            _bridgeCallback: function (cbType) {
                var callBackType = bridgeCallbacks[cbType];

                if (callBackType && callBackType.enabled) {
                    return callBackType;
                }
                return null;
            },

            /**
             * Public API to add a screenshot capture. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            logScreenCapture: function () {
                if (!core.isInitialized()) {
                    throw "logScreenCapture API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("screenCapture");
                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to enable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            enableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    throw "enableTealeafFramework API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("enableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to disable Tealeaf framework. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            disableTealeafFramework: function () {
                if (!core.isInitialized()) {
                    throw "disableTealeafFramework API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("disableTealeafFramework");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start a new Tealeaf session. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {void}
             */
            startNewTLFSession: function () {
                if (!core.isInitialized()) {
                    throw "startNewTLFSession API was called before UIC is initialized.";
                }
                var bridgeCallback = core._bridgeCallback("startNewTLFSession");

                if (bridgeCallback !== null) {
                    bridgeCallback.cbFunction();
                }
            },

            /**
             * Public API to start get current Tealeaf session Id. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @returns {String} Current session Id
             */
            currentSessionId: function () {
                if (!core.isInitialized()) {
                    throw "currentSessionId API was called before UIC is initialized.";
                }
                var sessionId,
                    bridgeCallback = core._bridgeCallback("currentSessionId");

                if (bridgeCallback !== null) {
                    sessionId = bridgeCallback.cbFunction();
                }
                return sessionId;
            },

            /**
             * Public API to get default value of a configurable item in
             * TLFConfigurableItems.properties file.  This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            defaultValueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    throw "defaultValueForConfigurableItem API was called before UIC is initialized.";
                }
                var value,
                    bridgeCallback = core._bridgeCallback("defaultValueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to get the value of a configurable item either from TLFConfigurableItems.properties file
             * or in memory data structure. This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @returns {String} The value for the item.
             */
            valueForConfigurableItem: function (configItem) {
                if (!core.isInitialized()) {
                    throw "valueForConfigurableItem API was called before UIC is initialized.";
                }
                var value,
                    bridgeCallback = core._bridgeCallback("valueForConfigurableItem");

                if (bridgeCallback !== null) {
                    value = bridgeCallback.cbFunction(configItem);
                }
                return value;
            },

            /**
             * Public API to set the value of a configurable item in TLFConfigurableItems.properties file.
             * This updates only in the memory value. This needs to be
             * implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} configItem This is the name of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            setConfigurableItem: function (configItem, value) {
                if (!core.isInitialized()) {
                    throw "setConfigurableItem API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("setConfigurableItem");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(configItem, value);
                }
                return result;
            },

            /**
             * Public API to add additional http header.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} key This is the key of the configurable item.
             * @param {String} value The value assign to the configItem.
             * @returns {boolean} Wether item was set.
             */
            addAdditionalHttpHeader: function (key, value) {
                if (!core.isInitialized()) {
                    throw "addAdditionalHttpHeader API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("addAdditionalHttpHeader");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(key, value);
                }
                return result;
            },

            /**
             * Public API to log custom event.
             * This needs to be implemented and registered (see registerBridgeCallbacks)
             * If no callback has been registered, then a call to this API
             * does nothing.
             * @param {String} eventName A custom event name.
             * @param {String} jsonData JSON data string.
             * @param {int} logLevel Tealeaf library logging level for the event.
             * @returns {boolean} Wether item was set.
             */
            logCustomEventBridge: function (eventName, jsonData, logLevel) {
                if (!core.isInitialized()) {
                    throw "logCustomEventBridge API was called before UIC is initialized.";
                }
                var result = false,
                    bridgeCallback = core._bridgeCallback("logCustomEventBridge");

                if (bridgeCallback !== null) {
                    result = bridgeCallback.cbFunction(eventName, jsonData, logLevel);
                }
                return result;
            },

            /**
             * Public API to allow registration of callback functions
             * These callback types are supported currently:
             * 1. screenCapture: Registering this type enables ability to
             *    take screenshots from script.
             * 2. messageRedirect: Registering this type will allow the
             *    callback function to process (and consume) the message
             *    instead of being handled by the default queue.
             * 3. addRequestHeaders: Registering this type will allow the
             *    callback function to return an array of HTTP request headers
             *    that will be set by the UIC in it's requests to the target.
             * @param {Array} callbacks Array of callback objects. Each object
             *                is of the format: {
             *                    {boolean}  enabled
             *                    {string}   cbType
             *                    {function} cbFunction
             *                }
             *                If the callbacks array is empty then any previously
             *                registered callbacks would be removed.
             * @returns {boolean} true if callbacks were registered. false otherwise.
             */
            registerBridgeCallbacks: function (callbacks) {
                var i = 0,
                    len = 0,
                    cb = null;

                // Sanity check
                if (!callbacks) {
                    return false;
                }
                if (callbacks.length === 0) {
                    // Reset any previously registered callbacks.
                    bridgeCallbacks = {};
                    return false;
                }
                try {
                    for (i = 0, len = callbacks.length; i < len; i += 1) {
                        cb = callbacks[i];
                        if (typeof cb === "object" && cb.cbType && cb.cbFunction) {
                            bridgeCallbacks[cb.cbType] = {
                                enabled: cb.enabled,
                                cbFunction: cb.cbFunction
                            };
                        }
                    }
                } catch (e) {
                    return false;
                }
                return true;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the queue to be redirected if a messageRedirect callback
             * has been registered. (see registerBridgeCallbacks)
             * @param {array} queue The queue array containing the individual
             *                message objects.
             * @returns {array} The array that should replace the previously
             *                  passed queue.
             */
            redirectQueue: function (queue) {
                var i,
                    len,
                    cb,
                    retval,
                    sS;

                // Sanity check
                if (!queue || !queue.length) {
                    return queue;
                }

                cb = bridgeCallbacks.messageRedirect;
                if (cb && cb.enabled) {
                    sS = core.getService("serializer");
                    for (i = 0, len = queue.length; i < len; i += 1) {
                        retval = cb.cbFunction(sS.serialize(queue[i]), queue[i]);
                        if (retval && typeof retval === "object") {
                            queue[i] = retval;
                        } else {
                            queue.splice(i, 1);
                            i -= 1;
                            len = queue.length;
                        }
                    }
                }
                return queue;
            },

            _hasSameOrigin: function (iframe) {
                try {
                    return iframe.document.location.host === document.location.host && iframe.document.location.protocol === document.location.protocol;
                } catch (e) {
                    // to be ignored. Error when iframe from different domain
                    //#ifdef DEBUG
                    //TODO add debug log
                    //#endif
                }
                return false;
            },

            /**
             * Core function which is invoked by the queue service to allow
             * for the addRequestHeaders callback (if registered) to be invoked.
             * (see registerBridgeCallbacks)
             * @returns {array} The array of request headers to be set. Each
             *                  object is of the format:
             *                  {
             *                      name: "header name",
             *                      value: "header value",
             *                      recurring: true
             *                  }
             */
            provideRequestHeaders: function () {
                var headers = null,
                    addHeadersCB = bridgeCallbacks.addRequestHeaders;

                if (addHeadersCB && addHeadersCB.enabled) {
                    headers = addHeadersCB.cbFunction();
                }

                return headers;
            },

            /**
             * Utility function used by core._updateModules.
             * It registers event listners according to module configuration.
             * @name core._registerModuleEvents
             * @function
             * @param {string} moduleName name of the module
             * @param {Array} moduleEvents an array of all module-specific events (from UIC configuration)
             * @param {object} scope DOM element where event will be registered; points either to a main window
             *                 object or to IFrame's content window
             */
            _registerModuleEvents: (function () {

                /**
                 * An instance of core.utils.WeakMap us as a cache for mapping DOM elements with their IDs.
                 * Introduced to reduce number of expensive browserBase.ElementData.prototype.examineID calls.
                 * Object initialization in _registerModuleEvents function
                 * @private
                 * @type {object}
                 */
                var idCache,
                    /**
                     * Helper function that returns the localTop or documentScope object if the
                     * specified prop is "window" or "document" respectively.
                     * @private
                     * @function
                     * @param {string|object} prop
                     * @param {object} localTop
                     * @param {object} documentScope
                     * @returns {string|object} localTop if prop value is "window",
                     *                          documentScope if prop value is "document" else
                     *                          returns the prop value itself
                     */
                    normalizeToObject = function (prop, localTop, documentScope) {
                        if (prop === "window") {
                            return localTop;
                        }
                        if (prop === "document") {
                            return documentScope;
                        }
                        return prop;
                    };

                /**
                 * Helper function for core._registerModuleEvents
                 * It does actual event listeners registration, while the main function managesthe scopes.
                 * @function
                 * @private
                 */
                function _registerModuleEventsOnScope(moduleName, moduleEvents, scope) {
                    var browserBase = core.getService("browserBase"),
                        browser = core.getService("browser"),
                        documentScope = core.utils.getDocument(scope),
                        localTop = core._getLocalTop(),
                        isFrame = core.utils.isIFrameDescendant(scope),
                        frameId,
                        e,
                        i;

                    scope = scope || documentScope;
                    loadUnloadHandler.normalizeModuleEvents(moduleName, moduleEvents, localTop, documentScope);

                    if (isFrame) {
                        frameId = browserBase.ElementData.prototype.examineID(scope).id;
                        // remove one closing ']'
                        if (typeof frameId === "string") {
                            frameId = frameId.slice(0, frameId.length - 1);
                            for (e in events) {
                                if (events.hasOwnProperty(e)) {
                                    for (i = 0; i < events[e].length; i += 1) {
                                        if (moduleName === events[e][i]) {
                                            if (e.indexOf(frameId) !== -1) {
                                                delete events[e];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    core.utils.forEach(moduleEvents, function (eventConfig) {
                        var target = normalizeToObject(eventConfig.target, localTop, documentScope) || documentScope,
                            delegateTarget = normalizeToObject(eventConfig.delegateTarget, localTop, documentScope),
                            token = "";

                        if (eventConfig.recurseFrames !== true && isFrame) {
                            return;
                        }

                        // If the target is a string it is a CSS query selector, specified in the config.
                        if (typeof target === "string") {
                            if (eventConfig.delegateTarget && core.getFlavor() === "jQuery") {
                                token = core._buildToken4delegateTarget(eventConfig.name, target, eventConfig.delegateTarget);

                                if (!events.hasOwnProperty(token)) {
                                    events[token] = [moduleName];
                                    events[token].target = target;
                                    events[token].delegateTarget = delegateTarget;
                                    browser.subscribe(eventConfig.name, target, core._publishEvent, delegateTarget, token);
                                } else {
                                    events[token].push(moduleName);
                                }
                            } else {
                                core.utils.forEach(browser.queryAll(target, scope), function (element) {
                                    var idData = idCache.get(element);
                                    if (!idData) {
                                        idData = browserBase.ElementData.prototype.examineID(element);
                                        idCache.set(element, idData);
                                    }
                                    token = eventConfig.name + "|" + idData.id + idData.type;
                                    // If the token already exists, do nothing
                                    if (core.utils.indexOf(events[token], moduleName) !== -1) {
                                        return;
                                    }
                                    events[token] = events[token] || [];
                                    events[token].push(moduleName);
                                    // Save a reference to the tokens target to be able to unregister it later.
                                    events[token].target = element;
                                    browser.subscribe(eventConfig.name, element, core._publishEvent);
                                });
                            }
                        // Else: The target, specified in the config, is an object or empty
                        // (defaults to document), generate a token for events which bubble up
                        // (to the window or document object).
                        } else {
                            token = core._buildToken4bubbleTarget(eventConfig.name, target, typeof eventConfig.target === "undefined");
                            if (!events.hasOwnProperty(token)) {
                                events[token] = [moduleName];
                                browser.subscribe(eventConfig.name, target, core._publishEvent);
                            } else {
                                /* XXX: Only add if module entry doesn't exist. */
                                if (core.utils.indexOf(events[token], moduleName) === -1) {
                                    events[token].push(moduleName);
                                }
                            }
                        }

                        if (token !== "") {
                            if (typeof target !== "string") {
                                events[token].target = target;
                            }
                        }
                    });
                }

                /**
                 * Helper function for core._registerModuleEvents. Checks load status of iframes.
                 * @function
                 * @private
                 * @returns {boolean} true when given frame is completely loaded; false otherwise
                 */
                function _isFrameLoaded(hIFrame) {
                    var iFrameWindow = core.utils.getIFrameWindow(hIFrame);
                    return (iFrameWindow !== null) &&
                            core._hasSameOrigin(iFrameWindow) &&
                            (iFrameWindow.document !== null) &&
                            iFrameWindow.document.readyState === "complete";
                }

                // actual implementation of core._registerModuleEvents
                function registerModuleEvents(moduleName, moduleEvents, scope) {
                    scope = scope || core._getLocalTop().document;
                    idCache = idCache || new core.utils.WeakMap();

                    _registerModuleEventsOnScope(moduleName, moduleEvents, scope);
                    if (moduleName !== "performance") {
                        var hIFrame = null,
                            hIFrameWindow = null,
                            browserService = core.getService("browser"),
                            cIFrames = browserService.queryAll("iframe, frame", scope),
                            i,
                            iLength;

                        for (i = 0, iLength = cIFrames.length; i < iLength; i += 1) {
                            hIFrame = cIFrames[i];
                            if (isFrameBlacklisted(hIFrame)) {
                                continue;
                            }
                            if (_isFrameLoaded(hIFrame)) {
                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                            }

                            (function (moduleName, moduleEvents, hIFrame) {
                                var hIFrameWindow = null,
                                    _iframeContext = {
                                        moduleName: moduleName,
                                        moduleEvents: moduleEvents,
                                        hIFrame: hIFrame,

                                        _registerModuleEventsDelayed: function () {
                                            var hIFrameWindow = null;

                                            if (!isFrameBlacklisted(hIFrame)) {
                                                hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                                if (core._hasSameOrigin(hIFrameWindow)) {
                                                    core._registerModuleEvents(moduleName, moduleEvents, hIFrameWindow.document);
                                                }
                                            }
                                        }
                                    };

                                core.utils.addEventListener(hIFrame, "load", function () {
                                    _iframeContext._registerModuleEventsDelayed();
                                });

                                if (core.utils.isLegacyIE && _isFrameLoaded(hIFrame)) {
                                    hIFrameWindow = core.utils.getIFrameWindow(hIFrame);
                                    core.utils.addEventListener(hIFrameWindow.document, "readystatechange", function () {
                                        _iframeContext._registerModuleEventsDelayed();
                                    });
                                }

                            }(moduleName, moduleEvents, hIFrame));
                        }
                    }
                }

                registerModuleEvents.clearCache = function () {
                    if (idCache) {
                        idCache.clear();
                        idCache = null;
                    }
                };

                return registerModuleEvents;
            }()), // end of _registerModuleEvents factory


            /**
             * Build the token for an event using the currentTarget of the event
             * (only if the current browser supports currenTarget) Otherwise uses
             * the event.target
             * @param  {Object} event The WebEvent
             * @return {String}       Returns the token as a string, consist of:
             *         eventType | target id target idtype
             */
            _buildToken4currentTarget: function (event) {
                var target = event.nativeEvent ? event.nativeEvent.currentTarget : null,
                    idData = target ? this.getService("browserBase").ElementData.prototype.examineID(target) :
                            {
                                id: event.target.id,
                                type: event.target.idType
                            };
                return event.type + "|" + idData.id + idData.type;
            },

            /**
             * Build the token for delegate targets
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | target | delegateTarget
             */
            _buildToken4delegateTarget: function (eventType, target, delegateTarget) {
                return eventType + "|" + target + "|" + delegateTarget;
            },

            /**
             * Build the token for bubble targets (either window or document)
             * @param  {String} eventType The event.type property of the WebEvent
             * @param  {Object} target    The target or currentTarget of the event.
             * @param  {Object} delegateTarget    The delegated target of the event.
             * @return {String}           Returns the token as a string, consist of:
             *            eventType | null-2 | window or document
             */
            _buildToken4bubbleTarget: function (eventType, target, checkIframe, delegateTarget) {
                var localTop = core._getLocalTop(),
                    localWindow,
                    browserService = core.getService("browser"),
                    _getIframeElement = function (documentScope) {
                        var retVal = null;

                        if (core._hasSameOrigin(localWindow.parent)) {
                            core.utils.forEach(browserService.queryAll("iframe, frame", localWindow.parent.document), function (iframe) {
                                var iFrameWindow = null;

                                if (!isFrameBlacklisted(iframe)) {
                                    iFrameWindow = core.utils.getIFrameWindow(iframe);
                                    if (core._hasSameOrigin(iFrameWindow) && iFrameWindow.document === documentScope) {
                                        retVal = iframe;
                                    }
                                }
                            });
                        }
                        return retVal;
                    },
                    documentScope = core.utils.getDocument(target),
                    browserBase = this.getService("browserBase"),
                    iframeElement = null,
                    tmpTarget,
                    retVal = eventType,
                    idData;

                if (documentScope) {
                    localWindow = documentScope.defaultView || documentScope.parentWindow;
                }

                if (target === window || target === window.window) {
                    retVal += "|null-2|window";
                } else {
                    if (checkIframe && localWindow && core._hasSameOrigin(localWindow.parent) && typeof documentScope !== "undefined" && localTop.document !== documentScope) {
                        iframeElement = _getIframeElement(documentScope);
                        if (iframeElement) {
                            tmpTarget = browserBase.ElementData.prototype.examineID(iframeElement);
                            retVal += "|" + tmpTarget.xPath + "-2";
                        }
                    } else if (delegateTarget && delegateTarget !== document && core.getFlavor() === "jQuery") {
                        // NOTE: elegateTarget !== document  --- because simple jQuery.on has delegateTarget set to document
                        // for event defined without target e.g. { name: "click", recurseFrame: true }
                        retVal += "|null-2|" + core.utils.getTagName(target) + "|" + core.utils.getTagName(delegateTarget);
                    } else {
                        retVal += "|null-2|document";
                    }
                }

                return retVal;
            },

            /**
             * Event handler for when configuration gets updated.
             * @returns {void}
             * @private
             */
            _reinitConfig: function () {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.
                core._updateModules();
            },

            /**
             * Iterates over each module delivers the event object if the module
             * is interested in that event.
             * @param {Event} event An event object published by the browser service.
             * @returns {void}
             * @private
             */
            _publishEvent: function (event) {

                // NOTE: Don't use "this" in this method, only use "core" to preserve context.

                var moduleName = null,
                    module = null,
                    // generate the explicit token for the element which received the event
                    // if event is delegated it will have event.data set to the token
                    token = (event.delegateTarget && event.data) ? event.data : core._buildToken4currentTarget(event),
                    modules = null,
                    i,
                    len,
                    target,
                    modEvent = null,
                    canIgnore = false,
                    canPublish = false,
                    coreConfig = core.getCoreConfig(),
                    browserService = core.getService("browser"),
                    delegateTarget = event.delegateTarget || null;

                // Reset the inactivity timer
                if (inactivityTimerId) {
                    clearTimeout(inactivityTimerId);
                }
                // Set inactivity timeout with default of 10 minutes.
                inactivityTimerId = setTimeout(inactivityTimeoutHandler, core.utils.getValue(coreConfig, "inactivityTimeout", 600000));

                // ignore native browser 'load' events
                if ((event.type === "load" || event.type === "pageshow") && !event.nativeEvent.customLoad) {
                    return;
                }

                // IE only: ignore 'beforeunload' fired by link placed in blacklist of excluded links
                if (core.utils.isIE) {
                    if (event.type === "click") {
                        lastClickedElement = event.target.element;
                    }
                    if (event.type === "beforeunload") {
                        canIgnore = false;
                        core.utils.forEach(coreConfig.ieExcludedLinks, function (selector) {
                            var i,
                                len,
                                el = browserService.queryAll(selector);

                            for (i = 0, len = el ? el.length : 0; i < len; i += 1) {
                                if (typeof el[i] !== undefined && el[i] === lastClickedElement) {
                                    // Last clicked element was in the blacklist. Set the ignore flag.
                                    canIgnore = true;
                                    return;
                                }
                            }
                        });

                        if (canIgnore) {
                            // The beforeunload can be ignored.
                            return;
                        }
                    }
                }

                // if an unload event is triggered update the core's internal state to "unloading"
                if (loadUnloadHandler.isUnload(event)) {
                    state = "unloading";
                }

                // ignore native browser 'change' events on IE<9/W3C for radio buttons and checkboxes
                if (event.type === "change" && core.utils.isLegacyIE && core.getFlavor() === "w3c" &&
                        (event.target.element.type === "checkbox" || event.target.element.type === "radio")) {
                    return;
                }

                // use 'propertychange' event in IE<9 to simulate 'change' event on radio and checkbox
                if (event.type === "propertychange") {
                    if (event.nativeEvent.propertyName === "checked" && (event.target.element.type === "checkbox" || (event.target.element.type === "radio" && event.target.element.checked))) {
                        event.type = "change";
                        event.target.type = "INPUT";
                    } else {
                        return;
                    }
                }

                // No module has registered the event for the currentTarget,
                // build token for bubble target (document or window)
                if (!events.hasOwnProperty(token)) {
                    if (event.hasOwnProperty("nativeEvent")) {
                        target = event.nativeEvent.currentTarget || event.nativeEvent.target;
                    }
                    token = core._buildToken4bubbleTarget(event.type, target, true, delegateTarget);
                }

                if (events.hasOwnProperty(token)) {
                    modules = events[token];
                    for (i = 0, len = modules.length; i < len; i += 1) {
                        moduleName = modules[i];
                        module = core.getModule(moduleName);
                        modEvent = core.utils.mixin({}, event);
                        if (module && core.isStarted(moduleName) && typeof module.onevent === "function") {
                            canPublish = loadUnloadHandler.canPublish(moduleName, modEvent);
                            if (canPublish) {
                                module.onevent(modEvent);
                            }
                        }
                    }
                }

                if (modEvent && modEvent.type === "unload" && canPublish) {
                    core.destroy();
                }

            },

            _getLocalTop: function () {
                // Return window.window instead of window due to an IE quirk where (window == top) is true but (window === top) is false
                // In such cases, (window.window == top) is true and so is (window.window === top)  Hence window.window is more reliable
                // to compare to see if the library is included in the top window.
                return window.window;
            },

            //---------------------------------------------------------------------
            // Module Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a module creator with TLT.
             * @param {String} moduleName The name of the module that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the module.
             * @returns {void}
             */
            addModule: function (moduleName, creator) {

                if (modules.hasOwnProperty(moduleName)) {
                    throw new Error("Attempting to add duplicate module '" + moduleName +
                            "' on TLT.");
                }

                modules[moduleName] = {
                    creator: creator,
                    instance: null,
                    context: null,
                    messages: []
                };

                // If the core is initialized, then this module has been dynamically loaded. Start it.
                if (this.isInitialized()) {
                    this.start(moduleName);
                }
            },

            /**
             * Returns the module instance of the given module.
             * @param {String} moduleName The name of the module to retrieve.
             * @returns {Object} The module instance if it exists, null otherwise.
             */
            getModule: function (moduleName) {
                if (modules[moduleName] && modules[moduleName].instance) {
                    return modules[moduleName].instance;
                }
                return null;
            },

            /**
             * Unregisters a module and stops and destroys its instance.
             * @param {String} moduleName The name of the module to remove.
             * @returns {void}
             */
            removeModule: function (moduleName) {

                this.stop(moduleName);
                delete modules[moduleName];
            },

            /**
             * Determines if a module is started by looking for the instance.
             * @param {String} moduleName The name of the module to check.
             * @returns {void}
             */
            isStarted: function (moduleName) {
                return modules.hasOwnProperty(moduleName) && modules[moduleName].instance !== null;
            },

            /**
             * Creates a new module instance and calls it's init() method.
             * @param {String} moduleName The name of the module to start.
             * @returns {void}
             */
            start: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                if (!modules.hasOwnProperty(moduleName)) {
                    throw new Error("Attempting to start nonexistent module '" + moduleName +
                            "' on TLT.");
                }

                // Only continue if the module data exists and there's not already an instance
                if (moduleData && moduleData.instance === null) {

                    // create the context and instance
                    moduleData.context = new TLT.ModuleContext(moduleName, this);
                    instance = moduleData.instance = moduleData.creator(moduleData.context);

                    // allow module to initialize itself
                    if (typeof instance.init === "function") {
                        instance.init();
                    }

                }
            },

            /**
             * Starts all registered modules, creating an instance and calling their
             * init() methods.
             * @returns {void}
             */
            startAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.start(moduleName);
                    }
                }
            },

            /**
             * Stops a module, calls it's destroy() method, and deletes the instance.
             * @param {String} moduleName The name of the module to stop.
             * @returns {void}
             */
            stop: function (moduleName) {

                var moduleData = modules[moduleName],
                    instance = null;

                // Only continue if the module instance exists
                if (moduleData && moduleData.instance !== null) {

                    instance = moduleData.instance;

                    // allow module to clean up after itself
                    if (typeof instance.destroy === "function") {
                        instance.destroy();
                    }

                    moduleData.instance = moduleData.context = null;

                }
            },

            /**
             * Stops all registered modules, calling their destroy() methods,
             * and removing their instances.
             * @returns {void}
             */
            stopAll: function () {

                var moduleName = null;

                for (moduleName in modules) {
                    if (modules.hasOwnProperty(moduleName)) {
                        this.stop(moduleName);
                    }
                }
            },

            //---------------------------------------------------------------------
            // Service Registration and Lifecycle
            //---------------------------------------------------------------------

            /**
             * Registers a service creator with TLT.
             * @param {String} serviceName The name of the service that is created using
             *      the creator.
             * @param {Function} creator The function to call to create the service.
             * @returns {void}
             */
            addService: function (serviceName, creator) {

                if (services.hasOwnProperty(serviceName)) {
                    throw new Error("Attempting to add duplicate service '" + serviceName +
                            "' on TLT.");
                }

                services[serviceName] = {
                    creator: creator,
                    instance: null
                };
            },

            /**
             * Retrieves a service instance, creating it if one doesn't already exist.
             * @param {String} serviceName The name of the service to retrieve.
             * @returns {Object} The service object as returned from the service
             *      creator or null if the service doesn't exist.
             */
            getService: function (serviceName) {
               /* if (!services.hasOwnProperty(serviceName)) {
                    throw new Error("Attempting to request non-existent service '" + serviceName +
                            "' on TLT.");
                }*/
                if (services.hasOwnProperty(serviceName)) {
                    if (!services[serviceName].instance) {
                        // If you want to have a separate ServiceContext, pass it here instead of "this"
                        try {
                            services[serviceName].instance = services[serviceName].creator(this);
                            if (typeof services[serviceName].instance.init === "function") {
                                services[serviceName].instance.init();
                            }
                        } catch (e) {
                            // shut the library down if jQuery or sizzle is not found / not supported
                            if (e.code && (e.code === "JQUERYNOTSUPPORTED" || e.code === "NOQUERYSELECTOR")) {
                                // TODO: reset service instance to null. In light of this, does explicit init for services make sense?
                                // Services should implicitly initialize when created and if any problems are encountered then throw appropriate exception.
                                return null;
                            }
                            // otherwise rethrow the error
                            throw e;
                        }
                        if (typeof services[serviceName].instance.getServiceName !== "function") {
                            services[serviceName].instance.getServiceName = function () {
                                return serviceName;
                            };
                        }
                    }
                    return services[serviceName].instance;
                }
                return null;
            },

            /**
             * Unregisters a service and destroys its instance.
             * @param {String} serviceName The name of the service to remove.
             * @returns {void}
             */
            removeService: function (serviceName) {
                delete services[serviceName];
            },

            //---------------------------------------------------------------------
            // Intermodule Communication
            //---------------------------------------------------------------------

            /**
             * Broadcasts a message throughout the system to all modules who are
             * interested.
             * @param {Object} message An object containing at least a type property
             *      indicating the message type.
             * @returns {void}
             */
            broadcast: function (message) {
                var i = 0,
                    len = 0,
                    prop = null,
                    module = null;

                if (message && typeof message === "object") {

                    if (!message.hasOwnProperty("type")) {
                        throw new Error("Message is missing property 'type'.");
                    }

                    for (prop in modules) {
                        if (modules.hasOwnProperty(prop)) {
                            module = modules[prop];

                            if (core.utils.indexOf(module.messages, message.type) > -1) {
                                if (typeof module.instance.onmessage === "function") {
                                    module.instance.onmessage(message);
                                }
                            }
                        }
                    }
                }
            },

            /**
             * Instructs a module to listen for a particular type of message.
             * @param {String} moduleName The module that's interested in the message.
             * @param {String} messageType The type of message to listen for.
             * @returns {void}
             */
            listen: function (moduleName, messageType) {
                var module = null;

                if (this.isStarted(moduleName)) {
                    module = modules[moduleName];

                    if (core.utils.indexOf(module.messages, messageType) === -1) {
                        module.messages.push(messageType);
                    }
                }
            },
            /**
             * Returns all services
             */
            _getServices: function () {
                return services;
            },
            /**
             * Stops UIC and throws an error.
             * @function
             * @throws {UICError}
             */
            fail: function (message, failcode, skipEvents) {
                message = "UIC FAILED. " + message;
                try {
                    core.destroy(!!skipEvents);
                } finally {
                    core.utils.clog(message);
                    throw new core.UICError(message, failcode);
                }
            },

            /**
             * @constructor
             */
            UICError: (function () {
                function UICError(message, errorCode) {
                    this.message = message;
                    this.code = errorCode;
                }
                UICError.prototype = new Error();
                UICError.prototype.name = "UICError";
                UICError.prototype.constructor = UICError;
                return UICError;
            }()),


            /**
             * Return the name of UIC flavor ("w3c" or "jQuery")
             * @function
             */
            getFlavor: function () {
                // TODO: Use the existing browserService method here
                return "w3c";
            }
        };

    /**
     * Inactivity timeout handler function. When the timer expires,
     * log an exception message indicating the timeout and shutdown.
     * @private
     */
    inactivityTimeoutHandler = function () {
        core.logExceptionEvent("Inactivity timeout.");
        core.destroy();
    }

    /**
     * Actual init function called from TLT.init when the DOM is ready.
     * @private
     * @see TLT.init
     */
    _init = function (config, callback) {
        var configService,
            event,
            webEvent,
            baseBrowser,
            browserService;

        if (initialized) {
            core.utils.clog("TLT.init() called more than once. Ignoring.");
            return;
        }

        // Do not initialize if replay is enabled.
        if (TLT && TLT.replay) {
            return;
        }

        configService = core.getService("config");
        configService.updateConfig(config);

        if (!core._updateModules()) {
            if (state !== "destroyed") {
                core.destroy();
            }
            return;
        }

        if (configService.subscribe) {
            configService.subscribe("configupdated", core._reinitConfig);
        }

        initialized = true;
        state = "loaded";

        //generate fake load event to send for modules
        event = {
            type: 'load',
            target: window.window,
            srcElement: window.window,
            currentTarget: window.window,
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            timeStamp: +new Date(),
            customLoad: true
        };

        baseBrowser = core.getService("browserBase");
        webEvent = new baseBrowser.WebEvent(event);
        core._publishEvent(webEvent);

        if (typeof _callback === "function") {
            // Protect against unexpected exceptions since _callback is 3rd party code.
            try {
                _callback("initialized");
            } catch (e) {
                // Do nothing!
            }
        }
    };

    // Add methods that passthrough to services
    (function () {

        var name = null,
            i,
            len;

        for (name in servicePassthroughs) {
            if (servicePassthroughs.hasOwnProperty(name)) {
                for (i = 0, len = servicePassthroughs[name].length; i < len; i += 1) {
                    (function (serviceName, methodName) {
                        core[methodName] = function () {
                            var service = this.getService(serviceName);
                            if (service) {
                                return service[methodName].apply(service, arguments);
                            }
                        };
                    }(name, servicePassthroughs[name][i]));

                }
            }
        }

    }());

    return core;
}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines utility functions available to all modules via context object or as TLT.utils
 * @exports TLT.utils
 */

/*global TLT, window*/
/*jshint loopfunc:true*/

(function () {

    "use strict";

    var ua = window.navigator.userAgent.toLowerCase(),

        _isIE = (ua.indexOf("msie") !== -1),

        _isLegacyIE = (function () {
            // W3 Navigation timing spec. supported from IE 9 onwards.
            var isNavTimingSupported = !!window.performance;
            return (_isIE && (!isNavTimingSupported || document.documentMode < 9));
        }()),

        _isAndroid = (ua.indexOf("android") !== -1),

        _isiOS = /(ipad|iphone|ipod)/.test(ua),

        tltUniqueIndex = 1,

        utils = {
            /**
             * Indicates if browser is IE.
             */
            isIE: _isIE,

            /**
             * Indicates if browser is IE<9 or IE 9+ running in
             * compatibility mode.
             */
            isLegacyIE: _isLegacyIE,

            /**
             * Indicates if the browser is based on an Android platform device.
             */
            isAndroid: _isAndroid,

            /**
             * Indicates if the browser is based on an iOS platform device.
             */
            isiOS: _isiOS,

            /**
             * Checks whether given parameter is null or undefined
             * @param {*} obj Any value
             * @returns {boolean} True if obj is null or undefined; false otherwise
             */
            isUndefOrNull: function (obj) {
                return typeof obj === "undefined" || obj === null;
            },

            /**
             * Returns a unique serial number
             * @returns {int} A number that can be used as a unique identifier.
             */
            getSerialNumber: function () {
                var id;

                id = tltUniqueIndex;
                tltUniqueIndex += 1;

                return id;
            },

            /**
             * Used to test and get value from an object.
             * @private
             * @function
             * @name core.utils.getValue
             * @param {object} parentObj An object you want to get a value from.
             * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
             * @param {object|String|Number} [defaultValue] The default value to be returned if the property is not found.
             * @return {object} If object is found, if not then default value will be returned. If the default value is
             * not defined then null will be returned.
             */
            getValue: function (parentObj, propertyAsStr, defaultValue) {
                var i,
                    len,
                    properties;

                defaultValue = defaultValue || null;

                // Sanity check
                if (!parentObj || typeof parentObj !== "object" || typeof propertyAsStr !== "string") {
                    return defaultValue;
                }

                properties = propertyAsStr.split(".");
                for (i = 0, len = properties.length; i < len; i += 1) {
                    if (this.isUndefOrNull(parentObj) || typeof parentObj[properties[i]] === "undefined") {
                        return defaultValue;
                    }
                    parentObj = parentObj[properties[i]];
                }
                return parentObj;
            },

            /**
             * Helper function to find an item in an array.
             * @param {Array} array The array to search.
             * @param {String} item The item to search for.
             * @returns {int} The index of the item if found, -1 if not.
             */
            indexOf: function (array, item) {
                var i,
                    len;

                if (array && array instanceof Array) {
                    for (i = 0, len = array.length; i < len; i += 1) {
                        if (array[i] === item) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            /**
             * Invokes callback for each element of an array.
             * @param {Array} array The array (or any indexable object) to walk through
             * @param {function} callback Callback function
             * @param {object} [context] context object; if not provided global object will be considered
             */
            forEach: function (array, callback, context) {
                var i,
                    len;

                // Sanity checks
                if (!array || !array.length || !callback || !callback.call) {
                    return;
                }

                for (i = 0, len = array.length; i < len; i += 1) {
                    callback.call(context, array[i], i, array);
                }
            },

            /**
             * Returns true if callback returns true at least once. Callback is
             * called for each array element unless it reaches end of array or
             * returns true.
             * @param {object} array An Array or any indexable object to walk through
             * @param {function} callback A callback function
             * @returns {boolean} True if callback returned true at least once; false otherwise
             */
            some: function (array, callback) {
                var i,
                    len,
                    val = false;

                for (i = 0, len = array.length; i < len; i += 1) {
                    val = callback(array[i], i, array);
                    if (val) {
                        return val;
                    }
                }
                return val;
            },

            /**
             * Converts an arguments object into an array. This is used to augment
             * the arguments passed to the TLT methods used by the Module Context.
             * @param {Arguments} items An array-like collection.
             * @return {Array} An array containing the same items as the collection.
             */
            convertToArray: function (items) {
                var i = 0,
                    len = items.length,
                    result = [];

                while (i < len) {
                    result.push(items[i]);
                    i += 1;
                }

                return result;
            },

            mixin: function (dst) {
                var prop,
                    src,
                    srcId,
                    len;

                for (srcId = 1, len = arguments.length; srcId < len; srcId += 1) {
                    src = arguments[srcId];
                    for (prop in src) {
                        if (Object.prototype.hasOwnProperty.call(src, prop)) {
                            dst[prop] = src[prop];
                        }
                    }
                }
                return dst;
            },

            extend: function (deep, target, src) {
                var prop = "";

                for (prop in src) {
                    if (Object.prototype.hasOwnProperty.call(src, prop)) {
                        if (deep && Object.prototype.toString.call(src[prop]) === "[object Object]") {
                            if (typeof target[prop] === "undefined") {
                                target[prop] = {};
                            }
                            utils.extend(deep, target[prop], src[prop]);
                        } else {
                            target[prop] = src[prop];
                        }
                    }
                }
                return target;
            },

            /**
             * Makes copy of an object.
             * @function
             * @name core.utils.clone
             * @param {object} obj A object that will be cloned.
             * @return {object} Object cloned.
             */
            clone: function (obj) {
                var copy,
                    attr;

                if (null === obj || "object" !== typeof obj) {
                    return obj;
                }

                if (obj instanceof Object) {
                    copy = (Object.prototype.toString.call(obj) === "[object Array]") ? [] : {};
                    for (attr in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, attr)) {
                            copy[attr] = utils.clone(obj[attr]);
                        }
                    }
                    return copy;
                }
            },

            /**
             *
             */
            createObject: (function () {
                var fn = null,
                    F = null;
                if (typeof Object.create === "function") {
                    fn = Object.create;
                } else {
                    F = function () {};
                    fn = function (o) {
                        if (typeof o !== "object" && typeof o !== "function") {
                            throw new TypeError("Object prototype need to be an object!");
                        }
                        F.prototype = o;
                        return new F();
                    };
                }
                return fn;
            }()),

            /**
             * Method access the object element based on a string. By default it searches starting from window object.
             * @function
             * @example core.utils.access("document.getElementById");
             * @example core.utils.access("address.city", person);
             * @param {string} path Path to object element. Currently on dot separators are supported (no [] notation support)
             * @param {object} [rootObj=window] Root object where there search starts. window by default
             * @return {*} Object element or undefined if the path is not valid
             */
            access: function (path, rootObj) {
                var obj = rootObj || window,
                    arr,
                    i,
                    len;

                if (typeof path !== "string" || (typeof obj !== "object" && obj !== null)) {
                    return;
                }
                arr = path.split(".");
                for (i = 0, len = arr.length; i < len; i += 1) {
                    if (i === 0 && arr[i] === "window") {
                        continue;
                    }
                    if (!Object.prototype.hasOwnProperty.call(obj, arr[i])) {
                        return;
                    }
                    obj = obj[arr[i]];
                    if (i < (len - 1) && !(obj instanceof Object)) {
                        return;
                    }
                }
                return obj;
            },

            /**
             * Checks if a given character is numeric.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the given character is a number.
             */
            isNumeric: function (character) {
                return !isNaN(character + 1 - 1);
            },

            /**
             * Checks if a given character is uppercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is uppercase.
             *                        Otherwise false.
             */
            isUpperCase: function (character) {
                return character === character.toUpperCase() &&
                        character !== character.toLowerCase();
            },

            /**
             * Checks if a given character is lowercase.
             * @param  {String}  character The character to test.
             * @return {Boolean}      Returns true if the character is lowercase.
             *                        Otherwise false.
             */
            isLowerCase: function (character) {
                return character === character.toLowerCase() &&
                        character !== character.toUpperCase();
            },

            getDocument: function (node) {
                if (node.nodeType !== 9) {
                    return (!utils.isUndefOrNull(node.ownerDocument)) ? (node.ownerDocument) : (node.document);
                }
                return node;
            },

            getWindow: function (node) {
                if (node.self !== node) {
                    var ownerDocument = utils.getDocument(node);
                    return (!utils.isUndefOrNull(ownerDocument.defaultView)) ? (ownerDocument.defaultView) : (ownerDocument.parentWindow);
                }
                return node;
            },

            /**
             * Given a HTML frame element, returns the window object of the frame. Tries the contentWindow property
             * first. If contentWindow is not accessible, tries the contentDocument.parentWindow property instead.
             * @param {Object} iFrameElement The HTML frame element object.
             * @return {Object} Returns the window object of the frame element or null.
             */
            getIFrameWindow: function (iFrameElement) {
                var contentWindow = null;

                if (!iFrameElement) {
                    return contentWindow;
                }

                try {
                    contentWindow = iFrameElement.contentWindow ||
                        (iFrameElement.contentDocument ? iFrameElement.contentDocument.parentWindow : null);
                } catch (e) {
                    // Do nothing.
                }

                return contentWindow;
            },

            getTagName: function (node) {
                if (node === document) {
                    return "document";
                }
                if (node === window || node === window.window) {
                    return "window";
                }
                if (typeof node === "string") {
                    return node.toLowerCase();
                }
                if (typeof node === "object" && !utils.isUndefOrNull(node) && typeof node.tagName === "string") {
                    return node.tagName.toLowerCase();
                }
                return "";
            },

            /**
             * Returns true if given node is element from a frame
             * @private
             * @param {Element} node DOM element
             * @return {boolean} true if input element is element from a frame; false otherwise
             */
            isIFrameDescendant: function (node) {
                /*jshint eqeqeq:false, eqnull: false */
                /* The != operator below is on purpose due to legacy IE issues, where:
                   window === top returns false, but window == top returns true */
                return utils.getWindow(node) != TLT._getLocalTop();
            },

            /**
             * Takes the orientation in degrees and returns the orientation mode as a
             * text string. 0, 180 and 360 correspond to portrait mode while 90, -90
             * and 270 correspond to landscape.
             * @function
             * @name core.utils.getOrientationMode
             * @param {number} orientation A normalized orientation value such as
             *          0, -90, 90, 180, 270, 360.
             * @return {string} "PORTRAIT" or "LANDSCAPE" for known orientation values.
             * "UNKNOWN" for unrecognized values. "INVALID" in case of error.
             */
            getOrientationMode: function (orientation) {
                var mode = "INVALID";

                if (typeof orientation !== "number") {
                    return mode;
                }

                switch (orientation) {
                case 0:
                case 180:
                case 360:
                    mode = "PORTRAIT";
                    break;
                case 90:
                case -90:
                case 270:
                    mode = "LANDSCAPE";
                    break;
                default:
                    mode = "UNKNOWN";
                    break;
                }

                return mode;
            },

            clog: (function (window) {
                // Console logging should be only enabled in debug builds.
                if (typeof window.console === "object" && typeof window.console.log === "function" && typeof window.console.log.apply === "function") {
                    var c = window.console;
                    return function () {
                        c.log.apply(c, arguments);
                    };
                }
                return function () {
                    // Do nothing!
                };
            }(window)),

            /**
             * Trims any whitespace and returns the trimmed string.
             * @function
             * @name core.utils.trim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            trim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+|\s+$/g, "");
            },

            /**
             * Trims any whitespace at the beginning of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.ltrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            ltrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/^\s+/, "");
            },

            /**
             * Trims any whitespace at the end of the string and returns the
             * trimmed string.
             * @function
             * @name core.utils.rtrim
             * @param {string} str The string to be trimmed.
             * @return {string} The trimmed string.
             */
            rtrim: function (str) {
                // Sanity check.
                if (!str || !str.toString) {
                    return str;
                }
                return str.toString().replace(/\s+$/, "");
            },

            /**
             * Finds and returns the named cookie's value.
             * @function
             * @name core.utils.getCookieValue
             * @param {string} cookieName The name of the cookie.
             * @param {string} [cookieString] Optional cookie string in which to search for cookieName.
             * If none is specified, then document.cookie is used by default.
             * @return {string} The cookie value if a match is found or null.
             */
            getCookieValue: function (cookieName, cookieString) {
                var i,
                    len,
                    cookie,
                    cookies,
                    cookieValue = null,
                    cookieNameLen;

                try {
                    cookieString = cookieString || document.cookie;

                    // Sanity check.
                    if (!cookieName || !cookieName.toString) {
                        return null;
                    }

                    // Append an '=' to the cookie name
                    cookieName += "=";
                    cookieNameLen = cookieName.length;

                    // Get the individual cookies into an array and look for a match
                    cookies = cookieString.split(';');
                    for (i = 0, len = cookies.length; i < len; i += 1) {
                        cookie = cookies[i];
                        cookie = utils.ltrim(cookie);

                        // Check if cookieName matches the current cookie prefix.
                        if (cookie.indexOf(cookieName) === 0) {
                            // Match found! Get the value (i.e. RHS of "=" sign)
                            cookieValue = cookie.substring(cookieNameLen, cookie.length);
                            break;
                        }
                    }
                } catch (e) {
                    cookieValue = null;
                }

                return cookieValue;
            },

            /**
             * Finds and returns the query parameter's value.
             * @function
             * @name core.utils.getQueryStringValue
             * @param {string} paramName The name of the query parameter.
             * @param {string} [queryDelim] The query string delimiter. Either ";" or "&"
             * @param {string} [queryString] Optional query string in which to search for the query parameter.
             * If none is specified, then document.location.search is used by default.
             * @return {string} The query parameter value if a match is found or null.
             */
            getQueryStringValue: function (paramName, queryDelim, queryString) {
                var i,
                    j,
                    queryStringLen,
                    paramValue = null,
                    valueStartIndex;

                try {
                    queryString = queryString || window.location.search;
                    queryStringLen = queryString.length;

                    // Sanity check.
                    if (!paramName || !paramName.toString || !queryStringLen) {
                        return null;
                    }

                    // Default delimiter is &
                    queryDelim = queryDelim || "&";
                    // Normalize for easy searching by replacing initial '?' with the delimiter
                    queryString = queryDelim + queryString.substring(1);
                    // Modify the parameter name to prefix the delimiter and append an '='
                    paramName = queryDelim + paramName + "=";

                    i = queryString.indexOf(paramName);
                    if (i !== -1) {
                        valueStartIndex = i + paramName.length;
                        // Match found! Get the value (i.e. RHS of "=" sign upto the delim or end of string)
                        j = queryString.indexOf(queryDelim, valueStartIndex);
                        if (j === -1) {
                            j = queryStringLen;
                        }
                        paramValue = decodeURIComponent(queryString.substring(valueStartIndex, j));
                    }
                } catch (e) {
                    // Do nothing!
                }

                return paramValue;
            },

            /**
             * Quick wrapper for addEventL:istener/attachEvent. Mainly to be used for core, before UIC is fully
             * initialized
             * @function
             * @name core.util.addEventListener
             */
            addEventListener: (function () {
                if (window.addEventListener) {
                    return function (element, eventName, listener) {
                        element.addEventListener(eventName, listener, false);
                    };
                }
                return function (element, eventName, listener) {
                    element.attachEvent("on" + eventName, listener);
                };
            }()),

            /**
             * Returns the index of the rule that is matched by the target object.
             * @function
             * @name core.utils.matchTarget
             * @param {Array} rules An array of match rules containing objects such as
             * {id, idType} or { { regex }, idType } or a string representing "CSS Selectors"
             * @param {Object} target  The normalized target object of the message.
             * @return {int} Returns the index of the matching rule. If none of the rules match then returns -1.
             */
            matchTarget: function (rules, target) {
                var i,
                    j,
                    matchIndex = -1,
                    qr,
                    qrLen,
                    qrTarget,
                    regex,
                    len,
                    rule;

                // Sanity check
                if (!rules || !target) {
                    return matchIndex;
                }

                if (!this.browserService || !this.browserBaseService) {
                    this.browserService = TLT.getService("browser");
                    this.browserBaseService = TLT.getService("browserBase");
                }

                for (i = 0, len = rules.length; i < len && matchIndex === -1; i += 1) {
                    rule = rules[i];

                    // Check if rule is a selector string.
                    if (typeof rule === "string") {
                        qr = this.browserService.queryAll(rule);
                        for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                            if (qr[j]) {
                                qrTarget = this.browserBaseService.ElementData.prototype.examineID(qr[j]);
                                if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                                    matchIndex = i;
                                    break;
                                }
                            }
                        }
                    } else if (rule.id && rule.idType && target.idType.toString() === rule.idType.toString()) {
                        // Note: idType provided by wizard is a string so convert both to strings before comparing.

                        // An id in the rules list could be a direct match, in which case it will be a string OR
                        // it could be a regular expression in which case it would be an object like this:
                        // {regex: ".+private$", flags: "i"}
                        switch (typeof rule.id) {
                        case "string":
                            if (rule.id === target.id) {
                                matchIndex = i;
                            }
                            break;
                        case "object":
                            regex = new RegExp(rule.id.regex, rule.id.flags);
                            if (regex.test(target.id)) {
                                matchIndex = i;
                            }
                            break;
                        }
                    }
                }
                return matchIndex;
            },

            /**
             * Basic WeakMap implementation - a map which can be indexed with objects.
             * In comparison to the original API 'delete' method has been replaced with 'remove'
             * due to compatibility with legacy IE
             * @constructor
             * @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/WeakMap
             */
            WeakMap: (function () {
                function index(data, key) {
                    var i,
                        len;
                    data = data || [];
                    for (i = 0, len = data.length; i < len; i += 1) {
                        if (data[i][0] === key) {
                            return i;
                        }
                    }
                    return -1;
                }
                return function () {
                    var data = [];
                    this.set = function (key, val) {
                        var idx = index(data, key);
                        data[idx > -1 ? idx : data.length] = [key, val];
                    };
                    this.get = function (key) {
                        var arr = data[index(data, key)];
                        return (arr ? arr[1] : undefined);
                    };
                    this.clear = function () {
                        data = [];
                    };
                    this.has = function (key) {
                        return (index(data, key) >= 0);
                    };
                    this.remove = function (key) {
                        var idx = index(data, key);
                        if (idx >= 0) {
                            data.splice(idx, 1);
                        }
                    };
                    this["delete"] = this.remove;
                };
            }())
        };


    if (typeof TLT === "undefined" || !TLT) {
        window.TLT = {};
    }

    TLT.utils = utils;

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines a simple event target interface that can be inherited
 *      from by other parts of the system.
 * @exports TLT.EventTarget
 */
/*global TLT*/

(function () {

    "use strict";

    /**
     * Abstract type that implements basic event handling capabilities.
     * Other types may inherit from this in order to provide custom
     * events.
     * @constructor
     */
    TLT.EventTarget = function () {

        /**
         * Holds all registered event handlers. Each property represents
         * a specific event, each property value is an array containing
         * the event handlers for that event.
         * @type Object
         */
        this._handlers = {};

    };

    TLT.EventTarget.prototype = {

        /**
         * Restores the constructor to the correct value.
         * @private
         */
        constructor: TLT.EventTarget,

        /**
         * Publishes an event with the given name, which causes all
         * event handlers for that event to be called.
         * @param {String} name The name of the event to publish.
         * @param {Variant} [data] The data to provide for the event.
         * @returns {void}
         */
        publish: function (name, data) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name],
                event = {
                    type: name,
                    data: data
                };

            if (typeof handlers !== "undefined") {
                for (len = handlers.length; i < len; i += 1) {
                    handlers[i](event);
                }
            }

        },

        /**
         * Registers an event handler for the given event.
         * @param {String} name The name of the event to subscribe to.
         * @param {Function} handler The function to call when the event occurs.
         * @returns {void}
         */
        subscribe: function (name, handler) {

            if (!this._handlers.hasOwnProperty(name)) {
                this._handlers[name] = [];
            }

            if (typeof handler !== "function") {
                throw new Error("Event handler for '" + name + "' isn't a function.");
            }

            this._handlers[name].push(handler);
        },

        /**
         * Unregisters an event handler for the given event.
         * @param {String} name The name of the event to unsubscribe from.
         * @param {Function} handler The event handler to remove.
         * @returns {void}
         */
        unsubscribe: function (name, handler) {

            var i = 0,
                len = 0,
                handlers = this._handlers[name];

            if (handlers) {
                for (len = handlers.length; i < len; i += 1) {
                    if (handlers[i] === handler) {
                        handlers.splice(i, 1);
                        return;
                    }
                }
            }
        }

    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview Defines ModuleContext, which is used by all modules.
 * @exports TLT.ModuleContext
 */

/*global TLT*/
/*jshint loopfunc:true*/

/**
 * A layer that abstracts core functionality for each modules. Modules interact
 * with a ModuleContext object to ensure that they're not doing anything
 * they're not allowed to do.
 * @class
 * @param {String} moduleName The name of the module that will use this context.
 * @param {TLT} core The core object. This must be passed in to enable easier
 *        testing.
 */
TLT.ModuleContext = (function () {

    "use strict";

    /**
     * Methods to be exposed from the Core to ModuleContext. ModuleContext
     * simply passes through these methods to the Core. By listing the
     * methods here, the ModuleContext object can be dynamically created
     * to keep the code as small as possible. You can easily add new methods
     * to ModuleContext by adding them to this array. Just make sure the
     * method also exists on TLT and that the first argument for the method
     * on TLT is always the module name.
     *
     * If the method name on ModuleContext is different than on TLT, you can
     * specify that via "contextMethodName:coreMethodName", where contextMethodName
     * is the name of the method on ModuleContext and coreMethodName is
     * the name of the method on TLT.
     *
     * Because the methods aren't actually defined in the traditional sense,
     * the documentation comments are included within the array for proper
     * context.
     * @private
     * @type String[]
     */
    var methodsToExpose = [

        /**
         * Broadcasts a message to the entire system.
         * @name broadcast
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to send.
         * @param {Variant} data The data to send along with the message.
         * @returns {void}
         */
        "broadcast",

        /**
         * Returns the configuration object for the module.
         * @name getConfig
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {Object} The configuration object for the module.
         */
        "getConfig:getModuleConfig",

        /**
         * Tells the system that the module wants to know when a particular
         * message occurs.
         * @name listen
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} messageName The name of the message to listen for.
         * @returns {void}
         */
        "listen",

        /**
         * Add HTTP header information to the module's default queue.
         * @name addHeader
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} headerName The name of the header.
         * @param {String} headerValue The value of the header.
         * @param {String} [queueId] Specifies the ID of the queue to receive the event.
         * @returns {void}
         */
        "addHeader",

        /**
         * Posts an event to the module's queue.
         * @name post
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {Object} event The event to put into the queue.
         * @param {String} [queueId] The ID of the queue to add the event to.
         * @returns {void}
         */
        "post",

        /**
         * Calculates the xpath of the given DOM Node.
         * @name getXPathFromNode
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {DOMElement} node The DOM node who's xpath is to be calculated.
         * @returns {String} The calculated xpath.
         */
        "getXPathFromNode",

        /* Log a DOM Capture message to the default queue.
         * @name performDOMCapture
         * @memberOf TLT.ModuleContext#
         * @function
         * @param {String} moduleName Name of the module which invoked this function.
         * @param {DOMElement} [root] Parent element from which to start the capture.
         * @param {Object} [config] DOM Capture configuration options.
         * @returns {String} The unique string representing the DOM Capture id.
         * null if DOM Capture failed.
         */
        "performDOMCapture",

        /**
         * @name getStartTime
         * @memberOf TLT.ModuleContext#
         * @function
         * @returns {integer} Returns the recorded timestamp in milliseconds corresponding to when the TLT object was created.
         */
        "getStartTime"
    ];

    /**
     * Creates a new ModuleContext object. This function ends up at TLT.ModuleContext.
     * @private
     * @param {String} moduleName The name of the module that will use this context.
     * @param {TLT} core The core object. This must be passed in to enable easier
     *        testing.
     */
    return function (moduleName, core) {

        // If you want to add methods that aren't directly mapped from TLT, do it here
        var context = {},
            i = 0,
            len = methodsToExpose.length,
            parts = null,
            coreMethod = null,
            contextMethod = null;

        // Copy over all methods onto the context object
        for (i = 0; i < len; i += 1) {

            // Check to see if the method names are the same or not
            parts = methodsToExpose[i].split(":");
            if (parts.length > 1) {
                contextMethod = parts[0];
                coreMethod = parts[1];
            } else {
                contextMethod = parts[0];
                coreMethod = parts[0];
            }

            context[contextMethod] = (function (coreMethod) {

                return function () {

                    // Gather arguments and put moduleName as the first one
                    var args = core.utils.convertToArray(arguments);
                    args.unshift(moduleName);

                    if (!core.hasOwnProperty(coreMethod)) {
                        throw new Error("Attempting to access method '" + coreMethod +
                                "' on TLT, but it doesn't exist. There's a " +
                                "misconfigured passthru method.");
                    }

                    // Pass through to the Core
                    return core[coreMethod].apply(core, args);
                };

            }(coreMethod));
        }

        context.utils = core.utils;

        return context;
    };

}());
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The ConfigService is responsible for managing global configuration settings.
 * This may include receiving dynamic configuration updates from the server at regular intervals.
 * The ConfigService fires a configupdated event when it receives updated configuration information.
 * @exports configService
 */

/*global TLT:true */

/**
 * @name configService
 * @namespace
 */
TLT.addService("config", function (core) {
    "use strict";

    /**
     * Merges a new configuration object/diff into the existing configuration by doing a deep copy.
     * @name configService-mergeConfig
     * @function
     * @private
     * @param  {Object} oldConf Existing configuration object.
     * @param  {Object} newConf New configuration object.
     */
    function mergeConfig(oldConf, newConf) {
        core.utils.extend(true, oldConf, newConf);
        configService.publish("configupdated", configService.getConfig());
    }



    /**
     * Holds the config for core and all services and modules.
     * @private
     * @name configService-config
     * @type {Object}
     */
    var config = {
            core: {},
            modules: {},
            services: {}
        },
        configService = core.utils.extend(false, core.utils.createObject(new TLT.EventTarget()), {
            /**
             * Returns the global configuration object.
             * @return {Object} The global configuration object.
             */
            getConfig: function () {
                return config;
            },
            /**
             * Assigns the global configuration for the system.
             * This is first called when Core.init() is called and also may be called later if new
             * configuration settings are returned from the server. After initial configuration is set,
             * all further calls are assumed to be diffs of settings that should be changed rather than
             * an entirely new configuration object.
             * @param  {Object} newConf The global configuration object.
             */
            updateConfig: function (newConf) {
                mergeConfig(config, newConf);
            },
            /**
             * Returns the configuration object for the core.
             * @return {Object} The core configuration object.
             */
            getCoreConfig: function () {
                return config.core;
            },
            /**
             * Assigns the configuration for the core. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {Object} newConf     A partial or complete core configuration object.
             */
            updateCoreConfig: function (newConf) {
                mergeConfig(config.core, newConf);
            },
            /**
             * Returns the configuration object for a given service.
             * @param {String} serviceName The name of the service to retrieve configuration information for.
             * @return {Object|null} The service configuration object or null if the named service doesn't exist.
             */
            getServiceConfig: function (serviceName) {
                // XXX - Return empty object {} instead of null and correct all places where this is being called.
                return config.services[serviceName] || null;
            },
            /**
             * Assigns the configuration for the named service. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} serviceName The name of the service to update configuration information for.
             * @param  {Object} newConf     A partial or complete service configuration object.
             */
            updateServiceConfig: function (serviceName, newConf) {
                if (typeof config.services[serviceName] === "undefined") {
                    config.services[serviceName] = {};
                }
                mergeConfig(config.services[serviceName], newConf);
            },
            /**
             * Returns the configuration object for a given module.
             * @param {String} moduleName The name of the module to retrieve configuration information for.
             * @return {Object|null} The module configuration object or null if the named module doesn't exist.
             */
            getModuleConfig: function (moduleName) {
                return config.modules[moduleName] || null;
            },
            /**
             * Assigns the configuration for the named module. All calls are assumed to be diffs
             * of settings that should be changed rather than an entirely new configuration object.
             * @param  {String} moduleName The name of the module to update configuration information for.
             * @param  {Object} newConf     A partial or complete module configuration object.
             */
            updateModuleConfig: function (moduleName, newConf) {
                if (typeof config.modules[moduleName] === "undefined") {
                    config.modules[moduleName] = {};
                }
                mergeConfig(config.modules[moduleName], newConf);
            },
            destroy: function () {
                config = {
                    core: {},
                    modules: {},
                    services: {}
                };
            }
        });

    return configService;

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The QueueService manages all queues in the system.
 * @exports queueService
 */

/*global TLT:true */

/**
 * @name queueService
 * @namespace
 */
TLT.addService("queue", function (core) {
    "use strict";

    /**
     * queueMananger
     * @private
     * @static
     * @name queueService-queueManager
     * @namespace
     */
    var CONFIG       = null,    // queue configuration
        // TODO: replace these with long form names i.e. aS -> ajaxService
        aS           = core.getService("ajax"),          // ajaxService
        bS           = core.getService("browser"),       // browserService
        eS           = core.getService("encoder"),       // encoderService
        sS           = core.getService("serializer"),    // serializerService
        cS           = core.getService("config"),        // configService
        mS           = core.getService("message"),       // messageService
        defaultQueue = null,    // config object for default queue
        queueTimers  = {},      // timer id for the queueTick
        autoFlushing = true,    // Bool, indicates whether to flush queues when
                                // threshold is reached or let the application control flushing.
        isInitialized = false,
        queueManager = (function () {
            var queues = {};

            /**
             * Checks if the specified queue exists.
             * @function
             * @name queueService-queueManager.exists
             * @param  {String} queueId The id of the queue to check for existence.
             * @return {Boolean}         Returns true if the queue exists, otherwise false.
             */
            function queueExists(queueId) {
                return typeof queues[queueId] !== "undefined";
            }

            /**
             * Adds a queue to the system.
             * @function
             * @name queueService-queueManager.add
             * @param {String} queueId The id of the queue to add.
             * @param {Object} opts    Some additional configuration options for this queue.
             * @param {String} opts.url  The endpoint URL to which the queue should be flushed.
             * @param {Number} opts.threshold The maximal amount of messages to store
             * in the queue before it gets flushed.
             * @param {String} opts.serialzer The serializer which should be used to serialize
             * the data in the queue when sending it to the server.
             * @return {Object} Returns the newly created queue.
             */
            function addQueue(queueId, opts) {
                if (!queueExists(queueId)) {
                    /* TODO: Add prototype functions to access queue members */
                    queues[queueId] = {
                        data: [],
                        queueId: queueId,
                        url: opts.url,
                        threshold: opts.threshold,
                        serializer: opts.serializer,
                        encoder: opts.encoder,
                        crossDomainEnabled: !!opts.crossDomainEnabled,
                        crossDomainIFrame: opts.crossDomainIFrame
                    };
                }
                return queues[queueId];
            }

            /**
             * Removes a queue from the system.
             * @function
             * @name queueService-queueManager.remove
             * @param  {String} queueId The id of the queue which should be deleted.
             */
            function removeQueue(queueId) {
                if (queueExists(queueId)) {
                    delete queues[queueId];
                }
            }

            /**
             * Returns the queue object associated with the given queueId.
             * @function
             * @name queueService-queueManager.get
             * @param  {String} queueId The id of the queue to return.
             * @return {Object}         Returns the queue object for the given id.
             */
            function getQueue(queueId) {
                if (queueExists(queueId)) {
                    return queues[queueId];
                }
                return null;
            }

            /**
             * Clears all items in the queue specified by the queue id.
             * @function
             * @name queueService-queueManager.clear
             * @param  {String} queueId The id of the queue which should be cleared.
             */
            function clearQueue(queueId) {
                var queue = getQueue(queueId);
                if (queue !== null) {
                    queue.data = [];
                }
            }

            /**
             * Returns the queue data and clears the queue.
             * @function
             * @name queueService-queueManager.flush
             * @param  {String} queueId The id of the queue to be flushed.
             * @return {Array}         Returns all items which were stored in the queue.
             */
            function flushQueue(queueId) {
                var data = null;
                if (queueExists(queueId)) {
                    data = getQueue(queueId).data;
                    clearQueue(queueId);
                }
                return data;
            }

            /**
             * Adds an item to a specific queue.
             * @function
             * @name queueService-queueManager.push
             * @param  {String} queueId The id of the queue to which the item should be added.
             * @param  {Object} data    The message object which should be stored in the queue.
             * @return {Number}         Returns the current length of the queue.
             */
            function pushToQueue(queueId, data) {
                var queue = null,
                    jsonStr = null,
                    bridgeAndroid = window.tlBridge,
                    bridgeiOS = window.iOSJSONShuttle;

                // Send to Native Android Bridge
                if ((typeof bridgeAndroid !== "undefined") &&
                        (typeof bridgeAndroid.addMessage === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeAndroid.addMessage(jsonStr);
                // Send to Native iOS Bridge
                } else if ((typeof bridgeiOS !== "undefined") &&
                        (typeof bridgeiOS === "function")) {
                    jsonStr = sS.serialize(data);
                    bridgeiOS(jsonStr);
                // Send to normal library queue
                } else {
                    if (queueExists(queueId)) {
                        queue = getQueue(queueId);
/*jshint devel:true */
                        if (typeof console !== "undefined") {
                            console.log("Added to queueId: ", queueId, " data: ", data);
                        }
                        queue.data.push(data);
                        /* Redirect the queue so any registered callback function
                         * can optionally modify it.
                         */
                        queue.data = core.redirectQueue(queue.data);
                        return queue.data.length;
                    }
                }
                return 0;
            }

            /**
             * @scope queueManager
             */
            return {
                exists: queueExists,
                add: addQueue,
                remove: removeQueue,
                get: getQueue,
                clear: clearQueue,
                flush: flushQueue,
                push: pushToQueue
            };

        }());


    /**
     * Handles the xhr response of the server call.
     * @function
     * @private
     * @name queueService-handleXhrCallback
     */
    function handleXhrCallback() {
        // TODO
    }

    /**
    * Get the path relative to the host.
    * @addon
    */
    function getUrlPath() {
        return window.location.pathname;
    }

    /**
     * Adds a HTTP header (name,value) pair to the specified queue.
     * @function
     * @private
     * @name queueService-addHeaderToQueue
     * @param  {String} queueId The id of the queue which should be flushed.
     * @param  {String} headerName The name of the header to be added.
     * @param  {String} headerValue The value of the header to be added.
     * @param  {Boolean} [recurring] Flag specifying if header should be sent
     *                   once (false) or always (true). Default behavior is to
     *                   send the header once.
     */
    function addHeaderToQueue(queueId, headerName, headerValue, recurring) {
        var queue = queueManager.get(queueId),
            header = {
                name: headerName,
                value: headerValue
            },
            qHeadersList = null;

        // Sanity check
        if (typeof headerName !== "string" || typeof headerValue !== "string") {
            return;
        }

        if (!queue.headers) {
            // TODO: Add prototype functions to help add/copy/remove headers
            queue.headers = {
                once: [],
                always: []
            };
        }

        qHeadersList = !!recurring ? queue.headers.always : queue.headers.once;
        qHeadersList.push(header);
    }

    /**
     * Copies HTTP headers {name,value} from the specified queue to an
     * object.
     * @function
     * @private
     * @name queueService-copyHeaders
     * @param  {String} queueId The id of the queue whose headers are copied.
     * @param  {Object} [headerObj] The object to which headers are added. If no
     * object is specified then a new one is created.
     * @return {Object} The object containing the copied headers.
     */
    function copyHeaders(queueId, headerObj) {
        var i = 0,
            len = 0,
            queue = queueManager.get(queueId),
            qHeaders = queue.headers,
            headersList = null;

        headerObj = headerObj || {};

        function copy(l, o) {
            var i = 0,
                len = 0,
                header = null;

            for (i = 0, len = l.length; i < len; i += 1) {
                header = l[i];
                o[header.name] = header.value;
            }
        }

        if (qHeaders) {
            headersList = [qHeaders.always, qHeaders.once];

            for (i = 0, len = headersList.length; i < len; i += 1) {
                copy(headersList[i], headerObj);
            }
        }

        return headerObj;
    }

    /**
     * Clear HTTP headers {name,value} from the specified queue. Only headers
     * that are to be sent once are cleared.
     * @function
     * @private
     * @name queueService-clearHeaders
     * @param  {String} queueId The id of the queue whose headers are cleared.
     */
    function clearHeaders(queueId) {
        var queue = null,
            qHeaders = null;

        if (!queueManager.exists(queueId)) {
            throw new Error("Queue: " + queueId + " does not exist!");
        }

        queue = queueManager.get(queueId);
        qHeaders = queue ? queue.headers : null;
        if (qHeaders) {
            // Only reset headers that are sent once.
            qHeaders.once = [];
        }
    }

    /**
     * Invoke the core function to get any HTTP request headers from
     * external scripts and add these headers to the default queue.
     * @function
     * @private
     * @returns The number of external headers added to the queue.
     */
    function getExternalRequestHeaders() {
        var i = 0,
            len,
            header,
            headers = core.provideRequestHeaders();

        if (headers && headers.length) {
            for (i = 0, len = headers.length; i < len; i += 1) {
                header = headers[i];
                addHeaderToQueue("DEFAULT", header.name, header.value, header.recurring);
            }
        }
        return i;
    }

    /**
     * Clears a specific queue and sends its serialized content to the server.
     * @function
     * @private
     * @name queueService-flushQueue
     * @param  {String} queueId The id of the queue to be flushed.
     */
    function flushQueue(queueId, sync) {
        var data = queueManager.flush(queueId),
            count = data !== null ? data.length : 0,
            queue = queueManager.get(queueId),
            httpHeaders = {
                "Content-Type": "application/json",
                "X-Tealeaf": "device (UIC) Lib/4.0.0.1607",
                "X-TealeafType": "GUI",  // For our past sins
                "X-TeaLeaf-Page-Url": getUrlPath()
            },
            serializer = queue.serializer || "json",
            contentEncoder = queue.encoder,
            requestData,
            retObj,
            xdomainFrameWindow = null;

        if (!count) {
            return;
        }

        // Wrap the messages with the header
        data = mS.wrapMessages(data);

        // Serialize the data
        if (serializer) {
            data = sS.serialize(data, serializer);
        }

        // Encode if specified
        if (contentEncoder) {
            retObj = eS.encode(data, contentEncoder);
            if (retObj && retObj.data && !retObj.error) {
                data = retObj.data;
                httpHeaders["Content-Encoding"] = retObj.encoding;
            }
        }

        getExternalRequestHeaders();
        copyHeaders(queueId, httpHeaders);

        if (queue.crossDomainEnabled) {
            xdomainFrameWindow = core.utils.getIFrameWindow(queue.crossDomainIFrame);
            if (!xdomainFrameWindow) {
                core.utils.clog("Cannot access xdomain frame window.");
                return;
            }
            requestData = {
                request: {
                    url: queue.url,
                    async: !sync,
                    headers: httpHeaders,
                    data: data
                }
            };

            if (!core.utils.isIE && typeof window.postMessage === "function") {
                xdomainFrameWindow.postMessage(requestData, queue.crossDomainIFrame.src);
            } else {
                try {
                    xdomainFrameWindow.sendMessage(requestData);
                } catch (e) {
                    core.utils.clog("Cannot access sendMessage API on xdomain frame window.");
                    return;
                }
            }
        } else {
            aS.sendRequest({
                oncomplete: handleXhrCallback,
                url: queue.url,
                async: !sync,
                headers: httpHeaders,
                data: data
            });
        }
        clearHeaders(queueId);
    }

    /**
     * Iterates over all queues and sends their contents to the servers.
     * @function
     * @private
     * @name queueServive-flushAll
     */
    function flushAll(sync) {
        var conf = null,
            queues = CONFIG.queues,
            i = 0;
        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            flushQueue(conf.qid, sync);
        }
        return true;
    }


    /**
     * Adds a message event to the specified queue.
     * If the queue threshold is reached the queue gets flushed.
     * @function
     * @private
     * @name queueService-addToQueue
     * @param {String} queueId The id of the queue which should be flushed.
     * @param {Object} data    The message event which should be stored in the queue.
     */
    function addToQueue(queueId, data) {
        var length = queueManager.push(queueId, mS.createMessage(data));
        if (length >= queueManager.get(queueId).threshold &&
                autoFlushing && core.getState() !== "unloading") {
            flushQueue(queueId);
        }
    }

    /**
     * Returns the queue id for the queue which is responsible for the given module.
     * @function
     * @private
     * @name queueService-getQueueId
     * @param  {String} moduleName The name of the module for which the id should get looked up.
     * @return {String}            Returns the queue id for the corresponding queue or the default queue id.
     */
    function getQueueId(moduleName) {
        var conf = null,
            queues = CONFIG.queues,
            module = "",
            i = 0,
            j = 0;

        for (i = 0; i < queues.length; i += 1) {
            conf = queues[i];
            if (conf && conf.modules) {
                for (j = 0; j < conf.modules.length; j += 1) {
                    module = conf.modules[j];
                    if (module === moduleName) {
                        return conf.qid;
                    }
                }
            }
        }
        return defaultQueue.qid;
    }


    function setTimer(qid, interval) {
        queueTimers[qid] = window.setTimeout(function tick() {
            flushQueue(qid);
            queueTimers[qid] = window.setTimeout(tick, interval);
        }, interval);
    }


    function clearTimers() {
        var key = 0;

        for (key in queueTimers) {
            if (queueTimers.hasOwnProperty(key)) {
                window.clearTimeout(queueTimers[key]);
                delete queueTimers[key];
            }
        }

        queueTimers = {};
    }


    /**
     * Handles the configupdated event from the configService and reinitialize all queues.
     * @function
     * @private
     * @name queueService-handleConfigUpdated
     * @param  {Object} newConf The new configuration object diff.
     */
    function handleConfigUpdated(newConf) {
        // TODO: merge config
    }



    /**
     * Sets up all the needed queues and event handlers and start the queueTick.
     * @function
     * @private
     * @param  {Object} config The queueService configuration object.
     */
    function initQueueService(config) {
        CONFIG = config;

        core.utils.forEach(CONFIG.queues, function (conf, i) {
            var crossDomainIFrame = null;
            if (conf.qid === "DEFAULT") {
                defaultQueue = conf;
            }
            if (conf.crossDomainEnabled) {
                crossDomainIFrame = bS.query(conf.crossDomainFrameSelector);
                if (!crossDomainIFrame) {
                    core.fail("Cross domain iframe not found");
                }
            }

            queueManager.add(conf.qid, {
                url: conf.endpoint,
                threshold: conf.maxEvents,
                serializer: conf.serializer,
                encoder: conf.encoder,
                timerInterval: conf.timerInterval || 0,
                crossDomainEnabled: conf.crossDomainEnabled || false,
                crossDomainIFrame: crossDomainIFrame
            });

            if (typeof conf.timerInterval !== "undefined" && conf.timerInterval > 0) {
                setTimer(conf.qid, conf.timerInterval);
            }
        });

        cS.subscribe("configupdated", handleConfigUpdated);

        isInitialized = true;
    }

    function destroy() {
        if (autoFlushing) {
            flushAll(!CONFIG.asyncReqOnUnload);
        }
        cS.unsubscribe("configupdated", handleConfigUpdated);

        clearTimers();

        CONFIG = null;
        defaultQueue = null;
        isInitialized = false;
    }

    /**
     * @scope queueService
     */
    return {
        addHeaderToQueue: addHeaderToQueue,
        copyHeaders: copyHeaders,
        clearHeaders: clearHeaders,
        getExternalRequestHeaders: getExternalRequestHeaders,
        getQueueManager: function () {
            return queueManager;
        },
        getAutoFlushing: function () {
            return autoFlushing;
        },
        init: function () {
            if (!isInitialized) {
                initQueueService(cS.getServiceConfig("queue") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(queueService)");
            }
        },

        /**
         * Get's called when the core shut's down.
         * Clean up everything.
         */
        destroy: function () {
            destroy();
        },

        // TODO: Need to expose for selenium functional tests
        _getQueue: function (qid) { return queueManager.get(qid).data; },

        /**
         * Adds a HTTP header (name,value) pair to the specified queue.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {String} headerName The name of the header to be added.
         * @param  {String} headerValue The value of the header to be added.
         * @param  {String} queueId The id of the queue which should be flushed.
         */
        addHeader: function (moduleName, headerName, headerValue, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addHeaderToQueue(queueId, headerName, headerValue);
        },

        /**
         * Enables/disables automatic flushing of queues so that the application
         * could decide on their own when to flush by calling flushAll.
         * @param {Boolean} flag Could be either true or false to enable or disable
         *                  auto flushing respectively.
         */
        setAutoFlush: function (flag) {
            if (flag === true) {
                autoFlushing = true;
            } else {
                autoFlushing = false;
            }
        },

        /**
         * Forces a particular queue to be flushed, sending its information to the server.
         * @param  {String} queueId The ID of the queue to be flushed.
         */
        flush: function (queueId) {
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            flushQueue(queueId);
        },

        /**
         * Forces all queues to be flushed, sending all queue information to the server.
         */
        flushAll: function (sync) {
            return flushAll(!!sync);
        },

        /**
         * Send event information to the module's default queue.
         * This doesn't necessarily force the event data to be sent to the server,
         * as this behavior is defined by the queue itself.
         * @param  {String} moduleName The name of the module saving the event.
         * @param  {Object} queueEvent The event information to be saved to the queue.
         * @param  {String} [queueId]    Specifies the ID of the queue to receive the event.
         */
        post: function (moduleName, queueEvent, queueId) {
            queueId = queueId || getQueueId(moduleName);
            if (!queueManager.exists(queueId)) {
                throw new Error("Queue: " + queueId + " does not exist!");
            }
            addToQueue(queueId, queueEvent);
        }
    };

});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document, ActiveXObject */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browserBase", function (core) {
    "use strict";

    var nonClickableTags = {
            OPTGROUP: true,
            OPTION: true,
            NOBR: true
        },
        queryDom = {},
        configService = core.getService("config"),
        serializerService = null,
        config,
        blacklist,
        customid,
        getXPathFromNode,
        isInitialized = false;

    function updateConfig() {
        configService = core.getService("config");
        serializerService = core.getService("serializer");
        config = core.getService("config").getServiceConfig("browser") || {};
        blacklist = config.hasOwnProperty("blacklist") ? config.blacklist : [];
        customid = config.hasOwnProperty("customid") ? config.customid : [];
    }

    function initBrowserBase() {
        updateConfig();
        configService.subscribe("configupdated", updateConfig);
        serializerService = core.getService("serializer");

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    function checkId(node) {
        var i,
            len,
            re;

        if (!node || !node.id || typeof node.id !== "string") {
            return false;
        }

        for (i = 0, len = blacklist.length; i < len; i += 1) {
            if (typeof blacklist[i] === "string") {
                if (node.id === blacklist[i]) {
                    return false;
                }
            } else if (typeof blacklist[i] === "object") {
                re = new RegExp(blacklist[i].regex, blacklist[i].flags);
                if (re.test(node.id)) {
                    return false;
                }
            }
        }
        return true;
    }

    function getEventType(event, target) {
        var returnObj = {
                type: null,
                // Event subtype is not used in the UIC
                subType: null
            },
            type;

        // Sanity check
        if (!event) {
            return returnObj;
        }

        // Normalize event type for jQuery events focusin, focusout
        type = event.type;
        switch (type) {
        case "focusin":
            type = "focus";
            break;
        case "focusout":
            type = "blur";
            break;
        default:
            break;
        }
        returnObj.type = type;

        return returnObj;
    }

    /**
     * Examines the type and subType of the target.
     * @function
     * @name browserService-getElementType
     * @param  {Object} element The normalized target element.
     * @return {Object} Returns an object which contains the type and subType of the target element.
     */
    function getElementType(element) {
        var returnObj = {
                type: null,
                subType: null
            };

        // Sanity check
        if (!element) {
            return returnObj;
        }

        returnObj.type = element.tagName;
        returnObj.subType = element.type || null;

        return returnObj;
    }

    /**
     * Returns an element by it's id and idType where id could be either an HTML id,
     *     attribute ID or XPath selector.
     * @param  {String} selector The selector. Either a single HTML ID or an attribute ID
     *                  example: "myid=customid" or a tealeaf XPath string.
     * @param  {Number} type     A number, indicating the type of the query
     *                           as in the object 'idTypes' below.
     *                           -1 for HTML ID, -2 for XPath and -3 for attribute ID.
     * @return {Object}          Returns the node, if found. Otherwise null.
     */
    function getNodeFromID(selector, type, scope) {
        var idTypes = {
                HTML_ID: "-1",
                XPATH_ID: "-2",
                ATTRIBUTE_ID: "-3"
            },
            doc,
            node = null,
            parts;

        // Sanity check
        if (!selector || !type) {
            return node;
        }

        doc = scope || window.document;
        type = type.toString();
        if (type === idTypes.HTML_ID) {
            if (doc.getElementById) {
                node = doc.getElementById(selector);
            } else if (doc.querySelector) {
                node = doc.querySelector("#" + selector);
            }
        } else if (type === idTypes.ATTRIBUTE_ID) {
            parts = selector.split("=");
            if (doc.querySelector) {
                node = doc.querySelector("[" + parts[0] + "=\"" + parts[1] + "\"]");
            }
        } else if (type === idTypes.XPATH_ID) {
            node = queryDom.xpath(selector, doc);
        }
        return node;
    }

    /**
     * Generates an XPath for a given node
     * @function
     */
    getXPathFromNode = (function () {

        var specialChildNodes = {
                "NOBR": true,
                "P": true
            };

        /**
         * Returns Xpath string for a node
         * @private
         * @param {Element} node DOM element
         * @return {string} xpath string
         */
        function getXPathArrayFromNode(node) {
            var i,
                j,
                idValid = false,
                tmp_child = null,
                parent_window = null,
                parent_node = null,
                xpath = [],
                loop = true,
                localTop = core._getLocalTop();

            while (loop) {
                loop = false;

                if (!core.utils.isUndefOrNull(node)) {
                    if (!core.utils.isUndefOrNull(node.tagName)) {
                        // Hack fix to handle tags that are not normally visual elements
                        if (specialChildNodes.hasOwnProperty(node.tagName)) {
                            node = node.parentNode;
                        }
                    }
                    for (idValid = checkId(node);
                            node !== document && !idValid;
                            idValid = checkId(node)) {
                        parent_node = node.parentNode;
                        if (!parent_node) {
                            parent_window = core.utils.getWindow(node);
                            parent_node = (parent_window !== localTop) ? parent_window.frameElement : document;
                        }

                        tmp_child = parent_node.firstChild;
                        if (typeof tmp_child === "undefined") {
                            return xpath;
                        }

                        for (j = 0; tmp_child; tmp_child = tmp_child.nextSibling) {
                            if (tmp_child.nodeType === 1 && tmp_child.tagName === node.tagName) {
                                if (tmp_child === node) {
                                    xpath[xpath.length] = [node.tagName, j];
                                    break;
                                }
                                j += 1;
                            }
                        }
                        node = parent_node;
                    }

                    if (idValid) {
                        xpath[xpath.length] = [node.id];
                        if (core.utils.isIFrameDescendant(node)) {
                            loop = true;
                            node = core.utils.getWindow(node).frameElement;
                        }
                    }
                }
            }

            return xpath;
        }

        // actual getXPathFromNode function
        return function (node) {
            var xpath = getXPathArrayFromNode(node),
                parts = [],
                i = xpath.length;

            if (i < 1) {
                return "null";
            }
            while (i) {
                i -= 1;
                if (xpath[i].length > 1) {
                    parts[parts.length] = '["' + xpath[i][0] + '",' + xpath[i][1] + "]";
                } else {
                    parts[parts.length] = '[' + serializerService.serialize(xpath[i][0], "json") + ']';
                }
            }
            return ("[" + parts.join(",") + "]");
        };
    }());

    /**
     * Returns the scroll position (left, top) of the document
     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX
     * @private
     * @param {DOMObject} doc The document object.
     * @return {Object} An object specifying the document's scroll offset position {left, top}
     */
    function getDocScrollPosition(doc) {
        var scrollPos = {
                left: -1,
                top: -1
            },
            docElement;

        doc = doc || document;
        // Get the scrollLeft, scrollTop from documentElement or body.parentNode or body in that order.
        docElement = doc.documentElement || doc.body.parentNode || doc.body;

        // If window.pageXOffset exists, use it. Otherwise fallback to getting the scrollLeft position.
        scrollPos.left = (typeof window.pageXOffset === "number") ? window.pageXOffset : docElement.scrollLeft;
        scrollPos.top = (typeof window.pageYOffset === "number") ? window.pageYOffset : docElement.scrollTop;

        return scrollPos;
    }

    /**
     * Returns true if an event is a jQuery event wrpper object.
     * @private
     * @param {UIEvent} event Browser event to examine
     * @return {boolean} true if given event is jQuery event
     */
    function isJQueryEvent(event) {
        return event && typeof event.originalEvent !== "undefined" &&
            typeof event.isDefaultPrevented !== "undefined"  &&
            !event.isSimulated;
    }


    /**
     * Looks for event details. Usually it returns an event itself, but for touch events
     * function returns an element from one of the touch arrays.
     * @private
     * @param {UIEvent} event Browser event. If skipped function will look for window.event
     * @return {UIEvent} latest touch details for touch event or original event object
     *          for all other cases
     */
    function getEventDetails(event) {
        if (!event) {
            return null;
        }
        if (event.type && event.type.indexOf("touch") === 0) {
            if (isJQueryEvent(event)) {
                event = event.originalEvent;
            }
            if (event.type === "touchstart") {
                event = event.touches[event.touches.length - 1];
            } else if (event.type === "touchend") {
                event = event.changedTouches[0];
            }
        }
        return event;
    }


    /**
     * Normalizes the event object for InternetExplorer older than 9.
     * @return {HttpEvent} normalized event object
     */
    function normalizeEvent(event) {
        var e = event || window.event,
            doc = document.documentElement,
            body = document.body,
            found = false,
            foundElement = null,
            i = 0;

        // skip jQuery event wrapper
        if (isJQueryEvent(e)) {
            e = e.originalEvent;
        }

        // IE case
        if (typeof event === 'undefined' || typeof e.target === 'undefined') {
            e.target = e.srcElement || window.window;
            e.timeStamp = Number(new Date());
            if (e.pageX === null || typeof e.pageX === "undefined") {
                e.pageX = e.clientX + ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -
                    ((doc && doc.clientLeft) || (body && body.clientLeft) || 0);
                e.pageY = e.clientY + ((doc && doc.scrollTop)  || (body && body.scrollTop)  || 0) -
                    ((doc && doc.clientTop)  || (body && body.clientTop)  || 0);
            }
            e.preventDefault = function () {
                this.returnValue = false;
            };
            e.stopPropagation = function () {
                this.cancelBubble = true;
            };
        }

        // Chrome case getting blur for inner elements sending click
        if (window.chrome && e.path !== undefined && e.type === "click") {
            if (e.path.length === undefined) {
                return e;
            }

            for (i = 0; i < e.path.length; i++) {
                if (e.path[i].tagName === "BUTTON") {
                    found = true;
                    foundElement = e.path[i];
                    i = e.path.length;
                }
            }
            if (found) {
                return {
                    originalEvent: e,
                    target: foundElement,
                    srcElement: foundElement,
                    type: e.type,
                    pageX: document.body.scrollLeft + foundElement.getBoundingClientRect().left,
                    pageY: document.body.scrollTop + foundElement.getBoundingClientRect().top
                };
            }
        }

        return e;
    }

    /**
     * Normalizes target element. In case of touch event the target is considered to be an
     * element for whch the last action took place
     * @private
     * @param {UIEvent} event browser event
     * @return {Element} DOM element
     */
    function normalizeTarget(event) {
        var itemSource = null;

        if (!event) {
            return null;
        }

        if (event.srcElement) {
            // IE
            itemSource = event.srcElement;
        } else {
            // W3C
            itemSource = event.target;
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.explicitOriginalTarget;
            }
            if (!itemSource) {
                // Mozilla only (non-standard)
                itemSource = event.originalTarget;
            }
        }

        if (!itemSource && event.type.indexOf("touch") === 0) {
            itemSource = getEventDetails(event).target;
        }

        while (itemSource && nonClickableTags[itemSource.tagName]) {
            itemSource = itemSource.parentNode;
        }

        // IE when srcElement pointing to window
        if (!itemSource && event.srcElement === null) {
            itemSource = window.window;
        }

        return itemSource;
    }


    /**
     * Returns event position independently to the event type.
     * In case of touch event the position of last action will be returned.
     * @private
     * @param {UIEvent} event Browser event
     * @return {Object} object containing x and y properties
     */
    function getEventPosition(event) {
        var posX = 0,
            posY = 0,
            doc = document.documentElement,
            body = document.body;

        event = getEventDetails(event);

        if (event) {
            if (event.pageX || event.pageY) {
                posX = event.pageX;
                posY = event.pageY;
            } else if (event.clientX || event.clientY) {
                posX = event.clientX + (doc ? doc.scrollLeft : (body ? body.scrollLeft : 0)) -
                                       (doc ? doc.clientLeft : (body ? body.clientLeft : 0));
                posY = event.clientY + (doc ? doc.scrollTop : (body ? body.scrollTop : 0)) -
                                       (doc ? doc.clientTop : (body ? body.clientTop : 0));
            }
        }

        return {
            x: posX,
            y: posY
        };
    }

    /**
     * Find one or more elements using a XPath selector.
     * @function
     * @name browserService-queryDom.xpath
     * @param  {String} query The XPath query to search for.
     * @param  {Object} [scope="document"] The DOM subtree to run the query in.
     * @return {Object}       Returns the DOM element matching the XPath.
     */
    queryDom.xpath = function (query, scope) {
        var xpath = null,
            elem,
            pathElem = null,
            i,
            j,
            k,
            len,
            jlen;

        // Sanity check
        if (!query) {
            return null;
        }

        xpath = serializerService.parse(query);
        scope = scope || document;
        elem = scope;

        if (!xpath) {
            return null;
        }

        for (i = 0, len = xpath.length; i < len && elem; i += 1) {
            pathElem = xpath[i];
            if (pathElem.length === 1) {
                if (scope.getElementById) {
                    elem = scope.getElementById(pathElem[0]);
                } else if (scope.querySelector) {
                    elem = scope.querySelector("#" + pathElem[0]);
                } else {
                    elem = null;
                }
            } else {
                for (j = 0, k = -1, jlen = elem.childNodes.length; j < jlen; j += 1) {
                    if (elem.childNodes[j].nodeType === 1 && elem.childNodes[j].tagName.toUpperCase() === pathElem[0]) {
                        k += 1;
                        if (k === pathElem[1]) {
                            elem = elem.childNodes[j];
                            break;
                        }
                    }
                }
                if (k === -1) {
                    return null;
                }
            }
        }

        return (elem === scope || !elem) ? null : elem;
    };


    /**
     * The Point interface represents a point on the page to
     *     x- and y-coordinates.
     * @constructor
     * @private
     * @name browserService-Point
     * @param {Integer} x The x-coordinate of the point.
     * @param {Integer} y The y-coordinate of the point.
     */
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }


    /**
     * The Size  interface represents the width and height of an element
     *     on the page.
     * @constructor
     * @private
     * @name browserService-Size
     * @param {Integer} width  Width of the element that received the event.
     * @param {Integer} height Height of the element that received the event.
     */
    function Size(width, height) {
        this.width = width || 0;
        this.height = height || 0;
    }


    /**
     * The ElementData interface represents a normalized browser event object.
     * @constructor
     * @private
     * @name browserService-ElementData
     * @param {Object} event  The browser event.
     * @param {Object} target The HTML element which received the event.
     */
    function ElementData(event, target) {
        var id,
            elementType,
            pos;

        target = normalizeTarget(event);
        id = this.examineID(target);
        elementType = getElementType(target);
        pos = this.examinePosition(event, target);

        this.element = target;
        this.id = id.id;
        this.idType = id.type;
        this.type = elementType.type;
        this.subType = elementType.subType;
        this.state = this.examineState(target);
        this.position = new Point(pos.x, pos.y);
        this.size = new Size(pos.width, pos.height);
        this.xPath = id.xPath;
        this.name = id.name;
    }

    /**#@+
     * @constant
     * @enum {Number}
     * @fieldOf browserService-ElementData
     */
    ElementData.HTML_ID = -1;
    ElementData.XPATH_ID = -2;
    ElementData.ATTRIBUTE_ID = -3;
    /**#@-*/

    /**
     * Examines how to specify the target element
     *     (either by css selectors or xpath)
     *     and returns an object with the properties id and type.
     * @function
     * @name browserService-ElementData.examineID
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object with the properties id and type.
     *      id contains either a css or xpath selector.
     *      type contains a reference to either ElementData.HTML_ID,
     *      ElementData.XPATH_ID or ElementData.ATTRIBUTE_ID
     * @todo determine the element css/xpath/attribute selector.
     */
    ElementData.prototype.examineID = function (target) {
        var id,
            type,
            xPath,
            attribute_id,
            name,
            i = customid.length,
            attrib;

        try {
            xPath = getXPathFromNode(target);
        } catch (e) { }
        name = target.name;

        try {
            if (!core.utils.isIFrameDescendant(target)) {

                if (checkId(target)) {
                    id = target.id;
                    type = ElementData.HTML_ID;
                } else if (customid.length && target.attributes) {
                    while (i) {
                        i -= 1;
                        attrib = target.attributes[customid[i]];
                        if (typeof attrib !== "undefined") {
                            id = customid[i] + "=" + (attrib.value || attrib);
                            type = ElementData.ATTRIBUTE_ID;
                        }
                    }
                }
            }
        } catch (e2) { }

        if (!id) {
            id = xPath;
            type = ElementData.XPATH_ID;
        }

        return {
            id: id,
            type: type,
            xPath: xPath,
            name: name
        };
    };


    /**
     * Examines the current state of the HTML element if it's an input/ui element.
     * @function
     * @name browserService-ElementData.examineState
     * @param  {Object} target The HTML element which received the event.
     * @return {Object}        Returns an object which contains all properties
     *     to describe the state.
     * @todo determine the current state.
     */
    ElementData.prototype.examineState = function (target) {
        var tagnames = {
                "a": ["innerText", "href"],
                "input": {
                    "range": ["maxValue:max", "value"],
                    "checkbox": ["value", "checked"],
                    "radio": ["value", "checked"],
                    "image": ["src"]
                },
                "select": ["value"],
                "button": ["value", "innerText"],
                "textarea": ["value"]
            },
            tagName = typeof target.tagName !== "undefined" ? target.tagName.toLowerCase() : "",
            properties = tagnames[tagName] || null,
            selectedOption = null,
            values = null,
            i = 0,
            len = 0,
            alias = null,
            key = "";

        if (properties !== null) {
            // For input elements, another level of indirection is required
            if (Object.prototype.toString.call(properties) === "[object Object]") {
                // default state for input elements is represented by the "value" property
                properties = properties[target.type] || ["value"];
            }
            values = {};
            for (key in properties) {
                if (properties.hasOwnProperty(key)) {
                    if (properties[key].indexOf(":") !== -1) {
                        alias = properties[key].split(":");
                        values[alias[0]] = target[alias[1]];
                    } else if (properties[key] === "innerText") {
                        values[properties[key]] = core.utils.trim(target.innerText || target.textContent);
                    } else {
                        values[properties[key]] = target[properties[key]];
                    }
                }
            }
        }

        // Special processing for select lists
        if (tagName === "select" && target.options && !isNaN(target.selectedIndex)) {
            values.index = target.selectedIndex;
            if (values.index >= 0 && values.index < target.options.length) {
                selectedOption = target.options[target.selectedIndex];
                /* Select list value is derived from the selected option's properties
                 * in the following order:
                 * 1. value
                 * 2. label
                 * 3. text
                 * 4. innerText
                 */
                values.value = selectedOption.getAttribute("value") || selectedOption.getAttribute("label") || selectedOption.text || selectedOption.innerText;
                values.text = selectedOption.text || selectedOption.innerText;
            }
        }

        return values;
    };


    /**
     * Gets the current zoom value of the browser with 1 being equivalent to 100%.
     * @function
     * @name getZoomValue
     * @return {int}        Returns zoom value of the browser.
     */
    function getZoomValue() {
        var factor = 1,
            rect,
            physicalW,
            logicalW;

        if (document.body.getBoundingClientRect) {
            // rect is only in physical pixel size in IE before version 8
            // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
            // on IE 9
            try {
                rect = document.body.getBoundingClientRect();
            } catch (e) {
                core.utils.clog("getBoundingClientRect failed.", e);
                return factor;
            }
            physicalW = rect.right - rect.left;
            logicalW = document.body.offsetWidth;

            // the zoom level is always an integer percent value
            factor = Math.round((physicalW / logicalW) * 100) / 100;
        }
        return factor;
    }

    /**
     * Gets BoundingClientRect value from a HTML element.
     * @function
     * @name getBoundingClientRectNormalized
     * @param  {Object} element The HTML element.
     * @return {Object} An object with x, y, width, and height.
     */
    function getBoundingClientRectNormalized(element) {
        var rect,
            rectangle,
            zoom,
            scrollPos;

        if (!element || !element.getBoundingClientRect) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        // CS-8780: getBoundingClientRect() can throw an exception in certain instances. Observed
        // on IE 9
        try {
            rect = element.getBoundingClientRect();
            scrollPos = getDocScrollPosition(document);
        } catch (e) {
            core.utils.clog("getBoundingClientRect failed.", e);
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        rectangle = {
            // Normalize viewport-relative left & top with scroll values to get left-x & top-y relative to the document
            x: rect.left + scrollPos.left,
            y: rect.top + scrollPos.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
        if (core.utils.isIE) {
            // IE ONLY: the bounding rectangle include the top and left borders of the client area
            rectangle.x -= document.documentElement.clientLeft;
            rectangle.y -= document.documentElement.clientTop;

            zoom = getZoomValue();
            if (zoom !== 1) {  // IE 7 at non-default zoom level
                rectangle.x = Math.round(rectangle.x / zoom);
                rectangle.y = Math.round(rectangle.y / zoom);
                rectangle.width = Math.round(rectangle.width / zoom);
                rectangle.height = Math.round(rectangle.height / zoom);
            }
        }
        return rectangle;
    }

    /**
     * Examines the position of the event relative to the HTML element which
     * received the event on the page. The top left corner of the element is 0,0
     * and bottom right corner of the element is equal to it's width, height.
     * @function
     * @name browserService-ElementData.examinePosition
     * @param  {Object} target The HTML element which received the event.
     * @return {Point}        Returns a Point object.
     */
    ElementData.prototype.examinePosition = function (event, target) {
        var posOnDoc = getEventPosition(event),
            elPos = getBoundingClientRectNormalized(target);

        elPos.x = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.x - elPos.x)) : elPos.width / 2;
        elPos.y = (posOnDoc.x || posOnDoc.y) ? Math.round(Math.abs(posOnDoc.y - elPos.y)) : elPos.height / 2;

        return elPos;
    };


    /**
     * The WebEvent  interface represents a normalized browser event object.
     *     When an event occurs, the BrowserService wraps the native event
     *     object in a WebEvent.
     * @constructor
     * @private
     * @name browserService-WebEvent
     * @param {Object} event The native browser event.
     */
    function WebEvent(event) {
        var pos,
            eventType;

        this.data = event.data || null;
        this.delegateTarget = event.delegateTarget || null;

		//add the gesture event data to the webevent if it exists.
		if (event.gesture || (event.originalEvent && event.originalEvent.gesture)) {
			this.gesture = event.gesture || event.originalEvent.gesture;
		}

        event = normalizeEvent(event);
        pos = getEventPosition(event);
        this.custom = false;    // @TODO: how to determine if it's a custom event?
        this.nativeEvent = this.custom === true ? null : event;
        this.position = new Point(pos.x, pos.y);
        this.target = new ElementData(event, event.target);
        // Do not rely on browser provided event.timeStamp since FF sets
        // incorrect values. Refer to Mozilla Bug 238041
        this.timestamp = (new Date()).getTime();

        eventType = getEventType(event, this.target);
        this.type = eventType.type;
        this.subType = eventType.subType;
    }

    function processDOMEvent(event) {
        core._publishEvent(new WebEvent(event));
    }


    return {
        // Expose private functions for unit testing
        normalizeEvent: normalizeEvent,
        normalizeTarget: normalizeTarget,
        getEventDetails: getEventDetails,
        getEventPosition: getEventPosition,
        getEventType: getEventType,
        getElementType: getElementType,
        getBoundingClientRectNormalized: getBoundingClientRectNormalized,
        checkId: checkId,
        getZoomValue: getZoomValue,
        getDocScrollPosition: getDocScrollPosition,
        init: function () {
            if (!isInitialized) {
                initBrowserBase();
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(browserBaseService)");
            }
        },
        destroy: function () {
            destroy();
        },
        WebEvent: WebEvent,
        ElementData: ElementData,
        processDOMEvent: processDOMEvent,

        getXPathFromNode: function (moduleName, node) {
            return getXPathFromNode(node);
        },
        getNodeFromID: getNodeFromID,
        queryDom: queryDom
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The browserService implements some low-level methods for
 * modifying / accessing the DOM.
 * @exports browserService
 */

/*global TLT, XPathResult, document */
/*global console: false */

/**
 * @name browserService
 * @namespace
 */
TLT.addService("browser", function (core) {
    "use strict";

    var configService = core.getService("config"),
        browserBaseService = core.getService('browserBase'),
        ajaxService = core.getService('ajax'),
        addEventListener = null,
        removeEventListener = null,
        serviceConfig = configService.getServiceConfig("browser") || {},
        useCapture = (serviceConfig.useCapture === true),
        isInitialized = false,
        errorCodes = {
            NO_QUERY_SELECTOR: "NOQUERYSELECTOR"
        },

        /**
         * Returns a new function which will be used in the subscribe method and which calls the
         * handler function with the normalized WebEvent.
         * @private
         * @function
         * @name browserService-wrapWebEvent
         * @param  {Function} handler The handler which was passed to the browserService's subscribe method.
         * @return {Function}         Returns a new function which, when called, passes a WebEvent to the handler.
         */
        wrapWebEvent = function (handler) {
            return function (event) {
                handler(new browserBaseService.WebEvent(event));
            };
        },

        /**
         * Loads a script by it's URL, appends it to te document and executes
         * it as soon as it's loaded.
         * @private
         * @function
         * @name browserService-loadScript
         * @param  {String} url The URL of the script to load.
         */
        loadScript = function (url) {
            var fjs = document.getElementsByTagName('script')[0],
                js = document.createElement('script');
            js.src = url;
            fjs.parentNode.insertBefore(js, fjs);
        },

        queryDom = {
            /**
             * Helper function to transform a nodelist into an array.
             * @function
             * @name browserService-queryDom.list2Array
             * @param  {List} nodeList Pass in a DOM NodeList
             * @return {Array}          Returns an array.
             */
            list2Array: function (nodeList) {
                var len = nodeList.length,
                    result = [],
                    i;
                if (typeof nodeList.length === "undefined") {
                    return [nodeList];
                }
                for (i = 0; i < len; i += 1) {
                    result[i] = nodeList[i];
                }
                return result;
            },
            /**
             * Finds one or more elements in the DOM using a CSS or XPath selector
             * and returns an array instead of a NodeList.
             * @function
             * @name browserService-queryDom.find
             * @param  {String} query Pass in a CSS or XPath selector query.
             * @param  {Object} [scope="document"]  The DOM subtree to run the query in.
             *      If not provided, document is used.
             * @param  {String} [type="css"]  The type of query. Either "css' (default)
             *      or 'xpath' to allow XPath queries.
             * @return {Array}       Returns an array of nodes that matches the particular query.
             */
            find: function (query, scope, type) {
                type = type || "css";
                return this.list2Array(this[type](query, scope));
            },
            /**
             * Find one or more elements using a CSS selector.
             * @function
             * @name browserService-queryDom.css
             * @param  {String} query The CSS selector query.
             * @param  {Object} [scope="document"] The DOM subtree to run the query in.
             * @return {Array}       Returns an array of nodes that matches the particular query.
             */
            css: function (query, scope) {
                var self = this,
                    message = null,
                    bodyEl = document.getElementsByTagName("body")[0],
                    bConfig = configService.getServiceConfig("browser") || {},
                    sizzleURL = bConfig.sizzleURL || null,
                    jQuery = bConfig.hasOwnProperty("jQueryObject") ? core.utils.access(bConfig.jQueryObject) : window.jQuery,
                    sizzle = bConfig.hasOwnProperty("sizzleObject") ? core.utils.access(bConfig.sizzleObject) : window.Sizzle;

                if (typeof document.querySelectorAll === "undefined") {
                    // redefine self.css to use self.Sizzle as selector engine.
                    self.css = function (query, scope) {
                        scope = scope || document;
                        return self.Sizzle(query, scope);
                    };
                    if (typeof self.Sizzle === "undefined") {
                        // define self.Sizzle function to use either Sizzle library or jQuery.
                        if (sizzleURL) {
                            message = {
                                type: "GET",
                                url: sizzleURL,
                                async: false,
                                oncomplete: function (result) {
                                    // load Sizzle library via xhr and eval it in an AMD context.
                                    function define(definition) {
                                        self.Sizzle = definition();
                                    }
                                    define.amd = true;
                                    eval(result.responseText);
                                }
                            };
                            ajaxService.sendRequest(message);
                        } else {
                            // if sizzleURL is not defined in configuration try
                            // to find jQuery or Sizzle globally.
                            try {
                                if (bodyEl === sizzle("html > body", document)[0]) {
                                    // if Sizzle is defined and behaves as expected, use it as self.Sizzle.
                                    self.Sizzle = sizzle;
                                }
                            } catch (e) {
                                try {
                                    if (bodyEl === jQuery(document).find("html > body").get()[0]) {
                                        // if jQuery is defined on window and behaves correctly define
                                        // self.Sizzle to use jQuery.
                                        self.Sizzle = function (query, scope) {
                                            return jQuery(scope).find(query).get();
                                        };
                                    }
                                } catch (ex) {
                                    core.fail("Sizzle was not found", errorCodes.NO_QUERY_SELECTOR);
                                }
                            }
                        }
                    }
                } else {
                    // otherwise, if document.querySelectorAll is available, use it.
                    self.css = function (query, scope) {
                        scope = scope || document;
                        return scope.querySelectorAll(query);
                    };
                }
                return self.css(query, scope);
            }
        },
        // store handler functions which got passed to subscribe/unsubscribe.
        handlerMappings = (function () {
            var data = new core.utils.WeakMap();

            return {
                add: function (originalHandler) {
                    var handlers = data.get(originalHandler) || [wrapWebEvent(originalHandler), 0];

                    handlers[1] += 1;
                    data.set(originalHandler, handlers);
                    return handlers[0];
                },

                find: function (originalHandler) {
                    var handlers = data.get(originalHandler);
                    return handlers ? handlers[0] : null;
                },

                remove: function (originalHandler) {
                    var handlers = data.get(originalHandler);
                    if (handlers) {
                        handlers[1] -= 1;
                        if (handlers[1] <= 0) {
                            data.remove(originalHandler);
                        }
                    }
                }
            };
        }());

    /**
     * Initialization function
     * @function
     */
    function initBrowserServiceW3C() {
        queryDom.xpath = browserBaseService.queryDom.xpath;

        if (typeof document.addEventListener === 'function') {
            addEventListener = function (target, eventName, handler) {
                target.addEventListener(eventName, handler, useCapture);
            };
            removeEventListener = function (target, eventName, handler) {
                target.removeEventListener(eventName, handler, useCapture);
            };
        } else if (typeof document.attachEvent !== 'undefined') {
            addEventListener = function (target, eventName, handler) {
                target.attachEvent('on' + eventName, handler);
            };
            removeEventListener = function (target, eventName, handler) {
                target.detachEvent('on' + eventName, handler);
            };
        } else {
            throw new Error("Unsupported browser");
        }

        isInitialized = true;
    }


    /**
     * @scope browserService
     */
    return {
        queryDom: queryDom,

        init: function () {
            if (!isInitialized) {
                initBrowserServiceW3C();
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(browserService.w3c)");
            }
        },

        destroy: function () {
            isInitialized = false;
        },

        getServiceName: function () {
            return "W3C";
        },

        /**
         * Find a single element in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object|null}       The first matching HTML element or null if not found.
         */
        query: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type)[0] || null;
			} catch (err) {
				console.log(err.message);
				return [];
			}
        },

        /**
         * Find all elements in the DOM mathing a particular query.
         * @param  {String} query Either a CSS or XPath query.
         * @param {Object} [scope="document"] The DOM subtree to run the query in.
         *     If not provided document is used.
         * @param  {String} [type="css"]  The type of the query. Either 'css' (default)
         *     or 'xpath' to allow XPath queries.
         * @return {Object[]|Array}       An array of HTML elements matching the query
         *     or and empty array if no elements are matching.
         */
		queryAll: function (query, scope, type) {
            try {
				return queryDom.find(query, scope, type);
			} catch (err) {
				console.log(err.message);
				return [];
			}
        },

        /**
         * Loads a JavaScript file onto the current page.
         * @param  {String} url The URL of the JavaScript file to load.
         */
        loadScript: function (url) {
            loadScript(url);
        },

        /**
         * Subscribes an event handler to be called when a particular event occurs.
         * @param  {String} eventName The name of the event to listen for.
         * @param  {Object} target    The object on which the event will fire.
         * @param  {Function} handler   The function to call when the event occurs.
         *     The browserServices passes a WebEvent object to this handler
         */
        subscribe: function (eventName, target, handler) {
            var wrappedHandler = handlerMappings.add(handler);
            addEventListener(target, eventName, wrappedHandler);
        },

        /**
         * Unsubscribes an event handler from a particular event.
         * @param  {String} eventName The name of the event for which the handler was subscribed.
         * @param  {Object} target    The object on which the event fires.
         * @param  {Function} handler   The function to remove as an event handler.
         */
        unsubscribe: function (eventName, target, handler) {
            var wrappedHandler = handlerMappings.find(handler);
            if (wrappedHandler) {
                try {
                    removeEventListener(target, eventName,  wrappedHandler);
                } catch (e) {
                    core.utils.clog("Unsubscribe failed for event: " + eventName + "\n" + e.message);
                }
                handlerMappings.remove(handler);
            }
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*global TLT:true, window: true, ActiveXObject */

/**
 * @name ajaxService
 * @namespace
 */
TLT.addService("ajax", function (core) {
    "use strict";

    var getXHRObject,
		convertHeaders = function (headersObj) {
            var header = "",
                headers = [];
            for (header in headersObj) {
                if (headersObj.hasOwnProperty(header)) {
                    headers.push([header, headersObj[header]]);
                }
            }
            return headers;
        },
		isInitialized = false;

    /**
     * Builds an object of key => value pairs of HTTP headers from a string.
     * @param  {String} headers The string of HTTP headers separated by newlines
     *      (i.e.: "Content-Type: text/html\nLast-Modified: ..")
     * @return {Object}         Returns an object where every key is a header
     *     and every value it's correspondending value.
     */
    function extractResponseHeaders(headers) {
        headers = headers.split('\n');
        var headersObj = {},
            i = 0,
            len = headers.length,
            header = null;
        for (i = 0; i < len; i += 1) {
            header = headers[i].split(': ');
            headersObj[header[0]] = header[1];
        }
        return headersObj;
    }

    /**
     * @private
     * @function
     * @name ajaxService-makeAjaxCall
     * @see browserService.sendRequest
     */
    function makeAjaxCall(message) {
        var xhr = getXHRObject(),
            headers = [["X-Requested-With", "XMLHttpRequest"]],
            timeout = 0,
            async = typeof message.async !== "boolean" ? true : message.async,
            header = "",
            callbackFn = null,
            i,
            length;

        if (message.headers) {
            headers = headers.concat(convertHeaders(message.headers));
        }
        if (message.contentType) {
            headers.push(["Content-Type", message.contentType]);
        }
        xhr.open(message.type.toUpperCase(), message.url, async);

        for (i = 0, length = headers.length; i < length; i += 1) {
            header = headers[i];
            if (header[0] && header[1]) {
                xhr.setRequestHeader(header[0], header[1]);
            }
        }

        xhr.onreadystatechange = callbackFn = function () {
            if (xhr.readyState === 4) {
                xhr.onreadystatechange = callbackFn = function () {};
                if (message.timeout) {
                    window.clearTimeout(timeout);
                }
                message.oncomplete({
                    headers: extractResponseHeaders(xhr.getAllResponseHeaders()),
                    responseText: (xhr.responseText || null),
                    statusCode: xhr.status,
                    success: (xhr.status === 200)
                });
                xhr = null;
            }
        };

        xhr.send(message.data || null);
        callbackFn();

        if (message.timeout) {
            timeout = window.setTimeout(function () {
                if (!xhr) {
                    return;
                }

                xhr.onreadystatechange = function () {};
                if (xhr.readyState !== 4) {
                    xhr.abort();
                }
                xhr = null;
            }, message.timeout);
        }
    }

    function initAjaxService() {
		if (typeof window.XMLHttpRequest !== 'undefined') {
            getXHRObject = function () {
                return new XMLHttpRequest();
            };
        } else {
            getXHRObject = function () {
                return new ActiveXObject("Microsoft.XMLHTTP");
            };
        }

		isInitialized = true;
    }

    return {
        convertHeaders: convertHeaders,
        extractResponseHeaders: extractResponseHeaders,
		init: function () {
			if (!isInitialized) {
                initAjaxService();
            }
		},

		/**
         * Destroys service state
         */
        destroy: function () {
            isInitialized = false;
        },

		/**
         * Makes an Ajax request to the server.
         * @param {Object} message An AjaxRequest object containing all the information
         *     neccessary for making the request.
         * @param {String} [message.contentType] Set to a string to override the default
         *     content type of the request.
         * @param {String} [message.data] A string containing data to POST to the server.
         * @param {Object} [message.headers] An object whose properties represent HTTP headers.
         * @param {Function} message.oncomplete A callback function to call when the
         *     request has completed.
         * @param {Integer} [message.timeout] The number of milliseconds to wait
         *     for a response before closing the Ajax request.
         * @param {String} [message.type="POST"] Either 'GET' or 'POST',
         *     indicating the type of the request to make.
         * @param {String} message.url The URL to send the request to.
         *     This should contain any required query string parameters.
         */
        sendRequest: function (message) {
            message.type = message.type || "POST";
            makeAjaxCall(message);
        }
    };
});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The DOM Capture Service provides the ability to capture a snapshot of
 * the DOM as a HTML snippet.
 * @exports domCaptureService
 */

/*global TLT:true, window: true, Node:true */
/*global console: false */

/**
 * @name domCaptureService
 * @namespace
 */
TLT.addService("domCapture", function (core) {
    "use strict";

    var configService = core.getService("config"),
        messageService,
        isInitialized = false,
        tltUniqueIDIndex = 1,
        dupNode = function () {},
        getDOMCapture = function () {},
        updateConfig = function () {};

    /**
     * Initialization of the service. Subscribe with config service for
     * the configupdated message.
     * @private
     * @function
     * @param {object} config
     */
    function initDOMCaptureService(config) {
        configService.subscribe("configupdated", updateConfig);
        messageService = core.getService("message");
        isInitialized = true;
    }

    /**
     * Destroy the service. Unsubscribe from the configupdated message.
     * @private
     * @function
     */
    function destroyDOMCaptureService() {
        configService.unsubscribe("configupdated", updateConfig);
        isInitialized = false;
    }

    /**
     * Returns a unique identifier string.
     * @private
     * @function
     * @returns {String} A string that can be used as a unique identifier.
     */
    function getUniqueID() {
        var id;

        id = "tlt-" + core.utils.getSerialNumber();

        return id;
    }

    /**
     * Remove child nodes matching the given tag name.
     * @private
     * @function
     * @param {DOMNode} node The root or parent DOM Node element
     * @param {String}  tagName The tag to be removed
     * @returns The node without any tags matching tagName
     */
    function removeTags(node, tagName) {
        var i,
            nodeList;

        // Sanity check
        if (!node || !node.getElementsByTagName || !tagName) {
            return;
        }

        nodeList = node.getElementsByTagName(tagName);
        if (nodeList && nodeList.length) {
            for (i = nodeList.length - 1; i >= 0; i -= 1) {
                nodeList[i].parentNode.removeChild(nodeList[i]);
            }
        }

        return node;
    }

    /**
     * Returns the DOCTYPE of the document as a formatted string.
     * @private
     * @function
     * @param {DOMNode} node A document node.
     * @returns {String} The formatted doctype or null.
     */
    function getDoctypeAsString(node) {
        var doctype,
            doctypeStr = null;

        // Sanity check
        if (!node || !node.doctype) {
            return null;
        }

        doctype = node.doctype;
        if (doctype) {
            doctypeStr = "<!DOCTYPE " + doctype.name +
                         (doctype.publicId ? ' PUBLIC "' + doctype.publicId + '"' : "") +
                         (!doctype.publicId && doctype.systemId ? ' SYSTEM' : "") +
                         (doctype.systemId ? ' "' + doctype.systemId + '"' : "") +
                         ">";
        }

        return doctypeStr;
    }

    /**
     * Fix child input nodes and set attributes such as value & checked.
     * @private
     * @function
     * @param {DOMNode} target The root or parent DOM Node element
     */
    function fixInputs(target) {
        var i,
            j,
            inputElement,
            inputList,
            len,
            radio,
            radioButtons,
            radioLen;

        // Sanity check
        if (!target) {
            return;
        }

        inputList = target.getElementsByTagName("input");
        if (inputList) {
            for (i = 0, len = inputList.length; i < len; i += 1) {
                inputElement = inputList[i];
                switch (inputElement.type) {
                case "checkbox":
                case "radio":
                    if (inputElement.checked) {
                        inputElement.setAttribute("checked", "checked");
                    } else {
                        inputElement.removeAttribute("checked");
                    }
                    break;
                default:
                    inputElement.setAttribute("value", inputElement.value);
                    break;
                }
            }
        }
    }

    /**
     * Fix the child select lists by setting the selected attribute on the option elements of
     * the lists in the target node.
     * @private
     * @function
     * @param {DOMNode} source The root or parent DOM Node element
     * @param {DOMNode} target The target DOM Node element that is a copy of the source
     */
    function fixSelectLists(source, target) {
        var sourceElem,
            sourceList,
            targetElem,
            targetList,
            i,
            j,
            len;

        // Sanity check
        if (!source || !source.getElementsByTagName || !target || !target.getElementsByTagName) {
            return;
        }

        sourceList = source.getElementsByTagName("select");
        targetList = target.getElementsByTagName("select");

        // TODO: ASSERT source and target nodes have same order of select elements

        if (sourceList) {
            for (i = 0, len = sourceList.length; i < len; i += 1) {
                sourceElem = sourceList[i];
                targetElem = targetList[i];
                for (j = 0; j < sourceElem.options.length; j += 1) {
                    if (j === sourceElem.selectedIndex || sourceElem.options[j].selected) {
                        targetElem.options[j].setAttribute("selected", "selected");
                    } else {
                        targetElem.options[j].removeAttribute("selected");
                    }
                }
            }
        }
    }

    /**
     * Return the outer HTML of the document or element.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element
     * @returns {String} The HTML text of the document or element. If the node is not
     * a document or element type then return null.
     */
    function getHTMLText(node) {
        var nodeType,
            htmlText = null;

        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
                // DOCUMENT_NODE
                htmlText = node.documentElement.outerHTML;
                break;
            case 1:
                // ELEMENT_NODE
                htmlText = node.outerHTML;
                break;
            default:
                htmlText = null;
                break;
            }
        }
        return htmlText;
    }

    /**
     * Checks if the DOM node is allowed for capture. Only document and element
     * node types are allowed for capture.
     * @private
     * @function
     * @param {DOMNode} node The DOM Node element to be checked
     * @returns {Boolean} Returns true if the node is document or element type.
     */
    function isNodeValidForCapture(node) {
        var nodeType,
            valid = false;
        // Only DOCUMENT (9) & ELEMENT (1) nodes are valid for capturing
        if (node) {
            nodeType = node.nodeType || -1;
            switch (nodeType) {
            case 9:
            case 1:
                valid = true;
                break;
            default:
                valid = false;
                break;
            }
        }
        return valid;
    }

    /**
     * Capture the frames from the source and add the unique token to the frame element
     * in the target.
     * @private
     * @function
     * @param {DOMNode} source The source element
     * @param {DOMNode} target The target element duplicated from the source.
     * @param {Object}  options The capture options object
     * @returns {Object} Returns the captured frames & canvas elements as per the enabled options.
     */
    function getIframes(source, target, options) {
        var i, j,
            len,
            frameTag,
            frameTags = [ "iframe", "frame" ],
            sourceIframe,
            iframeWindow,
            iframeDoc,
            iframeCapture,
            iframeID,
            returnObject = {
                frames: [],
                canvas: []
            },
            sourceIframeList,
            targetIframeList;

        for (j = 0; j < frameTags.length; j += 1) {
            frameTag = frameTags[j];
            // Get the frames in the original DOM
            sourceIframeList = source.getElementsByTagName(frameTag);

            // Get the cloned frames - the content is not copied here - these will be
            // used to add an attribute to specify which item in the frames collection
            // contains the content for this frame
            targetIframeList = target.getElementsByTagName(frameTag);

            if (sourceIframeList) {
                for (i = 0, len = sourceIframeList.length; i < len; i += 1) {
                    try {
                        sourceIframe = sourceIframeList[i];
                        iframeWindow = core.utils.getIFrameWindow(sourceIframe);
                        if (iframeWindow && iframeWindow.document) {
                            iframeDoc = iframeWindow.document;

                            iframeCapture = getDOMCapture(iframeDoc, iframeDoc, options);
                            iframeID = getUniqueID();
                            // Set the tltid for this frame in the target DOM
                            targetIframeList[i].setAttribute("tltid", iframeID);

                            // Merge this frame's captured DOM into the return object
                            returnObject.frames.push({
                                root: iframeCapture.root,
                                charset: iframeDoc.characterSet || iframeDoc.charset,
                                tltid: iframeID
                            });
                            returnObject.frames = returnObject.frames.concat(iframeCapture.frames);
                            returnObject.canvas = returnObject.canvas.concat(iframeCapture.canvas);
                        }
                    } catch (e) {
                        // Do nothing!
                    }
                }
            }
        }
        return returnObject;
    }

    /**
     * Calculate the total length of the HTML in the captured object.
     * @private
     * @function
     * @param {Object} captureObj The DOM capture object containing the serialized HTML.
     * @returns {Number} Returns the total length of the serialized object.
     */
    function getCapturedLength(captureObj) {
        var i,
            len,
            totalLength = 0;

        if (!captureObj || !captureObj.root) {
            return totalLength;
        }

        totalLength = captureObj.root.length;
        for (i = 0, len = captureObj.frames.length; i < len; i += 1) {
            if (captureObj.frames[i].root) {
                totalLength += captureObj.frames[i].root.length;
            }
        }

        return totalLength;
    }

    /**
     * Clone the provided document or element node.
     * @private
     * @function
     * @param {DOMNode} node The element to be duplicated.
     * @returns {DOMNode} Returns the duplicated node.
     */
    dupNode = function (node) {
        var dup = null;

        if (isNodeValidForCapture(node)) {
            dup = node.cloneNode(true);
            if (!dup && node.documentElement) {
                // Fix for Android and Safari bug which returns null when cloneNode is called on the document element.
                dup = node.documentElement.cloneNode(true);
            }
        }

        return dup;
    };

    /**
     * Capture the DOM starting at the root element as per the provided configuration options.
     * @private
     * @function
     * @param {DOMNode} doc The document element.
     * @param {DOMNode} root The root element that needs to be captured.
     * @param {Object}  options The capture options object.
     * @returns {Object} Returns the object containing the captured and serialized DOM.
     */
    getDOMCapture = function (doc, root, options) {
        var new_doc = null,
            canvasCaptureList,
            frameCaptureObj,
            captureObj = {};

        // Sanity check
        if (!doc || !root) {
            return captureObj;
        }

        new_doc = dupNode(root, doc);

        // Remove script tags
        if (options.removeScripts) {
            removeTags(new_doc, "script");
        }

        // Set "selected" attribute on select list elements
        fixSelectLists(root, new_doc);

        // Set attributes on input elements.
        fixInputs(new_doc);

        // Apply privacy
        new_doc = messageService.applyPrivacyToDocument(new_doc);

        if (options.captureCanvas) {
            // TODO: Get the canvas elements
            canvasCaptureList = null;
        }

        if (options.captureFrames) {
            // Get the iframes
            frameCaptureObj = getIframes(root, new_doc, options);
        }

        // Add all the captured data to the capture object
        if (frameCaptureObj) {
            captureObj = core.utils.mixin(captureObj, frameCaptureObj);
        }
        if (canvasCaptureList) {
            if (!captureObj.canvas) {
                captureObj.canvas = [];
            }
            captureObj.canvas = captureObj.canvas.concat(canvasCaptureList);
        }
        captureObj.root = (getDoctypeAsString(root) || "") + getHTMLText(new_doc);
        captureObj.charset = doc.characterSet || doc.charset;

        return captureObj;
    };

    /**
     * Callback function which receives notification from config service when
     * the configuration is updated.
     * @private
     * @function
     */
    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
    };

    /**
     * @scope domCaptureService
     */
    return {
        // Expose private functions for unit testing
        updateConfig: updateConfig,
        getUniqueID: getUniqueID,
        removeTags: removeTags,
        getDoctypeAsString: getDoctypeAsString,
        fixInputs: fixInputs,
        fixSelectLists: fixSelectLists,
        getHTMLText: getHTMLText,
        isNodeValidForCapture: isNodeValidForCapture,
        getCapturedLength: getCapturedLength,
        dupNode: dupNode,
        /**
         * Callback function invoked by the core to initialize the DOM Capture service.
         * @private
         * @function
         */
        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initDOMCaptureService(configService.getServiceConfig("domCapture") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(domCaptureService)");
            }
        },

        /**
         * Callback function invoked by the core to destroy the DOM Capture service.
         * @private
         * @function
         */
        destroy: function () {
            destroyDOMCaptureService();
        },

        /**
         * API function exposed by the DOM Capture service. Accepts the root element and
         * DOM capture options object.
         * @param  {DOMNode} root The root element for the DOM capture.
         * @param  {Object}  options The configuration options for performing the DOM capture.
         * @return {Object} An object containing the captured DOM.
         */
        captureDOM: function (root, options) {
            var captureObj = null,
                totalLength = 0;

            // Sanity check - DOM Capture is not supported on IE 8 and below
            if (!isInitialized || core.utils.isLegacyIE) {
                return captureObj;
            }

            if (!options || typeof options !== "object") {
                options = {};
            }
            root = root || window.document;

            captureObj = getDOMCapture(window.document, root, options);

            // Check if the capture meets the length threshold (if any)
            if (options.maxLength) {
                totalLength = getCapturedLength(captureObj);
                if (totalLength > options.maxLength) {
                    captureObj = {
                        errorCode: 101,
                        error: "Captured length (" + totalLength + ") exceeded limit (" + options.maxLength + ")."
                    };
                }
            }

            return captureObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The EncoderService provides the ability to extend the library with various data encodings.
 * @exports encoderService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name encoderService
 * @namespace
 */
TLT.addService("encoder", function (core) {
    "use strict";

    var encoderServiceConfig = {},
        configService = null,
        handleConfigUpdated = null,
        isInitialized = false;

    /**
     * Returns the encoder object for the specified encoder type.
     * @private
     * @function
     * @param {String} type The type of encoder object. e.g. "gzip"
     * @returns {Object} The encoder object or null if not found.
     */
    function getEncoder(type) {
        var encoder = null;

        // Sanity check
        if (!type) {
            return encoder;
        }
        encoder = encoderServiceConfig[type];
        if (encoder && typeof encoder.encode === "string") {
            encoder.encode = core.utils.access(encoder.encode);
        }

        return encoder;
    }

    /**
     * Initializes the encoder service.
     * @private
     * @function
     * @param {Object} config The configuration object for this service
     */
    function initEncoderService(config) {
        encoderServiceConfig = config;

        configService.subscribe("configupdated", handleConfigUpdated);
        isInitialized = true;
    }

    /**
     * Destroys the encoder service.
     * @private
     * @function
     */
    function destroy() {
        configService.unsubscribe("configupdated", handleConfigUpdated);

        isInitialized = false;
    }

    /**
     * Callback handler for the configupdated event. Refreshes the service configuration to the latest.
     * @private
     * @function
     */
    handleConfigUpdated = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed.
        initEncoderService(configService.getServiceConfig("encoder") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        // Expose private functions for unit testing
        handleConfigUpdated: handleConfigUpdated,
        getEncoder: getEncoder,

        init: function () {
            configService = core.getService("config");
            if (!isInitialized) {
                initEncoderService(configService.getServiceConfig("encoder") || {});
            } else {
                core.utils.clog("Attempt to initialize service (encoder) which has been already initialized.");
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Encodes data using specified encoder.
         * @param  {String} data The data to encode.
         * @param  {String} type The name of the encoder to use.
         * @return {Object} An object containing the encoded data or error message.
         */
        encode: function (data, type) {
            var encoder,
                result,
                returnObj = {
                    data: null,
                    encoding: null,
                    error: null
                };

            // Sanity check
            if ((typeof data !== "string" && !data) || !type) {
                returnObj.error = "Invalid " + (!data ? "data" : "type") + " parameter.";
                return returnObj;
            }

            // Get the specified encoder
            encoder = getEncoder(type);
            if (!encoder) {
                returnObj.error = "Specified encoder (" + type + ") not found.";
                return returnObj;
            }

            // Sanity check
            if (typeof encoder.encode !== "function") {
                returnObj.error = "Configured encoder (" + type + ") encode method is not a function.";
                return returnObj;
            }

            // Invoke the encode method of the encoder and return the result.
            result = encoder.encode(data);
            if (!result || core.utils.getValue(result, "buffer", null) === null) {
                returnObj.error = "Encoder (" + type + ") returned an invalid result.";
                return returnObj;
            }

            returnObj.data = result.buffer;
            returnObj.encoding = encoder.defaultEncoding;

            return returnObj;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The MessageService creates messages in the correct format to be transmitted to the server.
 * @exports messageService
 */

/*global TLT:true */

/**
 * @name messageService
 * @namespace
 */
TLT.addService("message", function (core) {
    "use strict";

    var screenviewOffsetTime = null,
        count             = 0,
        messageCount      = 0,
        sessionStart      = new Date(),
        tlStartLoad       = new Date(),
        browserBaseService = core.getService("browserBase"),
        browserService    = core.getService("browser"),
        configService     = core.getService("config"),
        config            = configService.getServiceConfig("message") || {},
        windowHref        = window.location.href,
        windowId          = "TODO",
        pageId            = "ID" + tlStartLoad.getHours() + "H" +
                            tlStartLoad.getMinutes() + "M" +
                            tlStartLoad.getSeconds() + "S" +
                            tlStartLoad.getMilliseconds() + "R" +
                            Math.random(),
        privacy           = config.hasOwnProperty("privacy") ? config.privacy : [],
        privacyMasks      = {},
        maskingCharacters = {
            lower: "x",
            upper: "X",
            numeric: "9",
            symbol: "@"
        },

        //TODO move these to a global section due to they might be used elsewhere
        isApple = navigator.userAgent.indexOf("iPhone") > -1 || navigator.userAgent.indexOf("iPod") > -1 || navigator.userAgent.indexOf("iPad") > -1,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Android") > -1,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = window.screen ? window.screen.width : 0,
        deviceOriginalHeight = window.screen ? window.screen.height : 0,
        deviceOrientation = window.orientation || 0,
        deviceWidth = isApple || isAndroidChrome ? deviceOriginalWidth : deviceOriginalWidth <= 320 ? deviceOriginalWidth : deviceOriginalWidth / devicePixelRatio,
        deviceHeight = isApple || isAndroidChrome ? deviceOriginalHeight : deviceOriginalWidth <= 320 ? deviceOriginalHeight : deviceOriginalHeight / devicePixelRatio,
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        startWidth = window.innerWidth || document.documentElement.clientWidth,
        startHeight = window.innerHeight || document.documentElement.clientHeight,
        isInitialized = false;


    /**
     * Base structure for a message object.
     * @constructor
     * @private
     * @name messageService-Message
     * @param {Object} event The QueueEvent to transform into a message object.
     */
    function Message(event) {
        var key = '';

        /**
         * The message type.
         * @type {Number}
         * @see browserService-Message.TYPES
         */
        this.type          = event.type;
        /**
         * The offset from the beginning of the session.
         * @type {Number}
         */
        this.offset        = (new Date()).getTime() - sessionStart.getTime();
        /**
         * The offset from the most recent application context message.
         * @type {Number}
         */
        if ((event.type === 2) || (screenviewOffsetTime === null)) {
            screenviewOffsetTime = new Date();
        }
        this.screenviewOffset = (new Date()).getTime() - screenviewOffsetTime.getTime();

        /**
         * The count of the overall messages until now.
         * @type {Number}
         */
        this.count         = (messageCount += 1);

        /**
         * To indicate that user action came from the web.
         * @type {Boolean}
         */
        this.fromWeb       = true;

        // iterate over the properties in the queueEvent and add all the objects to the message.
        for (key in event) {
            if (event.hasOwnProperty(key)) {
                this[key] = event[key];
            }
        }
    }

    /**
     * Empty filter. Returns an empty string which would be used as value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns an empty string.
     */
    privacyMasks.PVC_MASK_EMPTY = function (value) {
        return "";
    };

    /**
     * Basic filter. Returns a predefined string for every value.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a predefined mask/string.
     */
    privacyMasks.PVC_MASK_BASIC = function (value) {
        var retMask = "XXXXX";

        // Sanity check
        if (typeof value !== "string") {
            return "";
        }
        return (value.length ? retMask : "");
    };

    /**
     * Type filter. Returns predefined values for uppercase/lowercase
     *                         and numeric values.
     * @param  {String} value The value of the input/control.
     * @return {String}       Returns a string/mask which uses predefined
     *                        characters to mask the value.
     */
    privacyMasks.PVC_MASK_TYPE = function (value) {
        var characters,
            i = 0,
            len = 0,
            retMask = "";

        // Sanity check
        if (typeof value !== "string") {
            return retMask;
        }

        characters = value.split("");

        for (i = 0, len = characters.length; i < len; i += 1) {
            if (core.utils.isNumeric(characters[i])) {
                retMask += maskingCharacters.numeric;
            } else if (core.utils.isUpperCase(characters[i])) {
                retMask += maskingCharacters.upper;
            } else if (core.utils.isLowerCase(characters[i])) {
                retMask += maskingCharacters.lower;
            } else {
                retMask += maskingCharacters.symbol;
            }
        }
        return retMask;
    };

    privacyMasks.PVC_MASK_EMPTY.maskType = 1; // reported value is empty string.
    privacyMasks.PVC_MASK_BASIC.maskType = 2; // reported value is fixed string "XXXXX".
    privacyMasks.PVC_MASK_TYPE.maskType = 3;  // reported value is a mask according to character type
                                              // as per configuration, e.g. "HelloWorld123" becomes "XxxxxXxxxx999".
    privacyMasks.PVC_MASK_CUSTOM = {
        maskType: 4 // reported value is return value of custom function provided by config.
    };

    /**
     * Checks which mask should be used to replace the value and applies
     * it to the string. If an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask The privacy object.
     * @param  {String} str  The string to be masked.
     */
    function maskStr(mask, str) {
        var filter = privacyMasks.PVC_MASK_BASIC;

        // Sanity check
        if (typeof str !== "string") {
            return str;
        }

        if (!mask) {
            // Default
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_EMPTY.maskType) {
            filter = privacyMasks.PVC_MASK_EMPTY;
        } else if (mask.maskType === privacyMasks.PVC_MASK_BASIC.maskType) {
            filter = privacyMasks.PVC_MASK_BASIC;
        } else if (mask.maskType === privacyMasks.PVC_MASK_TYPE.maskType) {
            filter = privacyMasks.PVC_MASK_TYPE;
        } else if (mask.maskType === privacyMasks.PVC_MASK_CUSTOM.maskType) {
            if (typeof mask.maskFunction === "string") {
                filter = core.utils.access(mask.maskFunction);
            } else {
                filter = mask.maskFunction;
            }
            if (typeof filter !== "function") {
                // Reset to default
                filter = privacyMasks.PVC_MASK_BASIC;
            }
        }
        return filter(str);
    }

    /**
     * Checks which mask should be used to replace the value and applies
     * it on the message object. By default, if an invalid mask is specified,
     * the BASIC mask will be applied.
     * @param  {Object} mask    The privacy object.
     * @param  {Object} message The entire message object.
     */
    function applyMask(mask, message) {
        // Sanity check
        if (!message || !message.target) {
            return;
        }

        if (typeof message.target.prevState !== "undefined" && message.target.prevState.hasOwnProperty("value")) {
            message.target.prevState.value = maskStr(mask, message.target.prevState.value);
        }
        if (typeof message.target.currState !== "undefined" && message.target.currState.hasOwnProperty("value")) {
            message.target.currState.value = maskStr(mask, message.target.currState.value);
        }
    }

    /**
     * Checks whether one of the privacy targets matches the target
     *                          of the current mesage.
     * TODO: There are several places in the library where the same type
     * of matching result is required based on id or selector. This should
     * be consolidated into a single helper function.
     * @param  {Array} targets An array of objects as defined in the
     *                         privacy configuration.
     * @param  {Object} target  The target object of the message.
     * @return {Boolean}         Returns true if one of the targets match.
     *                           Otherwise false.
     */
    function matchesTarget(targets, target) {
        var i,
            j,
            element,
            qr,
            qrLen,
            qrTarget,
            regex,
            len,
            tmpTarget;

        // Sanity check
        if (!targets || !target || !target.id) {
            return false;
        }

        for (i = 0, len = targets.length; i < len; i += 1) {
            tmpTarget = targets[i];

            // Check if target in config is a selector string.
            if (typeof tmpTarget === "string") {
                qr = browserService.queryAll(tmpTarget);
                for (j = 0, qrLen = qr ? qr.length : 0; j < qrLen; j += 1) {
                    if (qr[j]) {
                        qrTarget = browserBaseService.ElementData.prototype.examineID(qr[j]);
                        if (qrTarget.type === target.idType && qrTarget.id === target.id) {
                            return true;
                        }
                    }
                }
            } else if (tmpTarget.id && tmpTarget.idType && target.idType.toString() === tmpTarget.idType.toString()) {
                // Note: idType provided by wizard is a string so convert both to strings before comparing.

                // An id in the configuration could be a direct match, in which case it will be a string OR
                // it could be a regular expression in which case it would be an object like this:
                // {regex: ".+private$", flags: "i"}
                switch (typeof tmpTarget.id) {
                case "string":
                    if (tmpTarget.id === target.id) {
                        return true;
                    }
                    break;
                case "object":
                    regex = new RegExp(tmpTarget.id.regex, tmpTarget.id.flags);
                    if (regex.test(target.id)) {
                        return true;
                    }
                    break;
                }
            }
        }
        return false;
    }

    /**
     * Runs through all privacy configurations and checks if it matches
     * the current message object.
     * @param  {Object} message The message object.
     * @return {Object}         The message, either with replaced values
     *                          if a target of the privacy configuration
     *                          matched or the original message if the
     *                          configuration didn't match.
     */
    function privacyFilter(message) {
        var i,
            len,
            mask;

        if (!message || !message.hasOwnProperty("target")) {
            return message;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            if (matchesTarget(mask.targets, message.target)) {
                applyMask(mask, message);
                break;
            }
        }
        return message;
    }

    /**
     * Applies the privacy configuration to all the matching elements
     * of the specified document object.
     * @param  {DOMDocument} doc The document object to which the privacy rules
     *                      need to be applied.
     * @return {DOMDocument}     The document object to which the privacy rules
     *                      have been applied.
     */
    function applyPrivacyToDocument(doc) {
        var i, j, k,
            element,
            len,
            mask,
            qr,
            qrLen,
            target,
            targets,
            targetsLen;

        // Sanity check
        if (!doc) {
            return doc;
        }

        for (i = 0, len = privacy.length; i < len; i += 1) {
            mask = privacy[i];
            targets = mask.targets;
            for (j = 0, targetsLen = targets.length; j < targetsLen; j += 1) {
                target = targets[j];
                if (typeof target === "string") {
                    // CSS selector
                    qr = browserService.queryAll(target, doc);
                    for (k = 0, qrLen = qr.length; k < qrLen; k += 1) {
                        element = qr[k];
                        if (element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                } else {
                    if (typeof target.id === "string") {
                        element = browserBaseService.getNodeFromID(target.id, target.idType, doc);
                        if (element && element.value) {
                            element.setAttribute("value", maskStr(mask, element.value));
                        }
                    }
                    // TODO: Handle the case where the target.id is a regex.
                    /*
                     * 1. Save all the regex rules into 3 arrays depending on the idType
                     * {
                     *     htmlID: [ {regex, mask} ],
                     *     xpathID: [],
                     *     customID: []
                     * }
                     * 2. Outside this for loop, get all the input elements in the document
                     * 3. Get element id, idType
                     */
                }
            }
        }

        return doc;
    }

    /**
     * Gets called when the configserver fires configupdated event.
     */
    function updateConfig() {
        configService = core.getService("config");
        config = configService.getServiceConfig("message") || {};
        privacy = config.hasOwnProperty("privacy") ? config.privacy : [];
    }

    function initMessageService() {
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }

    function destroy() {
        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }


    /**
     * @scope messageService
     */
    return {
        privacyMasks: privacyMasks,
        applyMask: applyMask,
        matchesTarget: matchesTarget,
        privacyFilter: privacyFilter,
        updateConfig: updateConfig,

        init: function () {
            if (!isInitialized) {
                initMessageService();
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(messageService)");
            }
        },

        destroy: function () {
            destroy();
        },

        applyPrivacyToDocument: applyPrivacyToDocument,

        /**
         * Accepts a simple queue event  and wraps it into a complete message that the server can understand.
         * @param  {Object} event The simple event information
         * @return {Object}       A complete message that is ready for transmission to the server.
         */
        createMessage: function (event) {
            if (typeof event.type === "undefined") {
                throw new TypeError("Invalid queueEvent given!");
            }
            return privacyFilter(new Message(event));
        },

        /**
         * Mock function to create a JSON structure around messages before sending to server.
         * @param  {Array} messages An array of messages
         * @return {Object}          Returns a JavaScript object which can be serialized to JSON
         *      and send to the server.
         *  @todo rewrite functionality
         */
        wrapMessages: function (messages) {
            var messagePackage = {
                messageVersion: "4.0.0.0",
                serialNumber: (count += 1),
                sessions: [{
                    id: pageId,
                    startTime: tlStartLoad.getTime(),
                    timezoneOffset: tlStartLoad.getTimezoneOffset(),
                    messages: messages,
                    clientEnvironment: {
                        webEnvironment: {
                            libVersion: "4.0.0.1607",
                            page: windowHref,
                            windowId: windowId,
                            screen: {
                                devicePixelRatio: devicePixelRatio,
                                deviceOriginalWidth: isApple || isAndroidChrome ? deviceOriginalWidth * devicePixelRatio : deviceOriginalWidth,
                                deviceOriginalHeight: isApple || isAndroidChrome ? deviceOriginalHeight * devicePixelRatio : deviceOriginalHeight,
                                deviceWidth: deviceWidth,
                                deviceHeight: deviceHeight,
                                deviceToolbarHeight: deviceToolbarHeight,
                                width: startWidth,
                                height: startHeight,
                                orientation: deviceOrientation
                            }
                        }
                    }
                }]
            },
                webEnvScreen = messagePackage.sessions[0].clientEnvironment.webEnvironment.screen;

            webEnvScreen.orientationMode = core.utils.getOrientationMode(webEnvScreen.orientation);
            /*
            if (true) { // Add usability to config settings
                //messagePackage.domainId = "<<TODO domainId>>"; This was used to send to correct posting url, no longer needed. Followup with Chris. Checked with Joe.
                //messagePackage.samplingRate = "<<TODO samplingRate>>"; This is no longer needed. We will not focus on sampling for this release of 8.6.
            }
            */
            return messagePackage;
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SerializerService provides the ability to serialize
 * data into one or more string formats.
 * @exports serializerService
 */

/*global TLT:true, window: true */
/*global console: false */

/**
 * @name serializerService
 * @namespace
 */
TLT.addService("serializer", function (core) {
    "use strict";

    /**
     * JSON serializer. If possible it uses JSON.stringify method, but
     * for older browsers it provides minimalistic implementaction of
     * custom serializer (limitations: does not detect circular
     * dependencies, does not serialize date objects and does not
     * validate names of object fields).
     * @private
     * @function
     * @name serializerService-serializeToJSON
     * @param {Any} obj - any value
     * @returns {string} serialized string
     */
    function serializeToJSON(obj) {
        var str,
            key,
            len = 0;
        if (typeof obj !== "object" || obj === null) {
            switch (typeof obj) {
            case "function":
            case "undefined":
                return "null";
            case "string":
                return '"' + obj.replace(/\"/g, '\\"') + '"';
            default:
                return String(obj);
            }
        } else if (Object.prototype.toString.call(obj) === "[object Array]") {
            str = "[";
            for (key = 0, len = obj.length; key < len; key += 1) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str += serializeToJSON(obj[key]) + ",";
                }
            }
        } else {
            str = "{";
            for (key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    str = str.concat('"', key, '":', serializeToJSON(obj[key]), ",");
                    len += 1;
                }
            }
        }
        if (len > 0) {
            str = str.substring(0, str.length - 1);
        }
        str += String.fromCharCode(str.charCodeAt(0) + 2);
        return str;
    }


    /**
     * Serializer / Parser implementations
     * @type {Object}
     */
    var configService = core.getService("config"),
        serialize = {},
        parse = {},
        defaultSerializers = {
            json: (function () {
                if (typeof window.JSON !== "undefined") {
                    return {
                        serialize: window.JSON.stringify,
                        parse: window.JSON.parse
                    };
                }

                return {
                    serialize: serializeToJSON,
                    // TODO: find a better way than using eval
                    parse: function (data) {
                        return eval("(" + data + ")");
                    }
                };
            }())
        },
        updateConfig = null,
        isInitialized = false;

    function addObjectIfExist(paths, rootObj, propertyName) {
        var i,
            len,
            obj;

        paths = paths || [];
        for (i = 0, len = paths.length; i < len; i += 1) {
            obj = paths[i];
            if (typeof obj === "string") {
                obj = core.utils.access(obj);
            }
            if (typeof obj === "function") {
                rootObj[propertyName] = obj;
                break;
            }
        }
    }
	function checkParserAndSerializer() {
		var isParserAndSerializerInvalid;
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
			isParserAndSerializerInvalid = true;
        } else {
			if (typeof parse.json('{"foo": "bar"}') === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = parse.json('{"foo": "bar"}').foo !== "bar";
			}
			if (typeof parse.json("[1, 2]") === "undefined") {
				isParserAndSerializerInvalid = true;
			} else {
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1, 2]")[0] !== 1;
				isParserAndSerializerInvalid = isParserAndSerializerInvalid || parse.json("[1,2]")[1] !== 2;
			}
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json({"foo": "bar"}) !== '{"foo":"bar"}';
			isParserAndSerializerInvalid = isParserAndSerializerInvalid || serialize.json([1, 2]) !== "[1,2]";
		}
		return isParserAndSerializerInvalid;
	}
    function initSerializerService(config) {
        var format;
        for (format in config) {
            if (config.hasOwnProperty(format)) {
                addObjectIfExist(config[format].stringifiers, serialize, format);
                addObjectIfExist(config[format].parsers, parse, format);
            }
        }

        // use default JSON parser/serializer if possible
        if (!(config.json && config.json.hasOwnProperty("defaultToBuiltin")) || config.json.defaultToBuiltin === true) {
            serialize.json = serialize.json || defaultSerializers.json.serialize;
            parse.json = parse.json || defaultSerializers.json.parse;
        }

        //sanity check
        if (typeof serialize.json !== "function" || typeof parse.json !== "function") {
            core.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue.");
        }
		if (checkParserAndSerializer()) {
			if (typeof serialize.json !== "function" && typeof parse.json !== "function") {
				console.log("parse.json() and serialize.json() are not a functions.");
			} else if (typeof serialize.json !== "function") {
				console.log("serialize.json() is not a function.");
			} else if (typeof parse.json !== "function") {
				console.log("parse.json() is not a function.");
			} else {
				if (typeof parse.json('{"foo": "bar"}') === "undefined") {
					console.log("parse.json('{'foo': 'bar'}') is undefined");
				} else if (parse.json('{"foo":"bar"}').foo !== "bar") {
					console.log('Parsing of JSON object is failing.');
				}
				if (typeof parse.json("[1, 2]") === "undefined") {
					console.log("parse.json('[1, 2]') is undefined");
				} else if (parse.json("[1,2]")[0] !== 1 || parse.json("[1,2]")[1] !== 2) {
					console.log('Parsing of JSON array is failing.');
				}
				if (serialize.json({"foo": "bar"}) !== '{"foo":"bar"}') {
					console.log('Stringification of JSON object is failing.');
				}
				if (serialize.json([1, 2]) !== "[1,2]") {
					console.log('Stringification of JSON array is failing.');
				}
			}
			core.fail("JSON stringification and parsing are not working as expected");
		}
        if (configService.subscribe) {
            configService.subscribe("configupdated", updateConfig);
        }

        isInitialized = true;
    }


    function destroy() {
        serialize = {};
        parse = {};

        configService.unsubscribe("configupdated", updateConfig);

        isInitialized = false;
    }

    updateConfig = function () {
        configService = core.getService("config");
        // TODO: reinit only if config changed. Verify initSerializerService is idempotent
        initSerializerService(configService.getServiceConfig("serializer") || {});
    };

    /**
     * @scope serializerService
     */
    return {
        // Expose private functions for unit testing
        updateConfig: updateConfig,
        init: function () {
            if (!isInitialized) {
                initSerializerService(configService.getServiceConfig("serializer") || {});
            } else {
                core.utils.clog("Attempt to initialize service which has been already initialized(serializerService)");
            }
        },

        destroy: function () {
            destroy();
        },

        /**
         * Parses a string into a JavaScript object.
         * @param  {String} data The string to parse.
         * @param  {String} [type="json"] The format of the data.
         * @return {Object}      An object representing the string data.
         */
        parse: function (data, type) {
            type = type || "json";
            if (typeof parse[type] !== "function") {
                core.utils.clog("Unsupported type of data in parse method of serializer service: " + type);
            }
            return parse[type](data);
        },

        /**
         * Serializes object data into a string using the format specified.
         * @param  {Object} data The data to serialize.
         * @param  {String} [type="json"] The format to serialize the data into.
         * @return {String}      A string containing the serialization of the data.
         */
        serialize: function (data, type) {
            type = type || "json";
            if (typeof serialize[type] !== "function") {
                core.utils.clog("Unsupported type of data in serializer method of serializer service: " + type);
            }
            return serialize[type](data);
        }
    };

});
/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Overstat module implements the logic for collecting
 * data for cxOverstat. The current uses are for the Hover Event and
 * Hover To Click event.
 * @exports overstat
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name overstat
     * @namespace
     */
    TLT.addModule("overstat", function (context) {
        "use strict";

        var tlTypes = {
            "input:radio": "radioButton",
            "input:checkbox": "checkBox",
            "input:text": "textBox",
            "input:password": "textBox",
            "input:file": "fileInput",
            "input:button": "button",
            "input:submit": "submitButton",
            "input:reset": "resetButton",
            "input:image": "image",
            "input:color": "color",
            "input:date": "date",
            "input:datetime": "datetime",
            "input:datetime-local": "datetime-local",
            "input:number": "number",
            "input:email": "email",
            "input:tel": "tel",
            "input:search": "search",
            "input:url": "url",
            "input:time": "time",
            "input:week": "week",
            "input:month": "month",
            "textarea:": "textBox",
            "select:": "selectList",
            "button:": "button",
            "a:": "link"
        },

            eventMap = {},
            configDefaults = { "UPDATE_INTERVAL" : 250,
                                "HOVER_THRESHOLD_MIN" : 1000,
                                "HOVER_THRESHOLD_MAX" : 2 * 60 * 1000,
                                "GRIDCELL_MAX_X" : 10,
                                "GRIDCELL_MAX_Y" : 10,
                                "GRIDCELL_MIN_WIDTH" : 20,
                                "GRIDCELL_MIN_HEIGHT" : 20
                };

        /**
         * Used to test and get value from an object.
         * @private
         * @function
         * @name replay-getValue
         * @param {object} parentObj An object you want to get a value from.
         * @param {string} propertyAsStr A string that represents dot notation to get a value from object.
         * @return {object} If object is found, if not then null will be returned.
         */
        function getValue(parentObj, propertyAsStr) {
            var i,
                properties;

            // Sanity check
            if (!parentObj || typeof parentObj !== "object") {
                return null;
            }

            properties = propertyAsStr.split(".");
            for (i = 0; i < properties.length; i += 1) {
                if ((typeof parentObj === "undefined") || (parentObj[properties[i]] === null)) {
                    return null;
                }
                parentObj = parentObj[properties[i]];
            }
            return parentObj;
        }

        function getConfigValue(key) {
            var overstatConfig = context.getConfig() || {},
                value = overstatConfig[key];
            return typeof value === "number" ? value : configDefaults[key];
        }

        function postUIEvent(hoverEvent, options) {
            var tagName = getValue(hoverEvent, "webEvent.target.element.tagName") || "",
                type = tagName.toLowerCase() === "input" ? getValue(hoverEvent, "webEvent.target.element.type") : "",
                tlType = tlTypes[tagName.toLowerCase() + ":" + type] || tagName,

                uiEvent = {
                    type: 9,
                    event: {
                        hoverDuration: hoverEvent.hoverDuration,
                        hoverToClick: getValue(options, "hoverToClick")
                    },
                    target: {
                        id: getValue(hoverEvent, "webEvent.target.id") || "",
                        idType: getValue(hoverEvent, "webEvent.target.idType") || "",
                        name: getValue(hoverEvent, "webEvent.target.name") || "",
                        tlType: tlType,
                        type: tagName,
                        subType: type,
                        position: {
                            width: getValue(hoverEvent, "webEvent.target.element.offsetWidth") || 0,
                            height: getValue(hoverEvent, "webEvent.target.element.offsetHeight") || 0,
                            relXY: hoverEvent.gridX + "," + hoverEvent.gridY
                        }
                    }
                };

                // if id is null or empty, what are we firing on? it can't be replayed anyway
            if ((typeof uiEvent.target.id) === undefined || uiEvent.target.id === "") {
                return;
            }

            context.utils.clog("Overstat - posted hover event");
            context.utils.clog(uiEvent);
            context.post(uiEvent);
        }

        function stopNode(node) {
            if (node && node.element) { node = node.element; }
            return !node || node === document.body || node === document.html || node === document;
        }

        function getParent(node) {
            if (!node) { return null; }
            return node.element ? node.element.parentNode : node.parentNode;
        }

        function getOffsetParent(node) {
            if (!node) { return null; }
            var parent = node.element ? node.element.offsetParent : node.offsetParent;
            return parent || getParent(node);
        }

        /*
         * for when mouseout is called - if you have moved over a child element, mouseout is fired for the parent element
         * @private
         * @function
         * @name overstat-isChildOf
         * @return {boolean} Returns whether node is a child of root
         */
        function isChildOf(root, node) {
            if (!node || node === root) { return false; }
            node = getParent(node);

            while (!stopNode(node)) {
                if (node === root) { return true; }
                node = getParent(node);
            }

            return false;
        }

        function getNativeEvent(e) {
            if (e.nativeEvent) { e = e.nativeEvent; }
            return e;
        }

        function getNativeTarget(e) {
            return getNativeEvent(e).target;
        }

        function getNativeNode(node) {
            if (!node) { return null; }
            return node.element || node;
        }

        function getNodeType(node) {
            if (!node) { return -1; }
            if (node.element) { node = node.element; }
            return node.nodeType || -1;
        }

        function getNodeTagName(node) {
            if (!node) { return ""; }
            if (node.element) { node = node.element; }
            return node.tagName ? node.tagName.toUpperCase() : "";
        }

        function getNodeElement(node) {
            if (node && node.element) { node = node.element; }
            return node;
        }

        function stopEventPropagation(e) {
            if (!e) { return; }
            if (e.nativeEvent) { e = e.nativeEvent; }

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.cancelBubble) {
                e.cancelBubble();
            }
        }

        function ignoreNode(node) {
            var tagName = getNodeTagName(node);
            return getNodeType(node) !== 1 || tagName === "TR" || tagName === "TBODY" || tagName === "THEAD";
        }

        /**
         * Generates an XPath for a given node, stub method until the real one is available
         * @function
         */
        function getXPathFromNode(node) {
            if (!node) { return ""; }
            if (node.xPath) { return node.xPath; }
            node = getNativeNode(node);
            return context.getXPathFromNode(node);
        }

        /*
         * replacement for lang.hitch(), setTimeout loses all scope
         * @private
         * @function
         * @name overstat-callHoverEventMethod
         * @return {object} Returns the value of the called method
         */
        function callHoverEventMethod(key, methodName) {
            var hEvent = eventMap[key];
            if (hEvent && hEvent[methodName]) { return hEvent[methodName](); }
        }

        function HoverEvent(dm, gx, gy, webEvent) {
            this.xPath = dm !== null ? getXPathFromNode(dm) : "";
            this.domNode = dm;
            this.hoverDuration = 0;
            this.hoverUpdateTime = 0;
            this.gridX = Math.max(gx, 0);
            this.gridY = Math.max(gy, 0);
            this.parentKey = "";
            this.updateTimer = -1;
            this.disposed = false;
            this.childKeys = {};
            this.webEvent = webEvent;

            /*
             * @public
             * @function
             * @name overstat-HoverEvent.getKey
             * @return {string} Returns the string unique key of this event
             */
            this.getKey = function () {
                return this.xPath + ":" + this.gridX + "," + this.gridY;
            };

            /*
             * update hoverTime, set timer to update again
             * @public
             * @function
             * @name overstat-HoverEvent.update
             */
            this.update = function () {
                var curTime = new Date().getTime(),
                    key = this.getKey();

                if (this.hoverUpdateTime !== 0) {
                    this.hoverDuration += curTime - this.hoverUpdateTime;
                }

                this.hoverUpdateTime = curTime;

                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(function () { callHoverEventMethod(key, "update"); }, getConfigValue("UPDATE_INTERVAL"));
            };

            /*
             * leaveClone is true if you want to get rid of an event but leave a new one in it's place.
             * usually this will happen due to a click, where the hover ends, but you want a new hover to
             * begin in the same place
             * @public
             * @function
             * @name overstat-HoverEvent.dispose
             */
            this.dispose = function (leaveClone) {
                clearTimeout(this.updateTimer);
                delete eventMap[this.getKey()];
                this.disposed = true;

                if (leaveClone) {
                    var cloneEvt = this.clone();
                    eventMap[cloneEvt.getKey()] = cloneEvt;
                    cloneEvt.update();
                }
            };

            /*
             * clear update timer, add to hover events queue if threshold is reached, dispose in any case
             * @public
             * @function
             * @name overstat-HoverEvent.process
             * @return {boolean} Returns whether or not the event met the threshold requirements and was added to the queue
             */
            this.process = function (wasClicked) {
                clearTimeout(this.updateTimer);
                if (this.disposed) { return false; }

                var addedToQueue = false,
                    hEvent = this,
                    key = null;
                if (this.hoverDuration >= getConfigValue("HOVER_THRESHOLD_MIN")) {
                    this.hoverDuration = Math.min(this.hoverDuration, getConfigValue("HOVER_THRESHOLD_MAX"));
                    // add to ui event queue here
                    addedToQueue = true;
                    postUIEvent(this, { hoverToClick : !!wasClicked });

                    while (typeof hEvent !== "undefined") {
                        hEvent.dispose(wasClicked);
                        hEvent = eventMap[hEvent.parentKey];
                    }
                } else {
                    this.dispose(wasClicked);
                }

                return addedToQueue;
            };

            /*
             * return a fresh copy of this event
             * @public
             * @function
             * @name overstat-HoverEvent.clone
             * @return {HoverTest} Returns a copy of this event with a reset hover time
             */
            this.clone = function () {
                var cloneEvent = new HoverEvent(this.domNode, this.gridX, this.gridY);
                cloneEvent.parentKey = this.parentKey;

                return cloneEvent;
            };
        }

        function createHoverEvent(node, x, y, webEvt) {
            return new HoverEvent(node, x, y, webEvt);
        }

        /*
         * get element offset according to the top left of the document
         * @private
         * @function
         * @name overstat-calculateNodeOffset
         * @return {object} Returns an object with x and y offsets
         */
        function calculateNodeOffset(node) {
            if (node && node.position) { return { x: node.position.x, y: node.position.y }; }
            node = getNodeElement(node);
            var offsetX = node.offsetLeft,
                offsetY = node.offsetTop,
                lastOffsetX = offsetX,
                lastOffsetY = offsetY,
                offsetDiffX = 0,
                offsetDiffY = 0,
                curNode = getOffsetParent(node);

            while (curNode) {
                if (stopNode(curNode)) { break; }

                offsetDiffX = curNode.offsetLeft - (curNode.scrollLeft || 0);
                offsetDiffY = curNode.offsetTop - (curNode.scrollTop || 0);

                if (offsetDiffX !== lastOffsetX || offsetDiffY !== lastOffsetY) {
                    offsetX += offsetDiffX;
                    offsetY += offsetDiffY;

                    lastOffsetX = offsetDiffX;
                    lastOffsetY = offsetDiffY;
                }

                curNode = getOffsetParent(curNode);
            }

            if (isNaN(offsetX)) { offsetX = 0; }
            if (isNaN(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * calculate position relative to top left corner of element
         * @private
         * @function
         * @name overstat-calculateRelativeCursorPos
         * @return {object} Returns an object with x and y offsets
         */
        function calculateRelativeCursorPos(node, cursorX, cursorY) {
            node = getNodeElement(node);
            var nodeOffset = calculateNodeOffset(node),
                offsetX = cursorX - nodeOffset.x,
                offsetY = cursorY - nodeOffset.y;

            if (!isFinite(offsetX)) { offsetX = 0; }
            if (!isFinite(offsetY)) { offsetY = 0; }
            return { x: offsetX, y: offsetY };
        }

        /*
         * determine grid cell dimensions based on the constants
         * @private
         * @function
         * @name overstat-calculateGridCell
         * @return {object} Returns the x and y grid location
         */
        function calculateGridCell(node, offsetX, offsetY) {
            node = getNodeElement(node);
            var cellWidth = node.offsetWidth > 0 ? Math.max(node.offsetWidth / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_WIDTH")) : getConfigValue("GRIDCELL_MIN_WIDTH"),
                cellHeight = node.offsetHeight > 0 ? Math.max(node.offsetHeight / getConfigValue("GRIDCELL_MAX_X"), getConfigValue("GRIDCELL_MIN_HEIGHT")) : getConfigValue("GRIDCELL_MIN_HEIGHT"),

                cellX = Math.floor(offsetX / cellWidth),
                cellY = Math.floor(offsetY / cellHeight);

            if (!isFinite(cellX)) { cellX = 0; }
            if (!isFinite(cellY)) { cellY = 0; }
            return { x: cellX, y: cellY };
        }

        /*
         * called when a hover event fires - processes all unrelated hover events from the queue.
         * events are related if they are the calling event, or any parent events
         * @private
         * @function
         * @name overstat-cleanupHoverEvents
         */
        function cleanupHoverEvents(curEvent) {
            var hEvent = curEvent,
                curKey = curEvent.getKey(),
                allowedKeyMap = {},
                key = null,
                childKey = null;

            allowedKeyMap[curKey] = true;

            while (typeof hEvent !== "undefined") {
                allowedKeyMap[hEvent.parentKey] = true;
                if (hEvent.parentKey === "" || hEvent.parentKey === hEvent.getKey()) {
                    break;
                }

                hEvent = eventMap[hEvent.parentKey];
            }

            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key) && !allowedKeyMap[key]) {
                    hEvent = eventMap[key];
                    if (hEvent) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * similar to cleanupHoverEvents, this will process all events within a domNode (fired on mouseout)
         * @private
         * @function
         * @name overstat-processEventsByDomNode
         */
        function processEventsByDomNode(eventNode, keyToIgnore) {
            var hEvent = null,
                key = null;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    if (hEvent.domNode === eventNode && hEvent.getKey() !== keyToIgnore) {
                        hEvent.process();
                    }
                }
            }
        }

        /*
         * 1) determine element and grid position for event
         * 2) find existing matching event if possible
         * 3) update event hover time
         * 4) bubble to parent node, for linking purposes
         * within the UI SDK framework, this should be called for each node in the heirarchy (box model)
         * going top down. so the parent (if the calculation is correct) should already exist, and have
         * it's own parent link, which helps during cleanupHoverEvents
         * @private
         * @function
         * @name overstat-hoverHandler
         * @return {HoverEvent} Returns the relevant HoverEvent object (either found or created)
         */
        function hoverHandler(e, node, isParent) {
            if (!node) { node = e.target; }
            if (stopNode(node)) { return null; }
            if (context.utils.isiOS || context.utils.isAndroid) { return null; }

            var rPos, gPos, hEvent, key, parentKey, parentEvent, offsetParent;

            if (!ignoreNode(node)) {
                rPos = calculateRelativeCursorPos(node, e.position.x, e.position.y);
                gPos = calculateGridCell(node, rPos.x, rPos.y);
                hEvent = new HoverEvent(node, gPos.x, gPos.y, e);
                key = hEvent.getKey();

                if (eventMap[key]) {
                    hEvent = eventMap[key];
                } else {
                    eventMap[key] = hEvent;
                }

                hEvent.update();

                // link parent, but in the case that it refers to itself (sometimes with frames) make sure the parentKey
                // is not the same as the current key
                if (!isParent) {
                    offsetParent = getOffsetParent(node);
                    if (offsetParent) {
                        parentEvent = hoverHandler(e, offsetParent, true);
                        if (parentEvent !== null) {
                            parentKey = parentEvent.getKey();
                            key = hEvent.getKey();
                            if (key !== parentKey) {
                                hEvent.parentKey = parentKey;
                            }
                        }
                    }

                    cleanupHoverEvents(hEvent);
                }
            } else {
                hEvent = hoverHandler(e, getOffsetParent(node), isParent);
            }

            return hEvent;
        }

        /*
         * process all events related to the event target, as hovering stops when leaving the element
         * @private
         * @function
         * @name overstat-leaveHandler
         */
        function leaveHandler(e) {
            e = getNativeEvent(e);
            if (isChildOf(e.target, e.relatedTarget)) {
                return;
            }

            processEventsByDomNode(e.target);
        }

        /*
         * on click, resolve current hover events, and reset hover count
         * @private
         * @function
         * @name overstat-clickHandler
         */
        function clickHandler(e) {
            var hEvent = null, key;
            for (key in eventMap) {
                if (eventMap.hasOwnProperty(key)) {
                    hEvent = eventMap[key];
                    hEvent.process(true);
                }
            }
        }

        /*
         * switches on window event type and routes it appropriately
         * @private
         * @function
         * @name overstat-handleEvent
         */
        function handleEvent(e) {
            var targetId = getValue(e, "target.id");

            // Sanity check
            if (!targetId) {
                return;
            }

            switch (e.type) {
            case "mousemove":
                hoverHandler(e);
                break;
            case "mouseout":
                leaveHandler(e);
                break;
            case "click":
                clickHandler(e);
                break;
            }
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {

            // Expose for unit testing

            DEBUG: 1,

            // Properties

            // Functions
            postUIEvent: postUIEvent,
            getValue: getValue,

            /**
             * Initialize the overstat module.
             */
            init: function () {
            },

            /**
             * Terminate the overstat module.
             */
            destroy: function () {
                var key, i;
                for (key in eventMap) {
                    if (eventMap.hasOwnProperty(key)) {
                        eventMap[key].dispose();
                        delete eventMap[key];
                    }
                }
            },

            /**
             * Handle events subscribed by the overstat module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                handleEvent(event);
            },

            /**
             * Handle system messages subscribed by the overstat module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            },

			createHoverEvent: createHoverEvent,
			cleanupHoverEvents: cleanupHoverEvents,
            eventMap: eventMap
        };
    });  // End of TLT.addModule
} else {

    // Only throw an error in DEBUG mode.
    throw "Overstat module included but TLT is not defined!!!";

}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Performance module implements the logic for monitoring and
 * reporting performance data such as the W3C Navigation Timing.
 * @exports performance
 */

/*global TLT:true */

// Sanity check
if (TLT && typeof TLT.addModule === "function") {
    /**
     * @name performance
     * @namespace
     */
    TLT.addModule("performance", function (context) {
        "use strict";

        var moduleState = {
                loadReceived: false,
                unloadReceived: false,
                perfEventSent: false
            },
            calculatedRenderTime = 0;


        /**
         * Returns true if the property is filtered out. The property is considered
         * to be filtered out if it exists in the filter object with a value of true.
         * @private
         * @function
         * @name performance-isFiltered
         * @param {string} prop The property name to be tested.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {boolean} true if the property is filtered out, false otherwise.
         */
        function isFiltered(prop, filter) {
            // Sanity check
            if (typeof prop !== "string") {
                return false;
            }

            // If there is no filter object then the property is not filtered out.
            if (!filter || typeof filter !== "object") {
                return false;
            }

            return (filter[prop] === true);
        }

        /**
         * Returns the normalized timing object. Normalized values are offsets measured
         * from the "navigationStart" timestamp which serves as the epoch. Also applies
         * the filter.
         * @private
         * @function
         * @name performance-parseTiming
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @param {object} [filter] An object that contains property names and their
         * associated boolean value. A property marked true will be filtered out.
         * @return {object} The normalized timing properties.
         */
        function parseTiming(timing, filter) {
            var epoch = 0,
                normalizedTiming = {},
                prop = "",
                value = 0;

            // Sanity checks
            if (!timing || typeof timing !== "object" || !timing.navigationStart) {
                return {};
            }

            epoch = timing.navigationStart;
            for (prop in timing) {
                // IE_COMPAT, FF_COMPAT: timing.hasOwnProperty(prop) returns false for
                // performance timing members in IE 9 and Firefox 14.0.1.

                // IE_COMPAT: timing.hasOwnProperty does not exist in IE8 and lower for
                // host objects. Legacy IE does not support hasOwnProperty on hosted objects.
                if (Object.prototype.hasOwnProperty.call(timing, prop) || typeof timing[prop] === "number") {
                    if (!isFiltered(prop, filter)) {
                        value = timing[prop];
                        if (typeof value === "number" && value && prop !== "navigationStart") {
                            normalizedTiming[prop] = value - epoch;
                        } else {
                            normalizedTiming[prop] = value;
                        }
                    }
                }
            }

            return normalizedTiming;
        }

        /**
         * Calculates the render time from the given timing object.
         * @private
         * @function
         * @name performance-getRenderTime
         * @param {object} timing An object implementing the W3C PerformanceTiming
         * interface.
         * @return {integer} The calculated render time or 0.
         */
        function getRenderTime(timing) {
            var renderTime = 0,
                startTime,
                endTime,
                utils = context.utils;

            if (timing) {
                // Use the lesser of domLoading or responseEnd as the start of render, see data in CS-8915
                startTime = (timing.responseEnd > 0 && timing.responseEnd < timing.domLoading) ? timing.responseEnd : timing.domLoading;
                endTime = timing.loadEventStart;
                if (utils.isNumeric(startTime) && utils.isNumeric(endTime) && endTime > startTime) {
                    renderTime = endTime - startTime;
                }
            }

            return renderTime;
        }

        /**
         * Calculates the render time by measuring the difference between when the
         * library core was loaded and when the page load event occurs.
         * @private
         * @function
         * @name performance-processLoadEvent
         * @param  {Object} event The normalized data extracted from a browser event object.
         */
        function processLoadEvent(event) {
            var startTime = context.getStartTime();
            if (event.timestamp > startTime && !calculatedRenderTime) {
                // Calculate the render time
                calculatedRenderTime = event.timestamp - startTime;
            }
        }

        /**
         * Posts the performance event.
         * @private
         * @function
         * @name performance-postPerformanceEvent
         * @param {object} window The DOM window
         */
        function postPerformanceEvent(window) {
            var config = context.getConfig() || {},
                navType = "UNKNOWN",
                queueEvent = {
                    type: 7,
                    performance: {}
                },
                navigation,
                performance,
                timing;

            // Sanity checks
            if (!window || moduleState.perfEventSent) {
                return;
            }

            performance = window.performance || {};
            timing = performance.timing;
            navigation = performance.navigation;

            if (timing) {
                queueEvent.performance.timing = parseTiming(timing, config.filter);
                queueEvent.performance.timing.renderTime = getRenderTime(timing);
            } else if (config.calculateRenderTime) {
                queueEvent.performance.timing = {
                    renderTime: calculatedRenderTime,
                    calculated: true
                };
            } else {
                // Nothing to report.
                return;
            }

            // Do not include renderTime if it is over the threshold.
            if (config.renderTimeThreshold && queueEvent.performance.timing.renderTime > config.renderTimeThreshold) {
                queueEvent.performance.timing.invalidRenderTime = queueEvent.performance.timing.renderTime;
                delete queueEvent.performance.timing.renderTime;
            }

            if (navigation) {
                switch (navigation.type) {
                case 0:
                    navType = "NAVIGATE";
                    break;
                case 1:
                    navType = "RELOAD";
                    break;
                case 2:
                    navType = "BACKFORWARD";
                    break;
                default:
                    navType = "UNKNOWN";
                    break;
                }
                queueEvent.performance.navigation = {
                    type: navType,
                    redirectCount: navigation.redirectCount
                };
            }

            // Invoke the context API to post this event
            context.post(queueEvent);
            // TODO: Remove all instances of perfEventSent flag from this method and localize it's use in the caller?
            moduleState.perfEventSent = true;
        }

        // Module interface.
        /**
         * @scope performance
         */
        return {

            // Expose private functions for unit testing
            isFiltered: isFiltered,
            parseTiming: parseTiming,
            getRenderTime: getRenderTime,
            postPerformanceEvent: postPerformanceEvent,

            /**
             * Initialize the performance module.
             */
            init: function () {
                // TODO: Possibly add check to see if navigation timing interface is supported. If not, short circuit the implementation below.
            },

            /**
             * Terminate the performance module.
             */
            destroy: function () {

            },

            /**
             * Handle events subscribed by the performance module.
             * @param  {Object} event The normalized data extracted from a browser event object.
             */
            onevent: function (event) {
                // Sanity check
                if (typeof event !== "object" || !event.type) {
                    return;
                }

                switch (event.type) {
                case "load":
                    moduleState.loadReceived = true;
                    processLoadEvent(event);
                    break;
                case "unload":
                    moduleState.unloadReceived = true;
                    // Force the performance data to be posted (if it hasn't been done already.)
                    if (!moduleState.perfEventSent) {
                        // TODO: Directly referencing the global window but may want to sandbox this.
                        postPerformanceEvent(window);
                    }
                    break;
                default:
                    break;
                }
            },

            /**
             * Handle system messages subscribed by the performance module.
             * @param  {Object} msg An object containing the message information.
             */
            onmessage: function (msg) {

            }
        };
    });  // End of TLT.addModule
} else {

    // Only throw an error in DEBUG mode.
    throw "Performance module included but TLT is not defined!!!";

}

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The Replay module implements the logic for monitoring and
 * reporting user interaction data used for replay and usability.
 * @exports replay
 */

/*global TLT:true */

// Sanity check
TLT.addModule("replay", function (context) {
    "use strict";

    var tlTypes = {
    // Keep these sorted for readability.
            "a:": "link",
            "button:button": "button",
            "button:submit": "button",
            "input:button": "button",
            "input:checkbox": "checkBox",
            "input:color": "colorPicker",
            "input:date": "datePicker",
            "input:datetime": "datetimePicker",
            "input:datetime-local": "datetime-local",
            "input:email": "emailInput",
            "input:file": "fileInput",
            "input:image": "image",
            "input:month": "month",
            "input:number": "numberPicker",
            "input:password": "textBox",
            "input:radio": "radioButton",
            "input:range": "slider",
            "input:reset": "resetButton",
            "input:search": "searchBox",
            "input:submit": "submitButton",
            "input:tel": "tel",
            "input:text": "textBox",
            "input:time": "timePicker",
            "input:url": "urlBox",
            "input:week": "week",
            "select:": "selectList",
            "select:select-one": "selectList",
            "textarea:": "textBox",
            "textarea:textarea": "textBox"
        },
        utils = context.utils,
        currOrientation = window.orientation || 0,
        savedTouch = {
            scale: 0,
            timestamp: 0
        },
        pastEvents = {},
        prevHash = window.location.hash,
        lastEventId = null,
        tmpQueue = [],
        eventCounter = 0,
        curClientState = null,
        pastClientState = null,
        errorCount = 0,
        visitOrder = "",
        lastVisit = "",
        pageLoadTime = (new Date()).getTime(),
        pageDwellTime = 0,
        prevWebEvent = null,
        viewEventStart = null,
        viewTimeStart = null,
        scrollViewStart = null,
        scrollViewEnd = null,
        nextScrollViewStart = null,
        viewPortXStart = 0,
        viewPortYStart = 0,
        inBetweenEvtsTimer = null,
        lastFocusEvent = { inFocus: false },
        lastClickEvent = null,
        //TODO move these to a global section due to they might be used elsewhere
        isApple = utils.isiOS,
        isAndroidChrome = navigator.userAgent.indexOf("Chrome") > -1 && utils.isAndroid,
        devicePixelRatio = window.devicePixelRatio || 1,
        deviceOriginalWidth = (window.screen ? window.screen.width : 0),
        deviceOriginalHeight = (window.screen ? window.screen.height : 0),
        deviceToolbarHeight = (window.screen ? window.screen.height - window.screen.availHeight : 0),
        config = context.getConfig(),
        deviceScale = 1,
        previousDeviceScale = 1,
        extendGetItem;

    /**
     * Returns true if the click event changes the target state or is otherwise
     * relevant for the target.
     * @private
     * @param {WebEvent.target} target Webevent target
     * @return {boolean} true if the click event is relevant for the target, false otherwise.
     */
    function isTargetClickable(target) {
        var clickable = false,
            clickableInputTypes = "|button|image|submit|reset|checkbox|radio|",
            subType = null;

        if (typeof target !== "object" || !target.type) {
            return clickable;
        }

        switch (target.type) {
        case "INPUT":
            // Clicks are relevant for button type inputs only.
            subType = "|" + (target.subType || "") + "|";
            if (clickableInputTypes.indexOf(subType.toLowerCase()) === -1) {
                clickable = false;
            } else {
                clickable = true;
            }
            break;
        case "SELECT":
        case "TEXTAREA":
            clickable = false;
            break;
        default:
            // By default, clicks are relevant for all targets.
            clickable = true;
            break;
        }

        return clickable;
    }

    function parentElements(node) {
        var parents = [];
        node = node.parentNode;
        while (node) {
            parents.push(node);
            node = node.parentNode;
        }
        return parents;
    }

    function getParentLink(parents) {
        return context.utils.some(parents, function (node) {
            // Either links or buttons could have content
            if (node.tagName === "A" || node.tagName === "BUTTON") {
                return node;
            }
            return null;
        });
    }

    /**
     * Get the normalized tlEvent from the underlying DOM event and target.
     * @private
     * @param {object} webEvent The normalized webEvent with event and target (control.)
     * @return {string} The normalized value for the tlEvent as per the JSON Logging Data Format.
     */
    function getTlEvent(webEvent) {
        var tlEvent = webEvent.type,
            target = webEvent.target;

        if (typeof tlEvent === "string") {
            tlEvent = tlEvent.toLowerCase();
        } else {
            tlEvent = "unknown";
        }

        if (tlEvent === "blur") {
            tlEvent = "focusout";
        }

        if (tlEvent === "change") {
            if (target.type === "INPUT") {
                switch (target.subType) {
                case "text":
                case "date":
                case "time":
                    // tlEvent is textChange, dateChange or timeChange respectively.
                    tlEvent = target.subType + "Change";
                    break;
                default:
                    // For all other input fields the tlEvent is valueChange.
                    tlEvent = "valueChange";
                    break;
                }
            } else if (target.type === "TEXTAREA") {
                tlEvent = "textChange";
            } else {
                tlEvent = "valueChange";
            }
        }

        return tlEvent;
    }

    /**
     * Invoke the core API to take the DOM capture. If a delay is specified, then
     * schedule a DOM capture.
     * @private
     * @param {DOMElement} root Root element from which the DOM capture snapshot should be taken.
     * @param {object} [config] Configuration options for the capture.
     * @param {Number} [delay] Milliseconds after which to take the DOM snapshot.
     * @return {string} Returns the unique DOM Capture id.
     */
    function scheduleDOMCapture(root, config, delay) {
        var dcid = null;
        // Sanity check
        if (!root) {
            return dcid;
        }
        config = config || {};
        if (delay) {
            dcid = "dcid-" + context.utils.getSerialNumber() + "." + (new Date()).getTime() + "s";
            window.setTimeout(function () {
                config.dcid = dcid;
                context.performDOMCapture(root, config);
            }, delay);
        } else {
            delete config.dcid;
            dcid = context.performDOMCapture(root, config);
        }
        return dcid;
    }

    /**
     * Check the DOM capture rules to see if DOM capture should be triggered for this combination
     * of event, target, screenview as applicable.
     * @private
     * @param {String} eventType Name of the event e.g. click, change, load, unload
     * @param {DOMElement} target The target element of the event. Some events (such as load/unload) may not
     * have a target in which case it would be null.
     * @param {String} [screenviewName] The screenview name for load and unload events.
     * @returns {String} Returns the unique DOM Capture id or null.
     */
    function addDOMCapture(eventType, target, screenviewName) {
        var i,
            capture = false,
            captureConfig,
            dcEnabled = false,
            dcTrigger,
            dcTriggerList,
            dcid = null,
            delay = 0,
            len,
            replayConfig;

        // Sanity check
        if (!eventType || (!target && !screenviewName)) {
            return dcid;
        }
        if (!target && !(eventType === "load" || eventType === "unload")) {
            return dcid;
        }

        replayConfig = context.getConfig() || {};
        dcEnabled = utils.getValue(replayConfig, "domCapture.enabled", false);
        if (!dcEnabled || context.utils.isLegacyIE) {
            // DOM Capture is not supported for IE8 and below
            return dcid;
        }

        dcTriggerList = utils.getValue(replayConfig, "domCapture.triggers") || [];
        for (i = 0, len = dcTriggerList.length; i < len; i += 1) {
            dcTrigger = dcTriggerList[i];
            if (dcTrigger.event === eventType) {
                if (eventType === "load" || eventType === "unload") {
                    if (dcTrigger.screenviews) {
                        capture = (-1 !== utils.indexOf(dcTrigger.screenviews, screenviewName));
                    } else {
                        capture = true;
                    }
                } else {
                    if (dcTrigger.targets) {
                        capture = (-1 !== utils.matchTarget(dcTrigger.targets, target));
                    } else {
                        capture = true;
                    }
                }
            }

            if (capture) {
                // Get the configuration (if any)
                captureConfig = utils.getValue(replayConfig, "domCapture.options", {});
                // Immediate or delayed?
                delay = dcTrigger.delay || 0;

                dcid = scheduleDOMCapture(window.document, captureConfig, delay);
                break;
            }
        }
        return dcid;
    }

    /**
     * Used to create control object from a webEvent.
     * TODO: Move tlType and similar normalization to message service.
     * XXX - Requires review and clean-up.
     * @private
     * @function
     * @name replay-createQueueEvent
     * @param {object} options An object with the following properties:
     *                 webEvent A webEvent that will created into a control.
     *                 id Id of the object.
     *                 prevState Previous state of the object.
     *                 currState Current state of the object.
     *                 visitedCount Visited count of the object.
     *                 dwell Dwell time on the object.
     *                 focusInOffset When you first focused on the object.
     * @return {object} Control object.
     */
    function createQueueEvent(options) {
        var control,
            dcid,
            target        = utils.getValue(options, "webEvent.target", {}),
            targetType    = target.type,
            targetSubtype = target.subType || null,
            tlType        = tlTypes[targetType.toLowerCase() + ":" + targetSubtype] || targetType,
            parents       = parentElements(utils.getValue(target, "element")),
            parentLinkNode = null,
            relXY         = utils.getValue(target, "position.relXY"),
            eventSubtype  = utils.getValue(options, "webEvent.subType", null);

        control = {
            type: 4,
            target: {
                id: target.id || "",
                idType: target.idType,
                name: target.name,
                tlType: tlType,
                type: targetType,
                position: {
                    width: utils.getValue(target, "element.offsetWidth"),
                    height: utils.getValue(target, "element.offsetHeight")
                },
                currState: options.currState || null
            },
            event: {
                tlEvent: getTlEvent(utils.getValue(options, "webEvent")),
                type: utils.getValue(options, "webEvent.type", "UNKNOWN")
            }
        };

        if (targetSubtype) {
            control.target.subType = targetSubtype;
        }

        if (relXY) {
            control.target.position.relXY = relXY;
        }

        if (typeof options.dwell === "number" && options.dwell > 0) {
            control.target.dwell = options.dwell;
        }

        if (typeof options.visitedCount === "number") {
            control.target.visitedCount = options.visitedCount;
        }

        if (typeof options.prevState !== "undefined") {
            control.prevState = options.prevState;
        }

        if (eventSubtype) {
            control.event.subType = eventSubtype;
        }

        // Add usability to config settings
        parentLinkNode = getParentLink(parents);
        control.target.isParentLink = !!parentLinkNode;
        if (parentLinkNode) {
            // Add the parent's href, value and innerText if the actual target doesn't
            // support these properties
            if (parentLinkNode.href) {
                control.target.currState = control.target.currState || {};
                control.target.currState.href = control.target.currState.href || parentLinkNode.href;
            }
            if (parentLinkNode.value) {
                control.target.currState = control.target.currState || {};
                control.target.currState.value = control.target.currState.value || parentLinkNode.value;
            }
            if (parentLinkNode.innerText || parentLinkNode.textContent) {
                control.target.currState = control.target.currState || {};
                control.target.currState.innerText = utils.trim(control.target.currState.innerText || parentLinkNode.innerText || parentLinkNode.textContent);
            }
        }

        if (utils.isUndefOrNull(control.target.currState)) {
            delete control.target.currState;
        }
        if (utils.isUndefOrNull(control.target.name)) {
            delete control.target.name;
        }

        // Check if DOM Capture needs to be triggered for this message.
        // If the event is click then DOM capture is only allowed if the target is click-able
        if (control.event.type !== "click" || isTargetClickable(target)) {
            // Check and add DOM Capture
            dcid = addDOMCapture(control.event.type, target);
            if (dcid) {
                control.dcid = dcid;
            }
        }

        return control;
    }

    function postUIEvent(queueEvent) {
        context.post(queueEvent);
    }

    function updateVisitOrder(msg) {
        var name = utils.getValue(msg, "target.name"),
            dwell = utils.getValue(msg, "target.dwell") || -1;

        if (name) {
            visitOrder += name + ":" + dwell + ";";
            lastVisit = name;
        }
    }

    /**
     * Posts all events from given array to the message service. The input
     * array is cleared on exit from the function.
     * Function additionally consolidates events fired on the same DOM element
     * TODO: Explain the consolidation process. Needs to be refactored!
     * @private
     * @param {Array} queue An array of QueueEvents
     * @return void
     */
    function postEventQueue(queue) {
        var i = 0,
            j,
            len = queue.length,
            e1,
            e2,
            tmp,
            ignoredEvents = {
                mouseout: true,
                mouseover: true
            },
            results = [];

        for (i = 0; i < len; i += 1) {
            e1 = queue[i];
            if (!e1) {
                continue;
            }
            if (ignoredEvents[e1.event.type]) {
                results.push(e1);
            } else {
                for (j = i + 1; j < len && queue[j]; j += 1) {
                    if (!ignoredEvents[queue[j].event.type]) {
                        break;
                    }
                }
                if (j < len) {
                    e2 = queue[j];
                    if (e2 && e1.target.id === e2.target.id && e1.event.type !== e2.event.type) {
                        if (e1.event.type === "click") {
                            tmp = e1;
                            e1 = e2;
                            e2 = tmp;
                        }
                        if (e2.event.type === "click") {
                            e1.target.position = e2.target.position;
                            i += 1;
                        } else if (e2.event.type === "blur") {
                            e1.target.dwell = e2.target.dwell;
                            e1.target.visitedCount = e2.target.visitedCount;
                            e1.focusInOffset = e2.focusInOffset;
                            e1.target.position = e2.target.position;
                            i += 1;
                        }
                        queue[j] = null;
                        queue[i] = e1;
                    }
                }
                results.push(queue[i]);
            }
        }

        for (e1 = results.shift(); e1; e1 = results.shift()) {
            updateVisitOrder(e1);
            context.post(e1);
        }
        queue.splice(0, queue.length);
    }


    if (typeof window.onerror !== "function") {
        window.onerror = function (msg, url, line) {
            var errorMessage = null;

            if (typeof msg !== "string") {
                return;
            }
            line = line || -1;
            errorMessage = {
                type: 6,
                exception: {
                    description: msg,
                    url: url,
                    line: line
                }
            };

            errorCount += 1;
            context.post(errorMessage);
        };
    }

    /**
     * Handles the focus events. It is fired either when the real focus event take place
     * or right after the click event on an element (only when browser focus event was not fired)
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleFocus(id, webEvent) {
        lastFocusEvent = webEvent;
        lastFocusEvent.inFocus = true;
        if (typeof pastEvents[id] === "undefined") {
            pastEvents[id] = {};
        }

        pastEvents[id].focus = lastFocusEvent.dwellStart = Number(new Date());
        pastEvents[id].focusInOffset = viewTimeStart ? lastFocusEvent.dwellStart - Number(viewTimeStart) : -1;
        pastEvents[id].prevState = utils.getValue(webEvent, "target.state");
        pastEvents[id].visitedCount = pastEvents[id].visitedCount + 1 || 1;
    }

    /**
     * Create and add value that will be posted to queue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function addToTmpQueue(webEvent, id) {
        tmpQueue.push(createQueueEvent({
            webEvent: webEvent,
            id: id,
            currState: utils.getValue(webEvent, "target.state")
        }));
    }

    /**
     * Handles blur events. It is invoked when browser blur events fires or from the
     * handleFocus method (only when browser 'blur' event didn't take place).
     * In the first case it's called with current event details, in the second one -
     * with lastFocusEvent. Method posts the tmpQueue of events. If during the same
     * focus time change event was fired the focus data will be combined together with
     * the last change event from the tmpQueue.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleBlur(id, webEvent) {
        var convertToBlur = false,
            dcid,
            lastQueueEvent,
            i = 0;

        if (typeof id === "undefined" || id === null || typeof webEvent === "undefined" || webEvent === null) {
            return;
        }

        lastFocusEvent.inFocus = false;

        if (typeof pastEvents[id] !== "undefined" && pastEvents[id].hasOwnProperty("focus")) {
            pastEvents[id].dwell =  Number(new Date()) - pastEvents[id].focus;
        } else {
            // Blur without any prior event on this control.
            pastEvents[id] = {};
            pastEvents[id].dwell = 0;
        }

        if (tmpQueue.length === 0) {
            // Orphaned blur without any prior event.
            addToTmpQueue(webEvent, id);
        }

        // Visited count is missing 
        if (tmpQueue[tmpQueue.length - 1]) {
            for (i = tmpQueue.length - 1; i >= 0; i--) {
                tmpQueue[i].target.visitedCount = pastEvents[id].visitedCount;
            }
        }

        lastQueueEvent = tmpQueue[tmpQueue.length - 1];
        if (lastQueueEvent) {
            lastQueueEvent.target.dwell = pastEvents[id].dwell;
            lastQueueEvent.focusInOffset = pastEvents[id].focusInOffset;
            lastQueueEvent.target.visitedCount = pastEvents[id].visitedCount;

            // if the click (without generating change event) fires on an
            // input element for which it's not relevant - report event as a blur and update the currState
            if (lastQueueEvent.event.type === "click") {
                if (!isTargetClickable(lastQueueEvent.target)) {
                    lastQueueEvent.target.currState = utils.getValue(webEvent, "target.state");
                    convertToBlur = true;
                }
            } else if (lastQueueEvent.event.type === "focus") {
                convertToBlur = true;
            }

            if (convertToBlur) {
                lastQueueEvent.event.type = "blur";
                lastQueueEvent.event.tlEvent = "focusout";
                // Check if DOM Capture needs to be triggered for this message.
                dcid = addDOMCapture(lastQueueEvent.event.type, webEvent.target);
                if (dcid) {
                    lastQueueEvent.dcid = dcid;
                }
            }
        }

        postEventQueue(tmpQueue);
    }

    /**
     * Checks to see in tmpQueue there is an older control that needs to be posted to server.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return Whether it has been sent to server.
     */
    function checkQueue(id, webEvent) {
        var hasInQueue = false;

        // TODO: Optimize the index by storing tmpQueue.length - 1 into a variable?
        if (tmpQueue.length > 0 && tmpQueue[tmpQueue.length - 1] && tmpQueue[tmpQueue.length - 1].target.id !== id &&
                // iOS scrolls & Android resizes after selecting a textbox
                webEvent.type !== "scroll" && webEvent.type !== "resize" &&
                // mouseover should not affect handleBlur invocation
                webEvent.type !== "mouseout" && webEvent.type !== "mouseover" &&
                // Need focus and click values to complete consolidation of message for these types
                (tmpQueue[tmpQueue.length - 1].target.tlType !== "textBox" &&
                tmpQueue[tmpQueue.length - 1].target.tlType !== "selectList")) {
            handleBlur(tmpQueue[tmpQueue.length - 1].target.id, tmpQueue[tmpQueue.length - 1]);
            hasInQueue = true;
        }
        return hasInQueue;
    }

    /**
     * Handles change and click events. Its called when browser 'change' event fires
     * or together with click event (from 'handleClick' method).
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleChange(id, webEvent) {
        if (typeof pastEvents[id] !== "undefined" && !pastEvents[id].hasOwnProperty("focus")) {
            handleFocus(id, webEvent);
        }

        addToTmpQueue(webEvent, id);

        if (typeof pastEvents[id] !== "undefined" && typeof pastEvents[id].prevState !== "undefined") {
            // TODO: Optimize the index by storing tmpQueue.length - 1 to a variable.
            if (tmpQueue[tmpQueue.length - 1].target.tlType === "textBox" ||
                    tmpQueue[tmpQueue.length - 1].target.tlType === "selectList") {
                tmpQueue[tmpQueue.length - 1].target.prevState = pastEvents[id].prevState;
            }
        }
    }

    /**
     * Sets the relative X & Y values to a webEvent.
     * TODO: Explain how relative X & Y should be calculated (in other words, define relative X & Y)
     * XXX - Shouldn't this be named "get" instead of "set"?
     * @private
     * @param {WebEvent} webEvent Normalized browser event
     * @return String value of relative X & Y
     */
    function setRelativeXY(webEvent) {
        var x = webEvent.target.position.x,
            y = webEvent.target.position.y,
            width = webEvent.target.size.width,
            height = webEvent.target.size.height,
            relX = Math.abs(x / width).toFixed(1),
            relY = Math.abs(y / height).toFixed(1);

        relX = relX > 1 || relX < 0 ? 0.5 : relX;
        relY = relY > 1 || relY < 0 ? 0.5 : relY;

        return relX + "," + relY;
    }

    /**
     * Handles click events. Additionally it recognizes situations when browser didn't
     * fire the focus event and in such case it invokes 'handleFocus' method.
     * @private
     * @param {string} id ID of an elment
     * @param {WebEvent} webEvent Normalized browser event
     * @return void
     */
    function handleClick(id, webEvent) {
        var relXY,
            addRelXY = true,
            tmpQueueLength = 0;

        if (webEvent.target.element.tagName === "SELECT" && lastClickEvent && lastClickEvent.target.id === id) {
            lastClickEvent = null;
            return;
        }

        if (!lastFocusEvent.inFocus) {
            handleFocus(id, webEvent);
        }

        // Sometimes the change triggers before the click (observed in Chrome and Android)
        // XXX - Not sure I fully understand this logic - MP
        tmpQueueLength = tmpQueue.length;
        if (tmpQueueLength && utils.getValue(tmpQueue[tmpQueueLength - 1], "event.type") !== "change") {
            handleChange(id, webEvent);
        }

        relXY = setRelativeXY(webEvent);

        // During use of arrow keys to select a radio option, it throws a click event after change event
        // which is incorrect for usability data. We only capture user clicks and not framework clicks.
        tmpQueueLength = tmpQueue.length;

        if (webEvent.position.x === 0 && webEvent.position.y === 0 && tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.tlType") === "radioButton") {
            addRelXY = false;
        } else {
            // For all other cases, record the relXY in the target.position
            webEvent.target.position.relXY = relXY;
        }

        // Update the existing queue entry with relXY info. from the click event
        if (tmpQueueLength &&
                utils.getValue(tmpQueue[tmpQueueLength - 1], "target.id") === id) {
            if (addRelXY) {
                tmpQueue[tmpQueueLength - 1].target.position.relXY = relXY;
            }
        } else {
            // Else add the click event to the queue
            addToTmpQueue(webEvent, id);
        }

        // XXX - What is lastClickEvent being used for? - MP
        lastClickEvent = webEvent;
    }

    /**
     * Returns the normalized orientation in degrees. Normalized values are measured
     * from the default portrait position which has an orientation of 0. From this
     * position the respective values are as follows:
     * 0   - Portrait orientation. Default
     * -90 - Landscape orientation with screen turned clockwise.
     * 90  - Landscape orientation with screen turned counterclockwise.
     * 180 - Portrait orientation with screen turned upside down.
     * @private
     * @function
     * @name replay-getNormalizedOrientation
     * @param {object} webEvent A normalized event object per the WebEvent
     * @return {integer} The normalized orientation value.
     */
    function getNormalizedOrientation(webEvent) {
        var orientation = 0;
        if (window.orientation) {
            orientation = window.orientation;
        } else if (webEvent !== undefined && webEvent.orientation) {
            orientation = webEvent.orientation;
        }

        // XXX - This functionality should probably be moved into the browser service.
        // TODO: Normalize for Android
        return orientation;
    }


    /**
     * Handles the "orientationchange" event and posts the appropriate message
     * to the replay module's queue.
     * @private
     * @function
     * @name replay-handleOrientationChange
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleOrientationChange(webEvent) {
        var newOrientation = getNormalizedOrientation(webEvent),
            orientationChangeEvent = {
                type: 4,
                event: {
                    type: "orientationchange"
                },
                target: {
                    prevState: {
                        orientation: currOrientation,
                        orientationMode: utils.getOrientationMode(currOrientation)
                    },
                    currState: {
                        orientation: newOrientation,
                        orientationMode: utils.getOrientationMode(newOrientation)
                    }
                }
            };

        postUIEvent(orientationChangeEvent);
        currOrientation = newOrientation;
    }

    /* TODO: Refactor this to use a well-defined touchState object */
    function isDuplicateTouch(touchState) {
        var result = false;

        if (!touchState) {
            return result;
        }

        result = (savedTouch.scale === touchState.scale &&
                Math.abs((new Date()).getTime() - savedTouch.timestamp) < 500);

        return result;
    }

    function saveTouchState(touchState) {
        savedTouch.scale = touchState.scale;
        savedTouch.rotation = touchState.rotation;
        savedTouch.timestamp = (new Date()).getTime();
    }

    /**
     * Takes the scale factor and returns the pinch mode as a text string.
     * Values less than 1 correspond to a pinch close gesture. Values greater
     * than 1 correspond to a pinch open gesture.
     * @private
     * @function
     * @name replay-getPinchType
     * @return {String} "CLOSE", "OPEN" or "NONE" for valid scale values.
     * "INVALID" in case of error.
     */
    function getPinchType() {
        var s,
            pinchType;

        s = deviceScale - previousDeviceScale;
        if (isNaN(s)) {
            pinchType = "INVALID";
        } else if (s < 0) {
            pinchType = "CLOSE";
        } else if (s > 0) {
            pinchType = "OPEN";
        } else {
            pinchType = "NONE";
        }

        return pinchType;
    }

    function addLegacyHeaders(eventType) {
        var pageObjects = [],
            renderTime = 0,
            RENDER_TIME_CAP = 3600000,
            timing = null;

        switch (eventType) {
        case "load":
            pageLoadTime = (new Date()).getTime();

            pageObjects = window.document.getElementsByName("object");
            context.addHeader("X-TeaLeaf-Page-Objects", pageObjects.length);
            break;
        case "unload":
            // Add the render time to the HTTP headers
            timing = utils.getValue(window, "performance.timing");
            if (timing && timing.loadEventStart) {
                renderTime = Math.abs(timing.loadEventStart - timing.responseEnd);
                context.addHeader("X-TeaLeaf-Page-Render", renderTime > RENDER_TIME_CAP ? RENDER_TIME_CAP : renderTime);
            }

            // Add the dwell time to the HTTP headers
            pageDwellTime = (new Date()).getTime() - pageLoadTime;
            context.addHeader("X-TeaLeaf-Page-Dwell", pageDwellTime);

            context.addHeader("X-TeaLeaf-Page-Cui-Exceptions", errorCount);

            context.addHeader("X-TeaLeaf-Visit-Order", visitOrder);

            context.addHeader("X-TeaLeaf-Page-Last-Field", lastVisit);
            break;
        default:
            break;
        }
    }

    /**
     * Used to create the client state message from a webEvent.
     * @private
     * @function
     * @name replay-getClientStateMessage
     * @param {object} webEvent A webEvent that will be used to create the clientState.
     * @return {object} Client state message object.
     */
    function getClientStateMessage(webEvent) {
        var documentElement = document.documentElement,
            documentBody = document.body,
            msg = {
                type: 1,
                clientState: {
                    pageWidth: document.width || (!documentElement ? 0 : documentElement.offsetWidth),
                    pageHeight: Math.max((!document.height ? 0 : document.height), (!documentElement ? 0 : documentElement.offsetHeight), (!documentElement ? 0 : documentElement.scrollHeight)),
                    viewPortWidth: window.innerWidth || documentElement.clientWidth,
                    viewPortHeight: window.innerHeight || documentElement.clientHeight,
                    viewPortX: window.pageXOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollLeft) : documentElement.scrollLeft || 0),
                    viewPortY: window.pageYOffset || (!documentElement ? (!documentBody ? 0 : documentBody.scrollTop) : documentElement.scrollTop || 0),
                    deviceOrientation: window.orientation || 0,
                    event: utils.getValue(webEvent, "type")
                }
            },
            deviceWidth = 1,
            scaleWidth = 1;

        pastClientState = pastClientState || msg;

        if (Math.abs(msg.clientState.deviceOrientation) === 90) {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalHeight - deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalHeight - deviceToolbarHeight : ((deviceOriginalHeight / devicePixelRatio) - deviceToolbarHeight);
            }
        } else {
            if (isApple || isAndroidChrome) {
                deviceWidth = deviceOriginalWidth + deviceToolbarHeight;
            } else {
                // Need to display web content no smaller than 320 or it will look incorrect. Older Android devices give these values due to they are built on a webview and not an actual browser.
                deviceWidth = deviceOriginalWidth <= 320 ? deviceOriginalWidth - deviceToolbarHeight : ((deviceOriginalWidth / devicePixelRatio) - deviceToolbarHeight);
            }
        }

        scaleWidth = (msg.clientState.viewPortWidth === 0 ? 1 : deviceWidth / msg.clientState.viewPortWidth);

        // Made scale a bit smaller to adjust for scroll bars that appear on top of content on certain browsers.
        msg.clientState.deviceScale = (scaleWidth - 0.02).toFixed(3);

        // Set the viewTime for this client state
        msg.clientState.viewTime = 0;
        if (scrollViewStart && scrollViewEnd) {
            msg.clientState.viewTime = scrollViewEnd.getTime() - scrollViewStart.getTime();
        }

        if (webEvent.type === "scroll") {
            msg.clientState.viewPortXStart = pastClientState.clientState.viewPortX;
            msg.clientState.viewPortYStart = pastClientState.clientState.viewPortY;
        }

        return msg;
    }

    /**
     * Post the current client state and also record it as pastClientState.
     * Reset the scrollViewStart/End values.
     * @private
     * @function
     * @name replay-sendClientState
     */
    function sendClientState() {
        if (curClientState) {
            postUIEvent(curClientState);
            pastClientState = curClientState;
            curClientState = null;
            scrollViewStart = nextScrollViewStart || scrollViewStart;
            scrollViewEnd = null;
        }
    }

    /**
     * Used to create client state from a webEvent.
     * @private
     * @function
     * @name replay-handleClientState
     * @param {object} webEvent A webEvent that will created into a clientState and saved for previous and current client state.
     * @return {object} Client state object.
     */
    function handleClientState(webEvent) {
        var attentionMsg = null;

        curClientState = getClientStateMessage(webEvent);

        // TODO: Change these if-else to a switch statement
        if (webEvent.type === "scroll" || webEvent.type === "resize") {
            // Set the interval timeout so we can collect related scroll / resize events in one batch
            if (sendClientState.timeoutId) {
                window.clearTimeout(sendClientState.timeoutId);
                sendClientState.timeoutId = 0;
            }
            sendClientState.timeoutId = window.setTimeout(sendClientState, utils.getValue(config, "scrollTimeout", 2000));
        } else if (webEvent.type === "touchstart" || webEvent.type === "load") {
            if (curClientState) {
                // set the initial device scale which is used to determine what type of pinch happened
                previousDeviceScale = parseFloat(curClientState.clientState.deviceScale);
            }
        } else if (webEvent.type === "touchend") {
            if (curClientState) {
                // used to determine what type of pinch happened
                deviceScale = parseFloat(curClientState.clientState.deviceScale);
                // Send client state on touchend
                sendClientState();
            }
        }

        if (webEvent.type === "load" || webEvent.type === "unload") {
            // The "Attention" event is deprecated
            if (webEvent.type === "unload" && pageLoadTime) {
                // Save the "attention" event which is essentially a dup of the unload with viewTime starting from page load.
                attentionMsg = utils.clone(curClientState);
                attentionMsg.clientState.event = "attention";
                attentionMsg.clientState.viewTime = (new Date()).getTime() - pageLoadTime;
            }

            sendClientState();

            if (attentionMsg) {
                // send the attentionMsg
                curClientState = attentionMsg;
                sendClientState();
            }
        }

        return curClientState;
    }

    /**
     * Handles the "touchstart" event, which is only used to get the deviceScale before a pinch
     * @private
     * @function
     * @name replay-handleTouchStart
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchStart(webEvent) {
        var fingerCount = utils.getValue(webEvent, "nativeEvent.touches.length", 0);

        if (fingerCount === 2) {
            handleClientState(webEvent);
        }
    }

    /**
     * Handles the "touchend" event and posts the appropriate message to the
     * replay module's queue.
     * @private
     * @function
     * @name replay-handleTouchEnd
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleTouchEnd(webEvent) {
        var fingerCount,
            prevTouchState = {},
            // Rotation angle for android devices does not work for all devices/browsers
            rotation = utils.getValue(webEvent, "nativeEvent.rotation", 0) || utils.getValue(webEvent, "nativeEvent.touches[0].webkitRotationAngle", 0),
            scale = utils.getValue(webEvent, "nativeEvent.scale", 1),
            touchState = null,
            touchEndEvent = {
                type: 4,
                event: {
                    type: "touchend"
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        // count the number of fingers placed on the screen
        fingerCount = utils.getValue(webEvent, "nativeEvent.changedTouches.length", 0) + utils.getValue(webEvent, "nativeEvent.touches.length", 0);
        if (fingerCount !== 2) {
            return;
        }

        // 1st handle the client state change. This will update the device scale information.
        handleClientState(webEvent);

        // Only post when there are two fingers reported by the touchend event object
        // create the current touchstate
        touchState = {
            rotation: rotation ? rotation.toFixed(2) : 0,
            scale: deviceScale ? deviceScale.toFixed(2) : 1
        };
        touchState.pinch = getPinchType();

        // create the prev touch state
        prevTouchState.scale = previousDeviceScale ? previousDeviceScale.toFixed(2) : 1;

        // Set the curr and prev states
        touchEndEvent.target.prevState = prevTouchState;
        touchEndEvent.target.currState = touchState;

        postUIEvent(touchEndEvent);
    }

    /**
     * Compares two WebEvent's to determine if they are duplicates. Examines
     * the event type, target id and the timestamp to make this determination.
     * XXX - Push this into the browser service or core?!?
     * @private
     * @function
     * @name replay-isDuplicateEvent
     * @param {object} curr A WebEvent object
     * @param {object} prev A WebEvent object
     * @return {boolean} Returns true if the WebEvents are duplicates.
     */
    function isDuplicateEvent(curr, prev) {
        var propsToCompare = ["type", "target.id"],
            prop = null,
            i,
            len,
            duplicate = true,
            DUPLICATE_EVENT_THRESHOLD_TIME = 10,
            timeDiff = 0,
            currTimeStamp = 0,
            prevTimeStamp = 0;

        // Sanity check
        if (!curr || !prev || typeof curr !== "object" || typeof prev !== "object") {
            duplicate = false;
        }

        // Compare WebEvent properties
        for (i = 0, len = propsToCompare.length; duplicate && i < len; i += 1) {
            prop = propsToCompare[i];
            if (utils.getValue(curr, prop) !== utils.getValue(prev, prop)) {
                duplicate = false;
                break;
            }
        }

        if (duplicate) {
            currTimeStamp = utils.getValue(curr, "timestamp");
            prevTimeStamp = utils.getValue(prev, "timestamp");
            // Don't compare if neither objects have a timestamp
            if (!(isNaN(currTimeStamp) && isNaN(prevTimeStamp))) {
                // Check if the event timestamps are within the predefined threshold
                timeDiff = Math.abs(utils.getValue(curr, "timestamp") - utils.getValue(prev, "timestamp"));
                if (isNaN(timeDiff) || timeDiff > DUPLICATE_EVENT_THRESHOLD_TIME) {
                    duplicate = false;
                }
            }
        }

        return duplicate;
    }

    /**
     * Keeps track of the location.hash and logs the appropriate screenview messages
     * when a hash change is detected.
     * @private
     * @function
     * @name replay-trackHashchange
     */
    function trackHashchange() {
        var currHash = window.location.hash;

        if (currHash === prevHash) {
            return;
        }

        // TODO: Expose logScreenview on context so we don't reference TLT
        if (prevHash) {
            // Send the screenview unload
            TLT.logScreenviewUnload(prevHash);
        }

        if (currHash) {
            // Send the screenview load
            TLT.logScreenviewLoad(currHash);
        }

        // Save the current hash value
        prevHash = currHash;
    }

    /**
      * Returns true if the key (localStorage key) is to be captured. The key is considered
      * to be filtered out if it does not exists in the capture object.
      * @private
      * @function
      * @name replay-isStorageKeyCaptured
      * @param {string} key The key name to be tested
      * associated boolean value. A key marked false will be filtered out or if the key in not found
      * @return {boolean} true if the key is to be captured, false otherwise.
      */
    function isStorageKeyCaptured(key) {
        //[capture] An object that contains key names
        var capture = config.storageKeys;

        // Sanity check
        if (typeof key !== "string") {
            return false;
        }

        if (utils.indexOf(capture, key) === -1) {
            return false;
        }
        return true;
    }

    /**
     * Handles the "webStorage" event and posts the appropriate message to the
     * replay module's queue only if isStorage(key)
     * @private
     * @function
     * @name replay-handleStorage
     * @param {object} webEvent A normalized event object per the WebEvent
     * interface definition.
     */
    function handleStorage(data) {
        var storage = null;
        if (data && isStorageKeyCaptured(data.key)) {
            storage = {
                type: 8,
                webStorage: data
            };

            postUIEvent(storage);
        }

        return storage;
    }

    /**
     * Extend the getItem() method of the object Storage
     * This is done to capture reads from localStorage.getItem().
     * Assuming client js is using this api and this method is run before everything else.
     * @private
     * @function
     * @name replay extendGetItem
     * @returns {Boolean} false for failiure and true for success.
     **/
    extendGetItem = (function (window) {
        var _getItem = window.Storage ? window.Storage.prototype.getItem : function () {};

        return function () {
            var storageData;
            try {
                window.Storage.prototype.getItem = function (key) {
                    try {
                        var value = _getItem.call(localStorage, key);
                        storageData = {
                            key: key || null,
                            value: value
                        };

                        handleStorage(storageData);
                        return value;
                    } catch (e) {}
                };
            } catch (e) {
                return false;
            }
            return true;
        };
    }(window));

    /**
     * Default handler for event types that are not being processed by the module.
     * @private
     * @function
     * @param {object} webEvent A WebEvent object
     * @name replay-defaultEventHandler
     */
    function defaultEventHandler(webEvent) {
        var msg = {
                type: 4,
                event: {
                    type: webEvent.type
                },
                target: {
                    id: utils.getValue(webEvent, "target.id"),
                    idType: utils.getValue(webEvent, "target.idType")
                }
            };

        postUIEvent(msg);
    }

    return {
        // Expose private functions for unit testing
        tlTypes: tlTypes,
        currOrientation: currOrientation,
        pastEvents: pastEvents,
        lastEventId: lastEventId,
        getTmpQueue: function () { return tmpQueue; },
        postEventQueue: postEventQueue,
        eventCounter: eventCounter,
        curClientState: curClientState,
        getViewEventStart: function () { return viewEventStart; },
        setViewEventStart: function (newViewEventStart) {viewEventStart = newViewEventStart; },
        viewTimeStart: viewTimeStart,
        parentElements: parentElements,
        getParentLink: getParentLink,
        createQueueEvent: createQueueEvent,
        postUIEvent: postUIEvent,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleChange: handleChange,
        handleClick: handleClick,
        getNormalizedOrientation: getNormalizedOrientation,
        handleOrientationChange: handleOrientationChange,
        handleClientState: handleClientState,
        getPinchType: getPinchType,
        saveTouchState: saveTouchState,
        isDuplicateTouch: isDuplicateTouch,
        getTlEvent: getTlEvent,
        isDuplicateEvent: isDuplicateEvent,
        scheduleDOMCapture: scheduleDOMCapture,
        addDOMCapture: addDOMCapture,
        trackHashchange: trackHashchange,
        isTargetClickable: isTargetClickable,
        defaultEventHandler: defaultEventHandler,
        extendGetItem: extendGetItem,
        isStorageKeyCaptured: isStorageKeyCaptured,
        handleStorage: handleStorage,
        init: function () {
            tmpQueue = [];
        },
        destroy: function () {
            handleBlur(lastEventId);
            tmpQueue = [];
        },
        onevent: function (webEvent) {
            var id = null,
                returnObj = null;

            // Sanity checks
            if (typeof webEvent !== "object" || !webEvent.type) {
                return;
            }

            if (isDuplicateEvent(webEvent, prevWebEvent)) {
                prevWebEvent = webEvent;
                return;
            }

            prevWebEvent = webEvent;

/*jshint devel:true */

            if (typeof console !== "undefined") {
                console.log("Replay event: ", webEvent);
            }

            id = utils.getValue(webEvent, "target.id");

            if (Object.prototype.toString.call(pastEvents[id]) !== "[object Object]") {
                pastEvents[id] = {};
            }

            checkQueue(id, webEvent);
            inBetweenEvtsTimer = new Date();

            switch (webEvent.type) {
            case "hashchange":
                trackHashchange();
                break;
            case "focus":
                returnObj = handleFocus(id, webEvent);
                break;
            case "blur":
                returnObj = handleBlur(id, webEvent);
                break;
            case "click":
                // Normal click processing
                returnObj = handleClick(id, webEvent);
                break;
            case "change":
                returnObj = handleChange(id, webEvent);
                break;
            case "orientationchange":
                returnObj = handleOrientationChange(webEvent);
                break;
			case "touchstart":
				handleTouchStart(webEvent);
				break;
            case "touchend":
                returnObj = handleTouchEnd(webEvent);
                break;
            case "load":
                extendGetItem();
                addLegacyHeaders("load");
                // initialize the start time for the scrolled view
                scrollViewStart = new Date();

                // send initial clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewLoad("root");

                break;
            case "screenview_load":
                // starts screenview time used for calculating the offset
                viewTimeStart = new Date();

                // Check and add DOM Capture
                returnObj = addDOMCapture("load", null, webEvent.name);

                break;
            case "screenview_unload":
                // Check and add DOM Capture
                returnObj = addDOMCapture("unload", null, webEvent.name);

                break;
            case "resize":
            case "scroll":
                if (!scrollViewEnd) {
                    scrollViewEnd = new Date();
                }
                nextScrollViewStart = new Date();

                handleClientState(webEvent);

                break;
            case "unload":
                // Flush any saved control
                if (tmpQueue !== null) {
                    postEventQueue(tmpQueue);
                }

                addLegacyHeaders("unload");
                // set the final timestamp of this scrolled view.
                scrollViewEnd = new Date();

                // send final clientstate
                handleClientState(webEvent);

                // XXX - Use the context instead?
                TLT.logScreenviewUnload("root");

                break;
            default:
                // Call the default handler for all other DOM events
                defaultEventHandler(webEvent);
                break;
            }

            lastEventId = id;
            return returnObj;
        },
        onmessage: function () {
        }
    };
});

/**
 * Licensed Materials - Property of IBM
 *  Copyright IBM Corp. 2014
 * US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @fileOverview The SaaS module implements the logic for using Tealeaf in the cloud.
 * @exports saas
 */

/*global TLT:true */

// Sanity check
TLT.addModule("saas", function (context) {
    "use strict";

    /**
     * Sets the SaaS data object to the configuration specified by the user in the config.
     * @private
     */
    var SaasData = function () {
			if (typeof TLT.getCoreConfig().modules.saas !== "undefined") {
				var key;

				for (key in TLT.getCoreConfig().modules.saas) {
					if (TLT.getCoreConfig().modules.saas.hasOwnProperty(key) && typeof key === "string" && typeof TLT.getCoreConfig().modules.saas[key] === "string") {
						this[key] = TLT.getCoreConfig().modules.saas[key];
						document.cookie = key + "=" + this[key];
					}
				}

				/**
				* Gets Tealeaf SaaS session data
				* @function
				* @name saas-saasData.get
				* @param {string} key SaaS session key to get.
				* @return {string} Value associated with the SaaS session key or error description.
				*/
				this.get = function (key) {
					if (typeof key !== "string" || typeof this === "undefined") {
						return "SaaS Data undefined or key is not a string";
					}
					if (typeof this[key] === "undefined") {
						return "Key does not exist within saasData";
					}
					return this[key];
				};

				/**
				* Sets Tealeaf SaaS session data.
				* @function
				* @name saas-saasData.set
				* @param {string} key SaaS session key to be changed or created.
				* @param {string} value SaaS session value to be set.
				* @return {boolean} True if the cookie was set, false if not.
				*/
				this.set = function (key, value) {
					if (typeof key !== "string" || typeof value !== "string" || typeof this === "undefined" || key === "get" || key === "set" || key === "toSaasString" || key === "clear" || key === "remove") {
						return false;
					}
					this[key] = value;
					document.cookie = key + "=" + value;
					return true;
				};

				/**
				* Clears Tealeaf SaaS data.
				* @function
				* @name saas-saasData.clear
				* @returns {void}
				*/
				this.clear = function () {
					var key;
					for (key in this) {
						if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
							document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
							delete this[key];
						}
					}
					return;
				};

				/**
				* Removes a key/value pair from Tealeaf SaaS data.
				* @function
				* @name saas-saasData.remove
				* @returns {void}
				*/
				this.remove = function (key) {
					if (this.hasOwnProperty(key) && key !== "get" && key !== "set" && key !== "toSaasString" && key !== "clear" && key !== "remove") {
						document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
						delete this[key];
					}
					return;
				};

				/**
				* Converts Tealeaf SaaS session key/value pairs into a semi-colon separated string
				* @function
				* @name saas-saasData.toString
				* @return {string} Key/value pairs in a semi-colon separated string like "key1=value1;key2=value2..."
				*/
				this.toSaasString = function () {
					var saasDataString = "",
						key;
					for (key in this) {
						if (this.hasOwnProperty(key) && typeof this.get(key) === "string") {
							saasDataString += key + "=" + this.get(key) + ";";
						}
					}
					return saasDataString;
				};
			}
		},
		_saasData = new SaasData();

    // Return the module's interface object. This contains callback functions which
    // will be invoked by the UIC core.
    return {
        init: function () {
            // Attach any custom event handlers here
			TLT.saasData = _saasData;
        },
        destroy: function () {
            // Detach any custom event handlers here
        },
        onevent: function (webEvent) {
            // Process DOM events that you registered in the configuration as
            // per your customized requirements
        }
    };

});
</script>
</div>


<script src="scripts/filesaver.js"></script>
<script src="scripts/form2js.js"></script>
<script src="scripts/main.js"></script>

</body>
</html>